<!DOCTYPE html>
<html lang="zh-cmn-Hans">
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <meta http-equiv="”Cache-Control”" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  
  <title>使用 screen 管理远程会话 | Skuaka</title>
  <link rel="icon" type="image/png" sizes="32x32" href>
  



<link rel="stylesheet" href="/./vendor.ec1199.css"><link rel="stylesheet" href="/./app.5ed5af.css">


</head>
  <body>
    <header class="main-header">
  <div class="container">
    <a href="/" " class="logo">
      <img src="logo.jpg" alt="Skuaka" class="logo-img">
    </a>
    <span class="nav-separator"></span>
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索文章"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
    <a href="javascript:void(0);" class="nav-icon">
      <i class="fas fa-bars"></i>
    </a>
    <nav class="main-nav">
      <ul class="nav-list">
        
          <li class="nav-link ">
            <a href="/">首页</a>
          </li>
        
          <li class="nav-link ">
            <a href="/archives/">归档</a>
          </li>
        
          <li class="nav-link ">
            <a href="/categories">分类</a>
          </li>
        
          <li class="nav-link ">
            <a href="/about.html">关于</a>
          </li>
        
      </ul>
    </nav>
  </div>
</header>
    <div class="page--article">
  
    <div class="toc-container">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#使用-screen-管理远程会话"><span class="toc-number">1.</span> <span class="toc-text">使用 screen 管理远程会话</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概览"><span class="toc-number">1.1.</span> <span class="toc-text">概览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#元凶就是-SIGHUP-信号"><span class="toc-number">1.1.1.</span> <span class="toc-text">元凶就是 SIGHUP 信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nohup命令"><span class="toc-number">1.1.2.</span> <span class="toc-text">nohup命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Screen"><span class="toc-number">1.2.</span> <span class="toc-text">使用Screen</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建新窗口"><span class="toc-number">1.2.1.</span> <span class="toc-text">创建新窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#断开与重连"><span class="toc-number">1.2.2.</span> <span class="toc-text">断开与重连</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#键绑定Ctrl-a"><span class="toc-number">1.2.3.</span> <span class="toc-text">键绑定Ctrl-a</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用选项"><span class="toc-number">1.2.4.</span> <span class="toc-text">常用选项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结束"><span class="toc-number">2.</span> <span class="toc-text">结束</span></a></li></ol>
      <div class="toc-tip">Table of Contents ▼</div>
    </div>
  


  <div class="container">
    <article>
      <h1>使用 screen 管理远程会话</h1>
      <h1 id="使用-screen-管理远程会话"><a href="#使用-screen-管理远程会话" class="headerlink" title="使用 screen 管理远程会话"></a>使用 screen 管理远程会话</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>你是不是经常需要 SSH 或者 telent 远程登录到 Linux 服务器？你是不是经常为一些长时间运行的任务而头疼，比如系统备份、ftp 传输等等。通常情况下我们都是为每一个这样的任务开一个远程终端窗口，因为他们执行的时间太长了。必须等待它执行完毕，在此期间可不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。</p>
<h3 id="元凶就是-SIGHUP-信号"><a href="#元凶就是-SIGHUP-信号" class="headerlink" title="元凶就是 SIGHUP 信号"></a>元凶就是 SIGHUP 信号</h3><ul>
<li>当终端接口检测到网络连接断开，将挂断信号发送给控制进程（会话期首进程）。</li>
<li>如果会话期首进程终止，则该信号发送到该会话期前台进程组。</li>
<li>一个进程退出导致一个孤儿进程组中产生时，如果任意一个孤儿进程组进程处于STOP状态，发送SIGHUP和SIGCONT信号到该进程组中所有进程。</li>
</ul>
<p>因此当网络断开或终端窗口关闭后，控制进程收到SIGHUP信号退出，会导致该会话期内其他进程退出。</p>
<h3 id="nohup命令"><a href="#nohup命令" class="headerlink" title="nohup命令"></a>nohup命令</h3><p>如果我们可以忽略SIGHUP信号，关掉窗口应该就不会影响程序的运行了。nohup命令可以达到这个目的，如果程序的标准输出/标准错误是终端，nohup默认将其重定向到nohup.out文件。值得注意的是nohup命令只是使得程序忽略SIGHUP信号，还需要使用标记<strong>&amp;</strong>把它放在后台运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup &lt;command&gt; [argument…] &amp;</span><br></pre></td></tr></table></figure>
<p>虽然nohup很容易使用，但还是比较“简陋”的，对于简单的命令能够应付过来，对于复杂的需要人机交互的任务就麻烦了。</p>
<p>其实我们可以使用一个更为强大的实用程序screen。流行的Linux发行版通常会自带screen实用程序，如果没有的话，可以从GNU screen的官方网站下载。</p>
<h2 id="使用Screen"><a href="#使用Screen" class="headerlink" title="使用Screen"></a>使用Screen</h2><p>简单来说，Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。</p>
<h3 id="创建新窗口"><a href="#创建新窗口" class="headerlink" title="创建新窗口"></a>创建新窗口</h3><ol>
<li><p>直接在命令行键入screen命令</p>
<p><code>screen</code></p>
<p>Screen将创建一个执行shell的全屏窗口。你可以执行任意shell程序，就像在ssh窗口中那样。在该窗口中键入exit退出该窗口，如果这是该screen会话的唯一窗口，该screen会话退出，否则screen自动切换到前一个窗口。</p>
</li>
<li><p>Screen命令后跟你要执行的程序</p>
<p><code>screen vi test.c</code></p>
<p>Screen创建一个执行vi test.c的单窗口会话，退出vi将退出该窗口/会话。</p>
</li>
<li><p>以上两种方式都创建新的screen会话。我们还可以在一个已有screen会话中创建新的窗口。在当前screen窗口中键入Ctrl键+a键，之后再按下c键，screen 在该会话内生成一个新的窗口并切换到该窗口。</p>
</li>
</ol>
<h3 id="断开与重连"><a href="#断开与重连" class="headerlink" title="断开与重连"></a>断开与重连</h3><p>screen还有更高级的功能。你可以不中断screen窗口中程序的运行而暂时断开（detach）screen会话，并在随后时间重新连接（attach）该会话，重新控制各窗口中运行的程序。</p>
<p>例如，我们打开一个screen窗口编辑/tmp/abc文件：</p>
<p><code>screen vi /tmp/abc</code></p>
<p>之后我们想暂时退出做点别的事情，那么在screen窗口键入<code>C-a d</code>，Screen会给出detached提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@host ~]# screen -ls</span><br><span class="line">There is a screen on:</span><br><span class="line">        16582.pts-1.tivf06      (Detached)</span><br><span class="line">1 Socket in /tmp/screens/S-root.</span><br></pre></td></tr></table></figure>
<p>然后重新重新连接会话：</p>
<p><code>screen -r 16582</code></p>
<h3 id="键绑定Ctrl-a"><a href="#键绑定Ctrl-a" class="headerlink" title="键绑定Ctrl-a"></a>键绑定Ctrl-a</h3><p>你可能注意到给screen发送命令使用了特殊的键组合C-a。这是因为我们在键盘上键入的信息是直接发送给当前screen窗口，必须用其他方式向screen窗口管理器发出命令，默认情况下，screen接收以C-a开始的命令。这种命令形式在screen中叫做键绑定（key binding），C-a叫做命令字符（command character）。</p>
<p>可以通过<code>C-a ?</code>来查看所有的键绑定，常用的键绑定有：</p>
<table>
<thead>
<tr>
<th>C-a ?</th>
<th>显示所有键绑定信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>C-a w</td>
<td>显示所有窗口列表</td>
</tr>
<tr>
<td>C-a C-a</td>
<td>切换到之前显示的窗口</td>
</tr>
<tr>
<td>C-a c</td>
<td>创建一个新的运行shell的窗口并切换到该窗口</td>
</tr>
<tr>
<td>C-a n</td>
<td>切换到下一个窗口</td>
</tr>
<tr>
<td>C-a p</td>
<td>切换到前一个窗口(与C-a n相对)</td>
</tr>
<tr>
<td>C-a 0..9</td>
<td>切换到窗口0..9</td>
</tr>
<tr>
<td>C-a a</td>
<td>发送 C-a到当前窗口</td>
</tr>
<tr>
<td>C-a d</td>
<td>暂时断开screen会话</td>
</tr>
<tr>
<td>C-a k</td>
<td>杀掉当前窗口</td>
</tr>
<tr>
<td>C-a [</td>
<td>进入拷贝/回滚模式</td>
</tr>
</tbody>
</table>
<h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><p><strong>-e 选项</strong></p>
<p>因为screen把C-a看作是screen命令的开始，所以如果你想要screen窗口接收到C-a字符，就要输入C-a a。Screen也允许你使用-e选项设置自己的命令字符和转义字符，其格式为：</p>
<p><code>-e xy</code>  x为命令字符，y为转义命令字符的字符</p>
<p>下面命令启动的screen会话指定了命令字符为C-t，转义C-t的字符为t，通过C-t ?命令可以看到该变化。</p>
<p><code>screen -e tt</code></p>
<p><strong>其他常用的选项</strong></p>
<table>
<thead>
<tr>
<th>-c file</th>
<th>使用配置文件file，而不使用默认的$HOME/.screenrc</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d\</td>
<td>-D [pid.tty.host]</td>
<td>不开启新的screen会话，而是断开其他正在运行的screen会话</td>
</tr>
<tr>
<td>-h num</td>
<td>指定历史回滚缓冲区大小为num行</td>
</tr>
<tr>
<td>-list\</td>
<td>-ls</td>
<td>列出现有screen会话，格式为pid.tty.host</td>
</tr>
<tr>
<td>-d -m</td>
<td>启动一个开始就处于断开模式的会话</td>
</tr>
<tr>
<td>-r sessionowner/ [pid.tty.host]</td>
<td>重新连接一个断开的会话。多用户模式下连接到其他用户screen会话需要指定sessionowner，需要setuid-root权限</td>
</tr>
<tr>
<td>-S sessionname</td>
<td>创建screen会话时为会话指定一个名字</td>
</tr>
<tr>
<td>-v</td>
<td>显示screen版本信息</td>
</tr>
<tr>
<td>-wipe [match]</td>
<td>同-list，但删掉那些无法连接的会话</td>
</tr>
</tbody>
</table>
<p><strong>-d –m 选项</strong></p>
<p>启动一个开始就处于断开模式的会话。你可以在随后需要的时候连接上该会话。有时候这是一个很有用的功能，比如我们可以使用它调试后台程序。该选项一个更常用的搭配是：<code>-dmS sessionname</code></p>
<p>启动一个初始状态断开的screen会话：</p>
<p><code>screen -dmS mygdb gdb execlp_test</code></p>
<p>连接该会话：</p>
<p><code>screen -r mygdb</code></p>
<p>结束会话：</p>
<p><code>screen -S session_name -X quit</code></p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1>
  </article>
    
  </div>
</div>

    <footer class="main-footer">
  <div class="container">
    © 2018 
  </div>
</footer>
    



<script src="/./runtime.32f029.js"></script><script src="/./vendor.ec1199.js"></script><script src="/./app.5ed5af.js"></script>


  </body>
</html>
