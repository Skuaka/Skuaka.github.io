<!DOCTYPE html>
<html lang="zh-cmn-Hans">
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <meta http-equiv="”Cache-Control”" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  
  <title>C++模板元编程(待续 | Skuaka</title>
  <link rel="icon" type="image/png" sizes="32x32" href>
  



<link rel="stylesheet" href="/./vendor.ec1199.css"><link rel="stylesheet" href="/./app.5ed5af.css">


</head>
  <body>
    <header class="main-header">
  <div class="container">
    <a href="/" " class="logo">
      <img src="logo.jpg" alt="Skuaka" class="logo-img">
    </a>
    <span class="nav-separator"></span>
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索文章"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
    <a href="javascript:void(0);" class="nav-icon">
      <i class="fas fa-bars"></i>
    </a>
    <nav class="main-nav">
      <ul class="nav-list">
        
          <li class="nav-link ">
            <a href="/">首页</a>
          </li>
        
          <li class="nav-link ">
            <a href="/archives/">归档</a>
          </li>
        
          <li class="nav-link ">
            <a href="/categories">分类</a>
          </li>
        
          <li class="nav-link ">
            <a href="/about.html">关于</a>
          </li>
        
      </ul>
    </nav>
  </div>
</header>
    <div class="page--article">
  
    <div class="toc-container">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#今天刚开始学"><span class="toc-number">1.</span> <span class="toc-text">今天刚开始学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例子"><span class="toc-number">1.1.</span> <span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#阶乘计算"><span class="toc-number">1.1.1.</span> <span class="toc-text">阶乘计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二进制计算"><span class="toc-number">1.1.2.</span> <span class="toc-text">二进制计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#交换迭代器指向的内容"><span class="toc-number">1.1.3.</span> <span class="toc-text">交换迭代器指向的内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#blob"><span class="toc-number">1.2.</span> <span class="toc-text">blob</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元数据"><span class="toc-number">1.3.</span> <span class="toc-text">元数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态-动态多态"><span class="toc-number">1.4.</span> <span class="toc-text">静态/动态多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boost-库的多态"><span class="toc-number">1.5.</span> <span class="toc-text">Boost 库的多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#整型常量外覆器"><span class="toc-number">1.5.1.</span> <span class="toc-text">整型常量外覆器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boost元函数库"><span class="toc-number">2.</span> <span class="toc-text">Boost元函数库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介"><span class="toc-number">2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主类型归类"><span class="toc-number">2.2.</span> <span class="toc-text">主类型归类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#次类型归类"><span class="toc-number">2.3.</span> <span class="toc-text">次类型归类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型属性"><span class="toc-number">2.4.</span> <span class="toc-text">类型属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型之间的关系"><span class="toc-number">2.5.</span> <span class="toc-text">类型之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型转化"><span class="toc-number">2.6.</span> <span class="toc-text">类型转化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#元函数的定义"><span class="toc-number">3.</span> <span class="toc-text">元函数的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#待续"><span class="toc-number">4.</span> <span class="toc-text">待续</span></a></li></ol>
      <div class="toc-tip">Table of Contents ▼</div>
    </div>
  


  <div class="container">
    <article>
      <h1>C++模板元编程(待续</h1>
      <h2 id="今天刚开始学"><a href="#今天刚开始学" class="headerlink" title="今天刚开始学"></a>今天刚开始学</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>(我想了下为什么要用struct？我猜是因为struct默认访问权限是public，如果用class还要多写一行public)</p>
<h4 id="阶乘计算"><a href="#阶乘计算" class="headerlink" title="阶乘计算"></a>阶乘计算</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> n&gt; <span class="comment">// general case: the value of</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span> &#123;</span> <span class="comment">// Factorial&lt;n&gt; is n times the value</span></span><br><span class="line"><span class="comment">// of Factorial&lt;n-1&gt;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; value = n * Factorial&lt;n<span class="number">-1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">// special case: the value of</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span>&lt;0&gt; &#123;</span> <span class="comment">// Factorial&lt;0&gt; is 1</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二进制计算"><a href="#二进制计算" class="headerlink" title="二进制计算"></a>二进制计算</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Binary</span>&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value = Binary&lt;N/<span class="number">10</span>&gt;::value * <span class="number">2</span> + N % <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Binary</span>&lt;0&gt;&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="交换迭代器指向的内容"><a href="#交换迭代器指向的内容" class="headerlink" title="交换迭代器指向的内容"></a>交换迭代器指向的内容</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/type_traits/is_reference.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/type_traits/is_same.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt; // 针对iterator_traits</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // 针对swap</span></span></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">bool</span> use_swap&gt; <span class="class"><span class="keyword">struct</span> <span class="title">iter_swap_impl</span>;</span></span><br><span class="line">    <span class="comment">// 快速版本</span></span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iter_swap_impl</span>&lt;true&gt;&#123;</span></span><br><span class="line">    	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator1</span>, <span class="title">class</span> <span class="title">ForwardIterator2</span>&gt;</span></span><br><span class="line"><span class="class">    	<span class="title">static</span> <span class="title">void</span> <span class="title">do_it</span>(<span class="title">ForwardIterator1</span> <span class="title">i1</span>, <span class="title">ForwardIterator2</span> <span class="title">i2</span>)&#123;</span></span><br><span class="line">			<span class="built_in">std</span>::swap(*i1, *i2);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 总是可行的版本</span></span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">   	<span class="class"><span class="keyword">struct</span> <span class="title">iter_swap_impl</span>&lt;false&gt;&#123;</span></span><br><span class="line">       	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator1</span>, <span class="title">class</span> <span class="title">ForwardIterator2</span>&gt;</span></span><br><span class="line"><span class="class">       	<span class="title">static</span> <span class="title">void</span> <span class="title">do_it</span>(<span class="title">ForwardIterator1</span> <span class="title">i1</span>, <span class="title">ForwardIterator2</span> <span class="title">i2</span>)&#123;</span></span><br><span class="line">       		<span class="keyword">typename</span> iterator_traits&lt;ForwardIterator1&gt;::value_type</span><br><span class="line">            tmp = *i1;</span><br><span class="line">           	*i1 = *i2;</span><br><span class="line">          	*i2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator1</span>, <span class="title">class</span> <span class="title">ForwardIterator2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">iter_swap</span>(<span class="title">ForwardIterator1</span> <span class="title">i1</span>, <span class="title">ForwardIterator2</span> <span class="title">i2</span>)&#123;</span></span><br><span class="line">    	<span class="keyword">typedef</span> iterator_traits&lt;ForwardsIterator1&gt; traits1;</span><br><span class="line">    	<span class="keyword">typedef</span> <span class="keyword">typename</span> traits1::value_type v1;</span><br><span class="line">    	<span class="keyword">typedef</span> <span class="keyword">typename</span> traits1::reference r1;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">typedef</span> iterator_traits&lt;ForwardsIterator1&gt; traits2;</span><br><span class="line">    	<span class="keyword">typedef</span> <span class="keyword">typename</span> traits2::value_type v2;</span><br><span class="line">    	<span class="keyword">typedef</span> <span class="keyword">typename</span> traits2::reference r2; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">const</span> use_swap = boost::is_same&lt;v1,v2&gt;::value</span><br><span class="line">        						&amp;&amp; boost::isreference&lt;r1&gt;::value</span><br><span class="line">        						&amp;&amp; boost::isreference&lt;r2&gt;::value;</span><br><span class="line">		</span><br><span class="line">        iter_swap_impl&lt;use_swap&gt;::do_it(i1,i2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="blob"><a href="#blob" class="headerlink" title="blob"></a>blob</h3><p>在面向对象的编程中将一个带有大量成员的类称作”blob”。类的成员彼此耦合，因为它们必须被声明在一起。为了避免耦合并提高模块化的程度，应该避免使用这种模式。代替方案是采用独立的元函数来定义单独的traits。</p>
<h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>可被C++编译器系统操纵的”值”可以被认为是元数据。在模板元编程中，两种最常见的元数据是<strong>类型</strong>和<strong>整数常量</strong>(包括bool)。</p>
<p>C++的编译器部分通常被称为”纯函数式语言”，因为元数据是不可变的并且元函数不可以有任何副作用。</p>
<h3 id="静态-动态多态"><a href="#静态-动态多态" class="headerlink" title="静态/动态多态"></a>静态/动态多态</h3><p>动态多态</p>
<ul>
<li>允许我们通过单个基指针或引用处理多个派生类型的对象</li>
<li>实际类型决定于运行期</li>
<li>是面向对象的关键特性</li>
</ul>
<p>静态多态</p>
<ul>
<li>允许不同类型的对象以同样的方式被操纵，只要它们支持某种共通的语法。</li>
<li>实际类型决定于编译期</li>
<li>是泛型编程的本质要素</li>
</ul>
<h3 id="Boost-库的多态"><a href="#Boost-库的多态" class="headerlink" title="Boost 库的多态"></a>Boost 库的多态</h3><p>为了在元函数之间实现多态，Boost 程序库使用的约定如下：</p>
<p><code>metafunction-name&lt;type-arguments...&gt;::type</code></p>
<p>从现在开始，当我们使用术语元函数时，就是指可以采用这种语法进行调用的模板。</p>
<h4 id="整型常量外覆器"><a href="#整型常量外覆器" class="headerlink" title="整型常量外覆器"></a>整型常量外覆器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">five</span> // 数值5的整型常量外覆器</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">const</span> value = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> value_type;</span><br><span class="line">    <span class="comment">// ... more</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// to get a int value</span></span><br><span class="line">metafunction-name&lt;type arguments...&gt;::type::value</span><br></pre></td></tr></table></figure>
<h2 id="Boost元函数库"><a href="#Boost元函数库" class="headerlink" title="Boost元函数库"></a>Boost元函数库</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>所有元函数都位于<strong>命名空间</strong>boost中</li>
<li><strong>头文件</strong>格式：<code>#include &lt;boost/type_traits/metafunction-name.hpp&gt;</code></li>
<li>所有<strong>数值元函数</strong>(包括bool, char 类型)都在其自身内直接提供了<code>::value</code></li>
<li>有少数type_traits 为了发挥完整的功能需要一些非标准编译器支持（否则功能降级，但肯定安全、能编译成功）。</li>
<li>类型归类元函数通常会忽视cv修饰符。</li>
</ul>
<h3 id="主类型归类"><a href="#主类型归类" class="headerlink" title="主类型归类"></a>主类型归类</h3><p>Primary Type Categorization</p>
<p>对于给定的类型T，这些元函数中有且仅有一个会产生结果true。</p>
<table>
<thead>
<tr>
<th>主类型Trait</th>
<th>::type::value 和 ::value 为 ture 的情况</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is_array&lt;T&gt;</code></td>
<td>T 是数组类型</td>
</tr>
<tr>
<td><code>is_class&lt;T&gt;</code></td>
<td>T 是类类型，如果缺乏编译器支持，T 是联合体时也是 true</td>
</tr>
<tr>
<td><code>is_enum&lt;T&gt;</code></td>
<td>T 是枚举类型</td>
</tr>
<tr>
<td><code>is_float&lt;T&gt;</code></td>
<td>T 是浮点类型</td>
</tr>
<tr>
<td><code>is_function&lt;T&gt;</code></td>
<td>T 是函数类型，<code>R(*)(args...)</code>/<code>R(&amp;)(args...)</code></td>
</tr>
<tr>
<td><code>is_integral&lt;T&gt;</code></td>
<td>T 是整型</td>
</tr>
<tr>
<td><code>is_member_pointer&lt;T&gt;</code></td>
<td>T 是指向函数成员或数据成员的指针，注意<code>is_pointer</code>识别不了这些类型。</td>
</tr>
<tr>
<td><code>is_pointer&lt;T&gt;</code></td>
<td>T 是指针类型（但不指向成员）</td>
</tr>
<tr>
<td><code>is_reference&lt;T&gt;</code></td>
<td>T 是引用</td>
</tr>
<tr>
<td><code>is_union&lt;T&gt;</code></td>
<td>T 是联合体，若缺乏编译器支持则总是false</td>
</tr>
<tr>
<td><code>is_void&lt;T&gt;</code></td>
<td>T 具有cv void形式</td>
</tr>
</tbody>
</table>
<p><strong>指向成员的指针</strong></p>
<p>指向成员函数的指针：<code>R(C::*)(args...)cv</code></p>
<p>指向数据成员的指针：<code>D C::*</code></p>
<p>实际上它们根本不是指针，而是一种偏移量。所以和指针类型不同。</p>
<h3 id="次类型归类"><a href="#次类型归类" class="headerlink" title="次类型归类"></a>次类型归类</h3><p>Secondary Type Categorization</p>
<p>表示对主类型归类的分组或区分。</p>
<table>
<thead>
<tr>
<th>次类型Trait</th>
<th>::type::value 和 ::value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is_arithmetic&lt;T&gt;</code></td>
<td>`is_integral<t>::value</t></td>
<td></td>
<td>is_float<t>::value`</t></td>
</tr>
<tr>
<td><code>is_compound&lt;T&gt;</code></td>
<td><code>!is_fundamental&lt;T&gt;::value</code></td>
</tr>
<tr>
<td><code>is_fundamental&lt;T&gt;</code></td>
<td>`is_arithmetic<t>::value</t></td>
<td></td>
<td>is_void<t>::value`</t></td>
</tr>
<tr>
<td><code>is_member_function_pointer&lt;T&gt;</code></td>
<td>T是指向成员函数的指针？</td>
</tr>
<tr>
<td><code>is_object&lt;T&gt;</code></td>
<td>`!(is_function<t>::value</t></td>
<td></td>
<td>is_reference<t>::value</t></td>
<td></td>
<td>is_void<t>::value)`</t></td>
</tr>
<tr>
<td><code>is_scalar&lt;T&gt;</code></td>
<td>`is_arithmetic<t>::value</t></td>
<td></td>
<td>is_enum<t>::value</t></td>
<td></td>
<td>is_pointer<t>::value</t></td>
<td></td>
<td>is_member_pointer<t>::value`</t></td>
</tr>
</tbody>
</table>
<h3 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h3><p>对于那些不是和标准类型归类直接相关的traits，type traits程序库使用“属性”作为包罗万象的术语来指定它们。</p>
<p>这个分组中，最简单的是<code>is_const&lt;T&gt;</code>和<code>is_volatile&lt;T&gt;</code>。</p>
<p>其余属性，略。</p>
<h3 id="类型之间的关系"><a href="#类型之间的关系" class="headerlink" title="类型之间的关系"></a>类型之间的关系</h3><table>
<thead>
<tr>
<th>元函数</th>
<th>::value 为 true的条件</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is_same&lt;T,U&gt;</code></td>
<td>T 和 U 类型一致</td>
</tr>
<tr>
<td><code>is_convertible&lt;T,U&gt;</code></td>
<td>T 类型可以被隐式转换为 U 类型</td>
</tr>
<tr>
<td><code>is_base_and_derived&lt;B,D&gt;</code></td>
<td>B 是 D 的一个基类</td>
</tr>
</tbody>
</table>
<h3 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h3><p>不同于之前的，这组元函数产生类型结果而不是布尔值。</p>
<table>
<thead>
<tr>
<th>转化</th>
<th>::type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>remove_const&lt;T&gt;</code></td>
<td>T不带任何顶层const。<code>const int</code>变成int，但<code>const int*</code>不变</td>
</tr>
<tr>
<td><code>remove_volatile&lt;T&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>remove_cv&lt;T&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>remove_reference&lt;T&gt;</code></td>
<td>T不带任何顶层引用。<code>int&amp;</code>变成int，但<code>int*</code>不变</td>
</tr>
<tr>
<td><code>remove_bounds&lt;T&gt;</code></td>
<td>T不带任何顶层数组中括号。<code>int[2][3]</code>变成<code>int[3]</code></td>
</tr>
<tr>
<td><code>remove_pointer&lt;T&gt;</code></td>
<td>T不带任何顶层指针。<code>int*</code>变成int，但<code>int&amp;</code>不变</td>
</tr>
<tr>
<td><code>add_reference&lt;T&gt;</code></td>
<td>如果T是引用类型，结果为T，否则为<code>T&amp;</code></td>
</tr>
<tr>
<td><code>add_pointer&lt;T&gt;</code></td>
<td><code>remove_reference&lt;T&gt;::type*</code>。如<code>int</code>和<code>int&amp;</code>都变成<code>int*</code></td>
</tr>
<tr>
<td><code>add_const&lt;T&gt;</code></td>
<td>T const</td>
</tr>
<tr>
<td><code>add_volatile&lt;T&gt;</code></td>
<td>T volatile</td>
</tr>
<tr>
<td><code>add_cv&lt;T&gt;</code></td>
<td>T const volatile</td>
</tr>
</tbody>
</table>
<h2 id="元函数的定义"><a href="#元函数的定义" class="headerlink" title="元函数的定义"></a>元函数的定义</h2><p><strong>无参元函数</strong></p>
<p>编写无参元函数最容易的方式是借助一个简单的struct：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">always_int</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>元函数的定义</strong></p>
<p>一个元函数可以是</p>
<ul>
<li>一个类模板，它的所有参数都是类型</li>
<li>一个类，带有一个名为”type”的可公开访问的嵌套结果类型</li>
</ul>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
  </article>
    
  </div>
</div>

    <footer class="main-footer">
  <div class="container">
    © 2018 
  </div>
</footer>
    



<script src="/./runtime.32f029.js"></script><script src="/./vendor.ec1199.js"></script><script src="/./app.5ed5af.js"></script>


  </body>
</html>
