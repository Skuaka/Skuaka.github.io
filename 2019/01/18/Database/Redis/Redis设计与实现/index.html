<!DOCTYPE html>
<html lang="zh-cmn-Hans">
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <meta http-equiv="”Cache-Control”" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  
  <title>Redis 设计与实现 | Skuaka</title>
  <link rel="icon" type="image/png" sizes="32x32" href>
  



<link rel="stylesheet" href="/./vendor.ec1199.css"><link rel="stylesheet" href="/./app.5ed5af.css">


</head>
  <body>
    <header class="main-header">
  <div class="container">
    <a href="/" " class="logo">
      <img src="logo.jpg" alt="Skuaka" class="logo-img">
    </a>
    <span class="nav-separator"></span>
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索文章"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
    <a href="javascript:void(0);" class="nav-icon">
      <i class="fas fa-bars"></i>
    </a>
    <nav class="main-nav">
      <ul class="nav-list">
        
          <li class="nav-link ">
            <a href="/">首页</a>
          </li>
        
          <li class="nav-link ">
            <a href="/archives/">归档</a>
          </li>
        
          <li class="nav-link ">
            <a href="/categories">分类</a>
          </li>
        
          <li class="nav-link ">
            <a href="/about.html">关于</a>
          </li>
        
      </ul>
    </nav>
  </div>
</header>
    <div class="page--article">
  
    <div class="toc-container">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-设计与实现"><span class="toc-number">1.</span> <span class="toc-text">Redis 设计与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-number">1.2.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#外层数据结构"><span class="toc-number">1.2.1.</span> <span class="toc-text">外层数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哈希表"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#列表"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#集合"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有序集"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">有序集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#底层数据结构"><span class="toc-number">1.2.2.</span> <span class="toc-text">底层数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SDS-动态字符串"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">SDS 动态字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dict-字典"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">dict 字典</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ziplist-压缩链表"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">ziplist 压缩链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#quicklist"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">quicklist</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zset"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">zset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#skiplist-跳跃表"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">skiplist 跳跃表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#inset"><span class="toc-number">1.2.2.7.</span> <span class="toc-text">inset</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">1.2.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RedisDb"><span class="toc-number">1.3.</span> <span class="toc-text">RedisDb</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#过期键的删除策略"><span class="toc-number">1.3.1.</span> <span class="toc-text">过期键的删除策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis的事件模型"><span class="toc-number">1.4.</span> <span class="toc-text">Redis的事件模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端到服务端的请求过程"><span class="toc-number">1.4.1.</span> <span class="toc-text">客户端到服务端的请求过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结束"><span class="toc-number">2.</span> <span class="toc-text">结束</span></a></li></ol>
      <div class="toc-tip">Table of Contents ▼</div>
    </div>
  


  <div class="container">
    <article>
      <h1>Redis 设计与实现</h1>
      <h1 id="Redis-设计与实现"><a href="#Redis-设计与实现" class="headerlink" title="Redis 设计与实现"></a>Redis 设计与实现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><p>什么是redis</p>
<p>Redis是一个开源的使用ANSI C语言编写、支持网络、可<strong>基于内存亦可持久化</strong>的日志型、<strong>Key-Value数据库</strong>，并提供多种语言的API。简而言之redis就是放在<strong>远程网络上的一个key-value数据结构</strong>。</p>
</li>
<li><p>redis有什么作用</p>
<p>Redis可以用来做cache，也可以用来做持久化db，甚至用来做队列。队列就是存储临时性数据，而cache主要存储那些用户频繁使用的数据。当然也可以来做db，但是实现持久化存储需要付出昂贵的代价。</p>
</li>
<li><p>redis有什么优缺点</p>
<p><strong>优点</strong></p>
<p>–redis丰富的数据结构—-更加方便操作</p>
<p>比如队列的先进先出，hash结构O(1)的快速查询，sorted-set有序集合方便获取排名</p>
<p>–redis的数据都是在内存操作—更加快速操作</p>
<p>—单线程处理—避免了锁</p>
<p>—非阻塞式IO多路复用—充分利用网络IO</p>
<p>—设计简单，效率快</p>
<p>—方便扩展，不需要像mysql一样分库分表，只需要简单扩大内存，或者增加redis的个数</p>
<p><strong>缺点</strong></p>
<p>Rdb备份不具备实时性</p>
<p>Aof持久化比较消耗内存和cpu，甚至当aof文件过大的时候占用磁盘</p>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>下图说明了，外部数据结构和底层实际数据结构是通过realobject来连接的。一个外观类型里面必然存着一个realobject，通过它来访问底层数据结构。</p>
<p><img src="Picture\01.png" alt="01"></p>
<h3 id="外层数据结构"><a href="#外层数据结构" class="headerlink" title="外层数据结构"></a>外层数据结构</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>REDIS_STRING (字符串)是 Redis 使用得最为广泛的数据类型,它除了是 SET 、GET 等命令的操作对象之外,数据库中的所有键,以及执行命令时提供给 Redis 的参数,都是用这种类型保存的。</p>
<p>字符串类型分别使用 REDIS_ENCODING_INT 和 REDIS_ENCODING_RAW 两种编码。</p>
<p>只有能表示为 long 类型的值,才会以整数的形式保存,其他类型的整数、小数和字符串,都是用 sdshdr 结构来保存。</p>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>REDIS_HASH (哈希表)是HSET 、HLEN 等命令的操作对象</p>
<p>它使用 REDIS_ENCODING_ZIPLIST和REDIS_ENCODING_HT 两种编码方式</p>
<p>Redis 中每个hash可以存储2^32-1键值对（40多亿）</p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>REDIS_LIST(列表)是LPUSH 、LRANGE等命令的操作对象</p>
<p>它使用 REDIS_ENCODING_ZIPLIST和REDIS_ENCODING_LINKEDLIST 这两种方式编码</p>
<p>一个列表最多可以包含232-1 个元素(4294967295, 每个列表超过40亿个元素)。</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>REDIS_SET (集合) 是 SADD 、 SRANDMEMBER 等命令的操作对象</p>
<p>它使用 REDIS_ENCODING_INTSET 和 REDIS_ENCODING_HT 两种方式编码</p>
<p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)</p>
<h4 id="有序集"><a href="#有序集" class="headerlink" title="有序集"></a>有序集</h4><p>REDIS_ZSET (有序集)是ZADD 、ZCOUNT 等命令的操作对象</p>
<p>它使用 REDIS_ENCODING_ZIPLIST和REDIS_ENCODING_SKIPLIST 两种方式编码</p>
<p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><h4 id="SDS-动态字符串"><a href="#SDS-动态字符串" class="headerlink" title="SDS 动态字符串"></a>SDS 动态字符串</h4><p>sds字符串是字符串的实现</p>
<p>动态字符串是一个结构体，内部有一个buf数组，以及字符串长度，剩余长度等字段，优点是通过长度限制写入，避免缓冲区溢出，另外剩余长度不足时会自动扩容，扩展性较好，不需要频繁分配内存。</p>
<p>并且sds支持写入二进制数据，而不一定是字符。</p>
<h4 id="dict-字典"><a href="#dict-字典" class="headerlink" title="dict 字典"></a>dict 字典</h4><p>dict字典是哈希表的实现。</p>
<p>dict字典与Java中的哈希表实现简直如出一辙，首先都是数组+链表组成的结构，通过dictentry保存节点。</p>
<p>其中dict同时保存两个entry数组，当需要扩容时，把节点转移到第二个数组即可，平时只使用一个数组。</p>
<p><img src="Picture\02.png" alt="02"></p>
<h4 id="ziplist-压缩链表"><a href="#ziplist-压缩链表" class="headerlink" title="ziplist 压缩链表"></a>ziplist 压缩链表</h4><p>ziplist 是一个经过特殊编码的双向链表，它的设计目标就是为了提高存储效率。ziplist可以用于存储字符串或整数，其中整数是按真正的二进制表示进行编码的，而不是编码成字符串序列。它能以O(1)的时间复杂度在表的两端提供push和pop操作。</p>
<ul>
<li><p>一个普通的双向链表，链表中每一项都占用独立的一块内存，各项之间用地址指针（或引用）连接起来。这种方式会带来大量的内存碎片，而且地址指针也会占用额外的内存。</p>
<p>ziplist 是将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。它是一个表（list），但其实不是一个链表（linked list）。</p>
</li>
<li><p>另外，ziplist为了在细节上节省内存，对于值的存储采用了变长的编码方式，大概意思是说，对于大的整数，就多用一些字节来存储，而对于小的整数，就少用一些字节来存储。</p>
</li>
<li><p>实际上。redis的字典一开始的数据比较少时，会使用ziplist的方式来存储，也就是key1，value1，key2，value2这样的顺序存储，对于小数据量来说，这样存储既省空间，查询的效率也不低。</p>
<p>当数据量超过阈值时，哈希表自动膨胀为之前我们讨论的dict。</p>
</li>
</ul>
<h4 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h4><p>quicklist是结合 ziplist存储优势 和 链表灵活性 于一身的双端链表。是一个空间和时间的折中：</p>
<p>双向链表便于在表的两端进行push和pop操作，但是它的内存开销比较大。ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。</p>
<p><img src="Picture\03.png" alt="03"></p>
<h4 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h4><p>zset其实是两种结构的合并。也就是dict和skiplist结合而成的。dict负责保存数据对分数的映射，而skiplist用于根据分数进行数据的查询（相辅相成）</p>
<h4 id="skiplist-跳跃表"><a href="#skiplist-跳跃表" class="headerlink" title="skiplist 跳跃表"></a>skiplist 跳跃表</h4><p>sortedset是由skiplist，dict和ziplist组成的。</p>
<p>当数据较少时，sorted set是由一个ziplist来实现的。 </p>
<p>当数据多的时候，sorted set是由 zset 来实现的，这个 zset 包含一个 dict + 一个skiplist。dict用来查询数据到分数(score)的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。</p>
<p>skiplist的节点中存着节点值和分数。并且跳表是根据节点的分数进行排序的，所以可以根据节点分数进行范围查找。</p>
<p><img src="Picture\04.png" alt="04"></p>
<p>结合下图，如果想查找19是否存在，从最高层开始，首先和头结点的最高层的后继结点9进行比较，19大于9，因此接着和9在该层上的后继结点21进行比较，小于21，那这个值肯定在9结点和21结点之间。</p>
<p> 因此，下移一层，接着和9在该层上的后继结点17进行比较，19大于17，然后和21进行比较，小于21，此时肯定在17结点和21结点之间。<br>接着下移一层，和17在该层上的后继结点19进行比较，这样就最终找到了。</p>
<p><img src="Picture\05.png" alt="05"></p>
<h4 id="inset"><a href="#inset" class="headerlink" title="inset"></a>inset</h4><p>inset是一个数字集合，他使用灵活的数据类型来保存数字。</p>
<p>新创建的intset只有一个header，总共8个字节。其中encoding = 2, length = 0。<br>添加13, 5两个元素之后，因为它们是比较小的整数，都能使用2个字节表示，所以encoding不变，值还是2。 </p>
<p>当添加32768的时候，它不再能用2个字节来表示了（2个字节能表达的数据范围是-215~215-1，而32768等于215，超出范围了），因此encoding必须升级到INTSET_ENC_INT32（值为4），即用4个字节表示一个元素。</p>
<p><img src="Picture\06.png" alt="06"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>sds是一个灵活的字符串数组，并且支持直接存储二进制数据，同时提供长度和剩余空间的字段来保证伸缩性和防止溢出。</p>
<p>dict是一个字典结构，实现方式就是Java中的hashmap实现，同时持有两个节点数组，但只使用其中一个，扩容时换成另外一个。</p>
<p>ziplist是一个压缩链表，他放弃内存不连续的连接方式，而是直接分配连续内存进行存储，减少内存碎片。提高利用率，并且也支持存储二进制数据。</p>
<p>quicklist是ziplist和传统链表的中和形成的链表结果，每个链表节点都是一个ziplist。</p>
<p>zset是由skiplist和dict实现的。</p>
<p>inset是一个数字集合，他根据插入元素的数据类型来决定数组元素的长度。并自动进行扩容。</p>
<ul>
<li><p>他们实现了哪些结构？</p>
<p>字符串由sds实现</p>
<p>list由ziplist和quicklist实现</p>
<p>sortset由ziplist和zset实现</p>
<p>hash表由dict实现</p>
<p>集合由inset实现。</p>
</li>
</ul>
<h2 id="RedisDb"><a href="#RedisDb" class="headerlink" title="RedisDb"></a>RedisDb</h2><p>redis服务器中维护着一个数据库名为redisdb，实际上他是一个dict结构。</p>
<p>Redis的数据库使用字典作为底层实现，数据库的增、删、查、改都是构建在字典的操作之上的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Redis database representation. There are multiple databases identified</span></span><br><span class="line"><span class="comment"> * by integers from 0 (the default database) up to the max configured</span></span><br><span class="line"><span class="comment"> * database. The database number is the 'id' field in the structure. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">     <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></span><br><span class="line">     <span class="comment">// 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span></span><br><span class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></span><br><span class="line">    <span class="comment">// 正处于阻塞状态的键</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP) */</span></span><br><span class="line">    <span class="comment">// 可以解除阻塞的键</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    <span class="comment">// 正在被 WATCH 命令监视的键</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">eviction_pool</span>;</span>    <span class="comment">/* Eviction pool of keys */</span></span><br><span class="line">    <span class="comment">// 数据库号码</span></span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line">    <span class="comment">// 数据库的键的平均 TTL ，统计信息</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line"> &#125; redisDb;</span><br></pre></td></tr></table></figure>
<p><img src="Picture\07.jpg" alt="07"></p>
<h3 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h3><p>定时删除：在设置键的过期时间的同时，创建一个定时器，在定时结束的时候，将该键删除；</p>
<p>惰性删除：放任键过期不管，在访问该键的时候，判断该键的过期时间是否已经到了，如果过期时间已经到了，就执行删除操作；</p>
<p>定期删除：每隔一段时间，对数据库中的键进行一次遍历，删除过期的键。</p>
<h2 id="Redis的事件模型"><a href="#Redis的事件模型" class="headerlink" title="Redis的事件模型"></a>Redis的事件模型</h2><p>redis处理请求的方式基于<strong>reactor线程模型</strong>，即一个线程处理连接，并且注册事件到IO多路复用器，复用器触发事件以后根据不同的处理器去执行不同的操作。总结以下</p>
<h3 id="客户端到服务端的请求过程"><a href="#客户端到服务端的请求过程" class="headerlink" title="客户端到服务端的请求过程"></a>客户端到服务端的请求过程</h3><p>远程客户端连接到 redis 后，redis服务端会为远程客户端创建一个 redisClient 作为代理。</p>
<p>redis 会读取嵌套字中的数据，写入 querybuf 中。</p>
<p>解析 querybuf 中的命令，记录到 argc 和 argv 中。</p>
<p>根据 argv[0] 查找对应的 recommand。</p>
<p>执行 recommend 对应的执行函数。</p>
<p>执行以后将结果存入 buf &amp; bufpos &amp; reply 中。</p>
<p>返回给调用方。返回数据的时候，会控制写入数据量的大小，如果过大会分成若干次。保证 redis 的相应时间。</p>
<p>Redis 作为单线程应用，一直贯彻的思想就是，每个步骤的执行都有一个上限（包括执行时间的上限或者文件尺寸的上限）一旦达到上限，就会记录下当前的执行进度，下次再执行。保证了 Redis 能够及时响应不发生阻塞。</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1>
  </article>
    
  </div>
</div>

    <footer class="main-footer">
  <div class="container">
    © 2018 
  </div>
</footer>
    



<script src="/./runtime.32f029.js"></script><script src="/./vendor.ec1199.js"></script><script src="/./app.5ed5af.js"></script>


  </body>
</html>
