<!DOCTYPE html>
<html lang="zh-cmn-Hans">
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <meta http-equiv="”Cache-Control”" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  
  <title>QT 贪吃蛇 | Skuaka</title>
  <link rel="icon" type="image/png" sizes="32x32" href>
  



<link rel="stylesheet" href="/./vendor.ec1199.css"><link rel="stylesheet" href="/./app.5ed5af.css">


</head>
  <body>
    <header class="main-header">
  <div class="container">
    <a href="/" " class="logo">
      <img src="logo.jpg" alt="Skuaka" class="logo-img">
    </a>
    <span class="nav-separator"></span>
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索文章"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
    <a href="javascript:void(0);" class="nav-icon">
      <i class="fas fa-bars"></i>
    </a>
    <nav class="main-nav">
      <ul class="nav-list">
        
          <li class="nav-link ">
            <a href="/">首页</a>
          </li>
        
          <li class="nav-link ">
            <a href="/archives/">归档</a>
          </li>
        
          <li class="nav-link ">
            <a href="/categories">分类</a>
          </li>
        
          <li class="nav-link ">
            <a href="/about.html">关于</a>
          </li>
        
      </ul>
    </nav>
  </div>
</header>
    <div class="page--article">
  
    <div class="toc-container">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#贪吃蛇"><span class="toc-number">1.</span> <span class="toc-text">贪吃蛇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MainWindow"><span class="toc-number">1.1.</span> <span class="toc-text">MainWindow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#food"><span class="toc-number">1.2.</span> <span class="toc-text">food</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#游戏循环"><span class="toc-number">1.3.</span> <span class="toc-text">游戏循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#snake绘制"><span class="toc-number">1.4.</span> <span class="toc-text">snake绘制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#snake动画"><span class="toc-number">1.5.</span> <span class="toc-text">snake动画</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用户控制"><span class="toc-number">1.6.</span> <span class="toc-text">用户控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#游戏逻辑"><span class="toc-number">1.7.</span> <span class="toc-text">游戏逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优化代码"><span class="toc-number">1.8.</span> <span class="toc-text">优化代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#待续"><span class="toc-number">2.</span> <span class="toc-text">待续</span></a></li></ol>
      <div class="toc-tip">Table of Contents ▼</div>
    </div>
  


  <div class="container">
    <article>
      <h1>QT 贪吃蛇</h1>
      <h3 id="贪吃蛇"><a href="#贪吃蛇" class="headerlink" title="贪吃蛇"></a>贪吃蛇</h3><p>要实现这个贪吃蛇游戏，会利用到事件系统、Graphics View Framework、QPainter 等相关内容，也会了解到一个游戏所具有的一些特性，比如游戏循环等。</p>
<p>很明显，绘制图形和移动图形，是一个游戏的核心。对于游戏而言，将其中的每一个部分看做对象是非常合理的。因此，我们选择 Graphics View Framework 作为核心框架。同时，Graphics View Framework 的性能很好，即便是数千上万的图形也没有压力。这一点非常适合于游戏。</p>
<p>对于游戏而言，我们需要一个QGraphicsScene，作为游戏发生的舞台；一个QGraphicsView，作为观察游戏舞台的组件；以及若干元素，用于表示游戏对象，比如蛇、食物以及障碍物等。</p>
<p>大致分析过游戏组成以及各部分的实现方式后，我们可以开始编码了。这当然是一个 GUI 工程，主窗口应该是一个QGraphicsView。为了以后的实现方便（比如，我们希望向工具栏添加按钮等），我们不会直接以QGraphicsView 作为顶层窗口，而是<strong>将其添加到一个主窗口上</strong>。这里，我们不使用 QtDesigner 进行界面设计，而是直接编码完成。</p>
<h4 id="MainWindow"><a href="#MainWindow" class="headerlink" title="MainWindow"></a>MainWindow</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QGraphicsScene</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QGraphicsView</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameController</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MainWindow(QWidget *parent = <span class="number">0</span>);</span><br><span class="line">    ~MainWindow();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjustViewSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initScene</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initSceneBackground</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    QGraphicsScene *scene;</span><br><span class="line">    QGraphicsView *view;</span><br><span class="line"></span><br><span class="line">    GameController *game;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">    QMainWindow(parent),</span><br><span class="line">    scene(<span class="keyword">new</span> QGraphicsScene(<span class="keyword">this</span>)),</span><br><span class="line">    view(<span class="keyword">new</span> QGraphicsView(scene, <span class="keyword">this</span>)),</span><br><span class="line">    game(<span class="keyword">new</span> GameController(*scene, <span class="keyword">this</span>))</span><br><span class="line">&#123;</span><br><span class="line">    setCentralWidget(view);</span><br><span class="line">    resize(<span class="number">600</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">    initScene();</span><br><span class="line">    initSceneBackground();</span><br><span class="line"></span><br><span class="line">    QTimer::singleShot(<span class="number">0</span>, <span class="keyword">this</span>, SLOT(adjustViewSize()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>最后一行的 singleShot() 函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> QTimer::singleShot(<span class="keyword">int</span> msec, QObject * receiver, <span class="keyword">const</span> <span class="keyword">char</span> * member);</span><br></pre></td></tr></table></figure>
<p>该函数接受三个参数，简单来说，它的意思是，在 msec 毫秒之后，调用 receiver 的 member <strong>槽函数</strong>。在我们的代码中，第一个参数传递的是 0，也就是 0ms 之后，调用<code>this-&gt;adjustViewSize()</code>。</p>
<p>QTimer 的处理是将其放到事件列表中，等到下一次事件循环开始时去调用这个函数。那么，<code>QTimer::signleShot(0, ...)</code>意思是，在下一次事件循环开始时，立刻调用指定的槽函数。</p>
<p>在我们的例子中，我们需要在视图绘制完毕后才去改变大小（视图绘制当然是在<code>paintEvent()</code>事件中），因此我们需要在下一次事件循环中调用<code>adjustViewSize()</code>函数。这就是为什么我们需要用<code>QTimer</code>而不是直接调用<code>adjustViewSize()</code>。</p>
<p>上面看不懂，去stackflow看到了看得懂的：</p>
<p><strong>Every call to QTimer::singleShot(…) is executed on the event loop of the thread where it is invoked. If invoked from the main thread, it’ll be the event loop started with app.exec().</strong></p>
</li>
</ul>
<p>接下来看看<code>initScene()</code>和<code>initSceneBackground()</code>的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::initScene()</span><br><span class="line">&#123;</span><br><span class="line">    scene-&gt;setSceneRect(<span class="number">-100</span>, <span class="number">-100</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MainWindow::initSceneBackground()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QPixmap <span class="title">bg</span><span class="params">(TILE_SIZE, TILE_SIZE)</span></span>;</span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(&amp;bg)</span></span>;</span><br><span class="line">    p.setBrush(QBrush(Qt::gray));</span><br><span class="line">    p.drawRect(<span class="number">0</span>, <span class="number">0</span>, TILE_SIZE, TILE_SIZE);</span><br><span class="line"></span><br><span class="line">    view-&gt;setBackgroundBrush(QBrush(bg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>initSceneBackground()</code>函数看似很长，实际却很简单。首先我们创建一个边长 TILE_SIZE 的 QPixmap，将其使用灰色填充矩形。我们没有设置边框颜色，默认就是黑色。然后将这个 QPixmap 作为背景画刷，铺满整个视图。</li>
</ul>
<hr>
<p>我们的地图是建立在<code>QGraphicsScene</code>的基础之上的，所以，里面的对象应该是<code>QGraphicsItem</code>实例。通常，我们会把所有的图形元素（这里便是游戏中需要的对象，例如蛇、食物等）设计为<code>QGraphicsItem</code>的子类，在这个类中添加绘制自身的代码以及动画逻辑。这也是面向对象的开发方式：封装自己的属性和操作。在我们的游戏中，应该有三个对象：<strong>蛇 Snake</strong>、<strong>食物 Food</strong>、<strong>墙 Wall</strong>。</p>
<h4 id="food"><a href="#food" class="headerlink" title="food"></a>food</h4><p>我们从食物开始。因为它是最简单的。我们将其作为一个红色的小圆饼，大小要比地图中的一个方格要小，因此我们可以将其放置在一个方格中。正如上面分析的那样，我们的Food 类需要继承<code>QGraphicsItem</code>。<strong>按照接口约束，<code>QGraphicsItem</code>的子类需要重写至少两个函数：<code>boundingRect()</code>和<code>paint()</code>。</strong></p>
<ul>
<li><p><code>boundingRect()</code>返回一个用于包裹住图形元素的矩形，也就是这个图形元素的范围。</p>
<p>需要注意的是，这个矩形必须能够<strong>完全包含</strong>图形元素。所谓“完全包含”，意思是，在图形元素有动画的时候，这个矩形也必须将整个图形元素包含进去。如果范围矩形过小。图形会被剪切；如果范围矩形过大，就会影响性能。</p>
</li>
<li><p><code>paint()</code>的作用是使用<code>QPainter</code>将图形元素绘制出来。</p>
</li>
</ul>
<p>下面是 food.h 和 food.cpp 的内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////// food.h //////////</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QGraphicsItem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span> :</span> <span class="keyword">public</span> QGraphicsItem</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Food(qreal x, qreal y);</span><br><span class="line"></span><br><span class="line">    <span class="function">QRectF <span class="title">boundingRect</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paint</span><span class="params">(QPainter *painter, <span class="keyword">const</span> QStyleOptionGraphicsItem *, QWidget *)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QPainterPath <span class="title">shape</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////// food.cpp //////////</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"food.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> qreal FOOD_RADIUS = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">Food::Food(qreal x, qreal y)</span><br><span class="line">&#123;</span><br><span class="line">    setPos(x, y);</span><br><span class="line">    setData(GD_Type, GO_Food);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QRectF Food::boundingRect() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> QRectF(-TILE_SIZE,    -TILE_SIZE,</span><br><span class="line">                   TILE_SIZE * <span class="number">2</span>, TILE_SIZE * <span class="number">2</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Food::paint(QPainter *painter, <span class="keyword">const</span> QStyleOptionGraphicsItem *, QWidget *)</span><br><span class="line">&#123;</span><br><span class="line">    painter-&gt;save();</span><br><span class="line"></span><br><span class="line">    painter-&gt;setRenderHint(QPainter::Antialiasing);</span><br><span class="line">    painter-&gt;fillPath(shape(), Qt::red);</span><br><span class="line"></span><br><span class="line">    painter-&gt;restore();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QPainterPath Food::shape() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    QPainterPath p;</span><br><span class="line">    p.addEllipse(QPointF(TILE_SIZE / <span class="number">2</span>, TILE_SIZE / <span class="number">2</span>), FOOD_RADIUS, FOOD_RADIUS);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>setPos() 函数就是设置 item 的位置，其坐标是相对父对象的。</p>
</li>
<li><p><code>setData()</code>函数是我们之后要用到的，这里简单提一句，它的作用为该图形元素添加额外的数据信息，类似于散列一样的键值对的形式。</p>
</li>
<li><p><code>boundingRect()</code>简单地返回一个<code>QRect</code>对象。由于我们的元素就是一个圆形，所以我们返回的是一个简单的矩形。注意，这个矩形的范围实际是四倍于实际区域的：以元素坐标 (x, y) 为中心，边长为<code>TILE_SIZE * 2</code>的正方形。</p>
</li>
<li><p>我们还重写了<code>shape()</code>函数。这也是一个虚函数，但是并不是必须覆盖的。这个函数返回的是元素实际的路径。所谓路径，可以理解成元素的矢量轮廓线，就是<code>QPainterPath</code>所表示的。</p>
<p>我们使用<code>addEllipse()</code>函数，添加了一个圆心为 (TILE_SIZE / 2, TILE_SIZE / 2)，半径 FOOD_RADIUS 的圆，正好是矩形的右下角的中心点。由于设置了<code>shape()</code>函数，我们所要做的，就是用painter的fillPath()方法把<code>shape()</code>函数定义的路径绘制出来。注意，我们使用了<code>QPainter::save()</code>和<code>QPainter::restore()</code>两个函数，用于保存画笔状态。</p>
</li>
</ul>
<hr>
<h4 id="游戏循环"><a href="#游戏循环" class="headerlink" title="游戏循环"></a>游戏循环</h4><p>现在我们有了第一个图形元素，那么，就让我们把它添加到场景中吧！对于一个游戏，通常需要有一个中心控制的类，用于控制所有游戏相关的行为。我们将其取名为<code>GameController</code>。</p>
<p><code>GameController</code>的工作是，初始化场景中的游戏对象，开始游戏循环。l</p>
<p><strong>在 Graphics View Framework 中，每一帧都应该调用一个称为<code>advance()</code>的函数。<code>QGraphicsScene::advance()</code>会调用场景中每一个元素自己的<code>advance()</code>函数。所以，如果图形元素需要做什么事，必须重写<code>QGraphicsItem</code>的<code>advance()</code>，然后在游戏循环中调用这个函数。</strong></p>
<p><code>GameController</code>创建并开始游戏循环。当然，我们也可以加入<code>pause()</code>和<code>resume()</code>函数。现在，我们来看看它的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GameController::GameController(QGraphicsScene *scene, QObject *parent) :</span><br><span class="line">    QObject(parent),</span><br><span class="line">    scene(scene),</span><br><span class="line">    snake(<span class="keyword">new</span> Snake(<span class="keyword">this</span>))</span><br><span class="line">&#123;</span><br><span class="line">    timer.start(<span class="number">1000</span>/<span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">    Food *a1 = <span class="keyword">new</span> Food(<span class="number">0</span>, <span class="number">-50</span>);</span><br><span class="line">    scene-&gt;addItem(a1);</span><br><span class="line">    scene-&gt;addItem(snake);</span><br><span class="line"></span><br><span class="line">    scene-&gt;installEventFilter(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    resume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GameController</code>的构造函数。首先开启充当游戏循环的定时器，定时间隔是 1000 / 33 毫秒，也就是每秒 30（1000 / 33 = 30）帧。<code>GameController</code>有两个成员变量：scene 和 snake，我们将第一个食物和蛇都加入到场景中。同时，我们为<code>GameController</code>添加了事件过滤器，以便监听键盘事件。这里我们先不管这个事件过滤器，直接看看后面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GameController::pause()</span><br><span class="line">&#123;</span><br><span class="line">    disconnect(&amp;timer, SIGNAL(timeout()),</span><br><span class="line">               scene,  SLOT(advance()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GameController::resume()</span><br><span class="line">&#123;</span><br><span class="line">    connect(&amp;timer, SIGNAL(timeout()),</span><br><span class="line">            scene,  SLOT(advance()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>pause()</code>和<code>resume()</code>函数很简单：我们只是连接或者断开定时器的信号。</strong>当我们把这一切都准备好之后，我们把<code>GameController</code>添加到<code>MainWindow</code>中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent),</span><br><span class="line">      game(<span class="keyword">new</span> GameController(scene, <span class="keyword">this</span>))</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>GameController</code>在构造时已经开始游戏循环，因此我们不需要另外调用一个所谓的“start”函数。这样，我们就把第一个食物添加到了游戏场景。</p>
<hr>
<h4 id="snake绘制"><a href="#snake绘制" class="headerlink" title="snake绘制"></a>snake绘制</h4><p>蛇要更复杂一些。在我们的游戏中，蛇是由黄色的小方块组成，这是最简单的实现方式了。第一个是蛇的头部，紧接着是它的身体。对此，我们有两个必须面对的困难：</p>
<ol>
<li>蛇具有复杂得多的形状。因为蛇的形状随着游戏者的控制而不同，因此，我们必须找出一个能够恰好包含蛇头和所有身体块的矩形。这也是 boundingRect() 函数所要解决的问题。</li>
<li>蛇会长大（比如吃了食物之后）。因此，我们需要在蛇对象中增加一个用于代表蛇身体长度的<code>growing</code>变量：当<code>growing</code>为正数时，蛇的身体增加一格；当<code>growing</code>为负数时，蛇的身体减少一格。</li>
<li><code>advance()</code>函数用于编码移动部分，这个函数会在一秒内调用 30 次（这是我们在<code>GameController</code>的定时器中决定的）。</li>
</ol>
<p>我们首先从<code>boundingRect()</code>开始看起：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">QRectF Snake::boundingRect() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    qreal minX = head.x();</span><br><span class="line">    qreal minY = head.y();</span><br><span class="line">    qreal maxX = head.x();</span><br><span class="line">    qreal maxY = head.y();</span><br><span class="line"></span><br><span class="line">    foreach (QPointF p, tail) &#123;</span><br><span class="line">        maxX = p.x() &gt; maxX ? p.x() : maxX;</span><br><span class="line">        maxY = p.y() &gt; maxY ? p.y() : maxY;</span><br><span class="line">        minX = p.x() &lt; minX ? p.x() : minX;</span><br><span class="line">        minY = p.y() &lt; minY ? p.y() : minY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QPointF tl = mapFromScene(QPointF(minX, minY));</span><br><span class="line">    QPointF br = mapFromScene(QPointF(maxX, maxY));</span><br><span class="line"></span><br><span class="line">    QRectF bound = QRectF(tl.x(),  <span class="comment">// x</span></span><br><span class="line">                          tl.y(),  <span class="comment">// y</span></span><br><span class="line">                          br.x() - tl.x() + SNAKE_SIZE,      <span class="comment">// width</span></span><br><span class="line">                          br.y() - tl.y() + SNAKE_SIZE       <span class="comment">//height</span></span><br><span class="line">                          );</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个函数的算法是：遍历蛇身体的每一个方块，找出所有部分的最大的 x 坐标和 y 坐标，以及最小的 x 坐标和 y 坐标。这样，夹在其中的便是蛇身体的外围区域。</li>
</ul>
<p><code>shape()</code> 函数决定了蛇身体的形状，我们遍历蛇身体的每一个方块向路径中添加：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">QPainterPath Snake::shape() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    QPainterPath path;</span><br><span class="line">    path.setFillRule(Qt::WindingFill);</span><br><span class="line"></span><br><span class="line">    path.addRect(QRectF(<span class="number">0</span>, <span class="number">0</span>, SNAKE_SIZE, SNAKE_SIZE));</span><br><span class="line"></span><br><span class="line">    foreach (QPointF p, tail) &#123;</span><br><span class="line">        QPointF itemp = mapFromScene(p);</span><br><span class="line">        path.addRect(QRectF(itemp.x(), itemp.y(), SNAKE_SIZE, SNAKE_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们实现了<code>shape()</code>函数的基础之上，<code>paint()</code>函数就很简单了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Snake::paint(QPainter *painter, <span class="keyword">const</span> QStyleOptionGraphicsItem *, QWidget *)</span><br><span class="line">&#123;</span><br><span class="line">    painter-&gt;save();</span><br><span class="line">    painter-&gt;fillPath(shape(), Qt::yellow);</span><br><span class="line">    painter-&gt;restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们已经把蛇“画”出来。</p>
<hr>
<h4 id="snake动画"><a href="#snake动画" class="headerlink" title="snake动画"></a>snake动画</h4><p>现在，我们开始添加游戏控制的代码。首先我们从最简单的四个方向键开始：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Snake::moveLeft()</span><br><span class="line">&#123;</span><br><span class="line">    head.rx() -= SNAKE_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (head.rx() &lt; <span class="number">-100</span>) &#123;</span><br><span class="line">        head.rx() = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Snake::moveRight()</span><br><span class="line">&#123;</span><br><span class="line">    head.rx() += SNAKE_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (head.rx() &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        head.rx() = <span class="number">-100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Snake::moveUp()</span><br><span class="line">&#123;</span><br><span class="line">    head.ry() -= SNAKE_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (head.ry() &lt; <span class="number">-100</span>) &#123;</span><br><span class="line">        head.ry() = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Snake::moveDown()</span><br><span class="line">&#123;</span><br><span class="line">    head.ry() += SNAKE_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (head.ry() &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        head.ry() = <span class="number">-100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们有四个以 move 开头的函数，内容都很类似：分别以 SNAKE_SIZE 为基准改变头部坐标，然后与场景边界比较，大于边界值时，设置为边界值。这么做的结果是，当蛇运动到场景最右侧时，会从最左侧出来；当运行到场景最上侧时，会从最下侧出来。</p>
<p>然后我们添加一个比较复杂的函数，借此，我们可以看出 Graphics View Framework 的强大之处：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Snake::handleCollisions()</span><br><span class="line">&#123;</span><br><span class="line">    QList&lt;QGraphicsItem *&gt; collisions = collidingItems();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check collisions with other objects on screen</span></span><br><span class="line">    foreach (QGraphicsItem *collidingItem, collisions) &#123;</span><br><span class="line">        <span class="keyword">if</span> (collidingItem-&gt;data(GD_Type) == GO_Food) &#123;</span><br><span class="line">            <span class="comment">// Let GameController handle the event by putting another apple</span></span><br><span class="line">            controller.snakeAteFood(<span class="keyword">this</span>, (Food *)collidingItem);</span><br><span class="line">            growing += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Check snake eating itself</span></span><br><span class="line">    <span class="keyword">if</span> (tail.contains(head)) &#123;</span><br><span class="line">        controller.snakeAteItself(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>首先，我们使用<code>collidingItems()</code>取得所有碰撞的元素。这个函数的签名是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QGraphicsItem *&gt; QGraphicsItem::collidingItems(</span><br><span class="line">        Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) <span class="keyword">const</span></span><br></pre></td></tr></table></figure>
<p>该函数返回与这个元素碰撞的所有元素。Graphcis View Framework 提供了四种碰撞检测的方式：</p>
<ul>
<li><code>Qt::ContainsItemShape</code>：如果被检测物的形状（<code>shape()</code>）完全包含在检测物内，算做碰撞；</li>
<li><code>Qt::IntersectsItemShape</code>：如果被检测物的形状（<code>shape()</code>）与检测物有交集，算做碰撞；</li>
<li><code>Qt::ContainsItemBoundingRect</code>：如果被检测物的包含矩形（<code>boundingRect()</code>）完全包含在检测物内，算做碰撞；</li>
<li><code>Qt::IntersectsItemBoundingRect</code>：如果被检测物的包含矩形（<code>boundingRect()</code>）与检测物有交集，算做碰撞。</li>
</ul>
<p>注意，该函数默认是<code>Qt::IntersectsItemShape</code>。回忆一下，我们之前编写的代码，<code>Food</code>的<code>boundingRect()</code>要大于其实际值，却不影响我们的游戏逻辑判断，这就是原因：因为我们使用的是<code>Qt::IntersectsItemShape</code>判断检测，这与<code>boundingRect()</code>无关。</p>
<p>后面的代码就很简单了。我们遍历所有被碰撞的元素，如果是食物，则进行吃食物的算法，同时将蛇的长度加 1；如果身体包含了头，那就是蛇吃了自己的身体。</p>
</li>
<li><p>还记得我们在 Food 类中有这么一句：<code>setData(GD_Type, GO_Food);</code></p>
<p><code>QGraphicsItem::setData()</code>以键值对的形式设置元素的自定义数据。所谓自定义数据，就是对应用程序有所帮助的用户数据。Qt 不会使用这种机制来存储数据，因此你可以放心地将所需要的数据存储到元素对象。例如，我们在Food的构造函数中，将GD_Type的值设置为GO_Food。那么，这里我们取出GD_Type，如果其值是GO_Food，意味着这个QGraphicsItem就是一个Food，因此我们可以将其安全地进行后面的类型转换。</p>
</li>
</ul>
<p>下面是<code>advance()</code>函数的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Snake::advance(<span class="keyword">int</span> step)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!step) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tickCounter++ % speed != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (moveDirection == NoMove) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (growing &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        tail &lt;&lt; head;</span><br><span class="line">        growing -= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tail.takeFirst();</span><br><span class="line">        tail &lt;&lt; head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (moveDirection) &#123;</span><br><span class="line">        <span class="keyword">case</span> MoveLeft:</span><br><span class="line">            moveLeft();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MoveRight:</span><br><span class="line">            moveRight();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MoveUp:</span><br><span class="line">            moveUp();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MoveDown:</span><br><span class="line">            moveDown();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setPos(head);</span><br><span class="line">    handleCollisions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QGraphicsItem::advance()</code>函数接受一个 int 作为参数。这个 int 代表该函数被调用的时间。<code>QGraphicsItem::advance()</code>函数会被<code>QGraphicsScene::advance()</code>函数调用两次：第一次时这个 int 为 0，代表即将开始调用；第二次这个 int 为 1，代表已经开始调用。在我们的代码中，我们只使用不为 0 的阶段，因此当 !step 时，函数直接返回。</li>
<li><code>tickCounter</code>实际是我们内部的一个计时器。我们使用 speed 作为蛇的两次动作的间隔时间，直接影响到游戏的难度。speed 值越大，两次运动的间隔时间越大，游戏越简单。这是因为随着 speed 的增大，tickCounter % speed != 0 的次数响应越多，刷新的次数就会越少，蛇运动得越慢。</li>
<li><code>moveDirection</code>显然就是运动方向，当是 NoMove 时，函数直接返回。</li>
<li><code>growing</code>是正在增长的方格数。当其大于 0 时，我们将头部追加到尾部的位置，同时减少一个增长值；当其小于 0 时，我们删除第一个，然后把头部添加进去。我们可以把 growing 看做即将发生的变化。比如，我们将 growing 初始化为 7。第一次运行<code>advance()</code>时，由于 7 &gt; 1，因此将头部追加，然后 growing 减少 1。直到 growing 为 0，此时，蛇的长度不再发生变化，直到我们吃了一个食物。</li>
<li>下面是相应的方向时需要调用对应的函数。最后，我们设置元素的坐标，同时检测碰撞。</li>
</ul>
<hr>
<h4 id="用户控制"><a href="#用户控制" class="headerlink" title="用户控制"></a>用户控制</h4><p>接下来完成<code>GameController</code>中有关用户控制的相关代码。</p>
<p>首先，我们来给<code>GameController</code>添加一个事件过滤器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> GameController::eventFilter(QObject *object, QEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;type() == QEvent::KeyPress) &#123;</span><br><span class="line">        handleKeyPressed((QKeyEvent *)event);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QObject::eventFilter(object, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回忆一下，我们使用<code>QGraphicsScene</code>作为游戏场景。为什么不直接继承<code>QGprahicsScene</code>，重写其<code>keyPressEvent()</code>函数呢？这里的考虑是：</p>
<ul>
<li>第一，我们不想只为重写一个键盘事件而继承<code>QGraphicScene</code>。这不符合面向对象设计的要求。继承首先应该有“是一个（is-a）”的关系。我们将游戏场景继承<code>QGraphcisScene</code>当然满足这个关系，无可厚非。但是，继承还有一个“特化”的含义，我们只想控制键盘事件，并没有添加其它额外的代码，因此感觉并不应该作此继承。</li>
<li>第二，我们希望将表示层与控制层分离：明明已经有了<code>GameController</code>，显然，这是一个用于控制游戏的类，那么，为什么键盘控制还要放在场景中呢？这岂不将控制与表现层耦合起来了吗？</li>
</ul>
<p>基于以上两点考虑，我们选择不继承<code>QGraphicsScene</code>，而是在<code>GameController</code>中为场景添加事件过滤器，从而完成键盘事件的处理。下面我们看看这个<code>handleKeyPressed()</code>函数是怎样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GameController::handleKeyPressed(QKeyEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event-&gt;key()) &#123;</span><br><span class="line">        <span class="keyword">case</span> Qt::Key_Left:</span><br><span class="line">            snake-&gt;setMoveDirection(Snake::MoveLeft);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Qt::Key_Right:</span><br><span class="line">            snake-&gt;setMoveDirection(Snake::MoveRight);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Qt::Key_Up:</span><br><span class="line">            snake-&gt;setMoveDirection(Snake::MoveUp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Qt::Key_Down:</span><br><span class="line">            snake-&gt;setMoveDirection(Snake::MoveDown);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码并不复杂：只是设置蛇的运动方向。我们在前面的代码中，已经为蛇添加了运动方向的控制，因此，我们只需要修改这个状态，即可完成对蛇的控制。</p>
<h4 id="游戏逻辑"><a href="#游戏逻辑" class="headerlink" title="游戏逻辑"></a>游戏逻辑</h4><p>接下来，我们要完成游戏逻辑：吃食物、生成新的食物以及咬到自己这三个逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GameController::snakeAteFood(Snake *snake, Food *food)</span><br><span class="line">&#123;</span><br><span class="line">    scene.removeItem(food);</span><br><span class="line">    <span class="keyword">delete</span> food;</span><br><span class="line"></span><br><span class="line">    addNewFood();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是蛇吃到食物。如果蛇吃到了食物，那么，我们将食物从场景中移除，然后添加新的食物。为了避免内存泄露，我们需要在这里 delete 食物，以释放占用的空间。当然，你应该想到，我们肯定会在<code>addNewFood()</code>函数中使用 new 运算符重新生成新的食物。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GameController::addNewFood()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        x = (<span class="keyword">int</span>) (qrand() % <span class="number">100</span>) / <span class="number">10</span>;</span><br><span class="line">        y = (<span class="keyword">int</span>) (qrand() % <span class="number">100</span>) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        x *= <span class="number">10</span>;</span><br><span class="line">        y *= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (snake-&gt;shape().contains(snake-&gt;mapFromScene(QPointF(x + <span class="number">5</span>, y + <span class="number">5</span>))));</span><br><span class="line"></span><br><span class="line">    Food *food = <span class="keyword">new</span> Food(x , y);</span><br><span class="line">    scene.addItem(food);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>addNewFood()</code>代码中，我们首先计算新的食物的坐标：使用一个循环，直到找到一个不在蛇身体中的坐标。为了判断一个坐标是不是位于蛇的身体上，我们利用蛇的shape()函数。需要注意的是，shape()返回元素坐标系中的坐标，而我们计算而得的 x，y 坐标位于场景坐标系，因此我们必须利用<code>QGraphicsItem::mapFromScene()</code>将场景坐标系映射为元素坐标系。当我们计算出食物坐标后，我们在堆上重新创建这个食物，并将其添加到游戏场景。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GameController::snakeAteItself(Snake *snake)</span><br><span class="line">&#123;</span><br><span class="line">    QTimer::singleShot(<span class="number">0</span>, <span class="keyword">this</span>, SLOT(gameOver()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GameController::gameOver()</span><br><span class="line">&#123;</span><br><span class="line">    scene.clear();</span><br><span class="line"></span><br><span class="line">    snake = <span class="keyword">new</span> Snake(*<span class="keyword">this</span>);</span><br><span class="line">    scene.addItem(snake);</span><br><span class="line">    addNewFood();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果蛇咬到了它自己，游戏即宣告结束。因此，我们直接调用<code>gameOver()</code>函数。这个函数将场景清空，然后重新创建蛇并增加第一个食物。为什么我们不直接调用gameOver()函数，而是利用QTimer调用呢？这是因为，我们不应该在一个 update 操作中去清空整个场景。因此我们使用QTimer，在 update 事件之后完成这个操作。否则程序会奔溃。</p>
<p>至此，我们已经把这个简单的贪吃蛇游戏全部完成。其实还没有完成整个游戏：<code>Wall</code>对象完全没有实现，难度控制也没有完成。</p>
<hr>
<h4 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h4><ol>
<li><p>物品坐标是 -100到100，但是显示在右下角 10 像素的正方形内，所以长宽应该是210。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::initScene()</span><br><span class="line">&#123;</span><br><span class="line">    scene-&gt;setSceneRect(<span class="number">-100</span>, <span class="number">-100</span>, <span class="number">210</span>, <span class="number">210</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写event()，通过监听Resize事件设置了窗口的等比例缩放</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MainWindow::event(QEvent *e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;type() == QEvent::Resize) &#123;</span><br><span class="line">        <span class="comment">//QTimer::singleShot(0, this, SLOT(adjustViewSize()));</span></span><br><span class="line">        <span class="keyword">int</span> InnerWidth = <span class="keyword">this</span>-&gt;width();</span><br><span class="line">        <span class="keyword">int</span> InnerHeight = <span class="keyword">this</span>-&gt;height();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (InnerWidth &gt; InnerHeight)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;resize(InnerWidth, InnerWidth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;resize(InnerHeight, InnerHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        adjustViewSize();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::event(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h3>
  </article>
    
  </div>
</div>

    <footer class="main-footer">
  <div class="container">
    © 2018 
  </div>
</footer>
    



<script src="/./runtime.32f029.js"></script><script src="/./vendor.ec1199.js"></script><script src="/./app.5ed5af.js"></script>


  </body>
</html>
