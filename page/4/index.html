<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="Skuaka">


    
    


<meta name="description" content="For you, a thousand times over.">
<meta name="keywords" content="skuaka">
<meta property="og:type" content="website">
<meta property="og:title" content="Skuaka">
<meta property="og:url" content="http://skuaka.cn/page/4/index.html">
<meta property="og:site_name" content="Skuaka">
<meta property="og:description" content="For you, a thousand times over.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Skuaka">
<meta name="twitter:description" content="For you, a thousand times over.">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Skuaka" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/avatar.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Skuaka</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Skuaka</a></h1>
        </hgroup>

        
        <p class="header-subtitle">For you, a thousand times over.</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">Home</a></li>
                        
                            <li><a href="/archives/">Archives</a></li>
                        
                            <li><a href="/tags/">Tags</a></li>
                        
                            <li><a href="/about/">about</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCIE/">CCIE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DDos/">DDos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS-BFS/">DFS,BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DTD/">DTD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DoNotStarve/">DoNotStarve</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dreamweaver/">Dreamweaver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kali/">Kali</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Macos/">Macos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MetaProgram/">MetaProgram</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mp3/">Mp3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenGL/">OpenGL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Perl/">Perl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QT/">QT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Raspberrypi/">Raspberrypi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLserver/">SQLserver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Socks5/">Socks5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sorting/">Sorting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tree/">Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wifi/">Wifi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wireshark/">Wireshark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/base64/">base64</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/epoll/">epoll</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcc-gdb/">gcc,gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reactor/">reactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vultr/">vultr</a></li></ul>
                    </div>
                </section>
                
                
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Skuaka</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Skuaka</a></h1>
            </hgroup>
            
            <p class="header-subtitle">For you, a thousand times over.</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">Home</a></li>
                
                    <li><a href="/archives/">Archives</a></li>
                
                    <li><a href="/tags/">Tags</a></li>
                
                    <li><a href="/about/">about</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" target="_blank" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me">
</nav>
      <div class="body-wrap">
  
    <article id="post-C_C++/C++STL" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/07/C_C++/C++STL/" class="article-date">
      <time datetime="2018-12-07T12:51:15.000Z" itemprop="datePublished">2018-12-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/07/C_C++/C++STL/">C++ STL</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="标准模板库"><a href="#标准模板库" class="headerlink" title="标准模板库"></a>标准模板库</h2><p>STL 提供了一组表示容器、迭代器、函数对象、算法的模板。</p>
<p>STL 容器是同质的，即存储的值的类型相同。</p>
<h3 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h3><p>对于已有的通用方法，类也有可能重新定义成员方法。因为针对特殊元素的成员方法一般比通用方法效率高。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a.size();	<span class="comment">//返回元素数目</span></span><br><span class="line">a.swap(b);	<span class="comment">//交换两个容器的内容</span></span><br><span class="line"></span><br><span class="line">a.begin();	<span class="comment">//返回指向容器中第一个元素的迭代器</span></span><br><span class="line">a.end();	<span class="comment">//返回一个表示超过容器尾的迭代器</span></span><br><span class="line">a.cbegin();	<span class="comment">//c++11 const迭代器</span></span><br><span class="line">a.cend();	<span class="comment">//c++11 const迭代器</span></span><br><span class="line"></span><br><span class="line">copy(it1, it2, it3);	<span class="comment">//前两个参数表示要复制的范围(输入迭代器)，第三个参数表示复制到的位置(输出迭代器)。</span></span><br><span class="line"></span><br><span class="line">for_each(it1, it2, pfun);	<span class="comment">//替换for循环，对指定区间每个元素使用函数对象。不能修改元素值。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x: books)&#123;*pfun(x)&#125;;	<span class="comment">//基于范围的for能修改元素值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*__需要支持随机访问__*/</span></span><br><span class="line"><span class="comment">//随机排列区间中的元素</span></span><br><span class="line">random_shuffle(it1, it2);</span><br><span class="line"><span class="comment">//排列指定区间，默认按照 &lt; 运算符，或者函数对象(接收两个元素引用，返回值bool，false表示顺序不对)</span></span><br><span class="line">sort(it1, it2[, pfun] );</span><br></pre></td></tr></table></figure>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是广义指针。让 STL 能够为不同的容器类提供统一的接口。</p>
<p>每个类都定义了一个合适的迭代器，该迭代器的类型是一个名为 iterator 的 typedef，其作用域为整个类。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::iterator pd;<span class="comment">// pd an iterator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器的行为就像指针</span></span><br><span class="line"><span class="keyword">auto</span> pd = scores.begin(); <span class="comment">// c++ automatic tyoe deduction</span></span><br><span class="line">*pd = <span class="number">22.3</span>;</span><br><span class="line">++pd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(pd = scores.begin(); pd != scores.end(); ++pd)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pd &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h4 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h4><p>不同的算法对迭代器的要求也不同。STL定义了5种迭代器，并根据所需要的类型对算法进行了描述。</p>
<p>例如，find()的原型与下面类似，指出了算法需要一个输入迭代器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>);</span></span><br></pre></td></tr></table></figure>
<h5 id="输入迭代器"><a href="#输入迭代器" class="headerlink" title="输入迭代器"></a>输入迭代器</h5><ul>
<li>术语“输入”是从程序的角度说的，即来自容器的信息被视为输入。</li>
<li>不能修改元素。</li>
<li><p>必须能够访问容器中所有元素，通过支持两种形式的++运算符。</p>
</li>
<li><p>并不能保证第二次遍历容器时，顺序不变。</p>
</li>
<li>是单向迭代器，可以递增，但不能倒退。</li>
</ul>
<h5 id="输出迭代器"><a href="#输出迭代器" class="headerlink" title="输出迭代器"></a>输出迭代器</h5><ul>
<li><p>术语“输出”指用于将信息从程序传输给容器。</p>
</li>
<li><p>只能解引用修改容器值，不能读取。</p>
<p>这点可能很奇怪。其实类似的，发送到显示器上的输出就是如此，cout 可以修改发送到显示器的字符流，却不能读取屏幕上的内容。STL足够通用，其容器可以表示输出设备。</p>
</li>
<li><p>单向迭代器。</p>
</li>
</ul>
<p>简而言之：对于单通行、只读算法，可以使用输入迭代器；单通行、只写，输出迭代器。</p>
<h5 id="正向迭代器"><a href="#正向迭代器" class="headerlink" title="正向迭代器"></a>正向迭代器</h5><ul>
<li><p>只使用++运算符来遍历容器，与输入、输出迭代器不同的是，它总是按相同的顺序遍历。</p>
<p>另外，将正向迭代器递增后，仍然可以对前面的迭代器值解引用，并得到相同的值。</p>
</li>
<li><p>即可以读写，也可以只读：</p>
<p><code>int * pitrw;</code>    <code>const int * pitr;</code></p>
</li>
</ul>
<h5 id="双向迭代器"><a href="#双向迭代器" class="headerlink" title="双向迭代器"></a>双向迭代器</h5><ul>
<li>具有正向迭代器的所有特性，并支持两种递减运算符。</li>
</ul>
<p>比如 reverse() 函数，交换第一个和最后一个元素，并将指向第一个元素的指针加一、指向最后的减一，并重复这种过程。</p>
<h5 id="随机访问迭代器"><a href="#随机访问迭代器" class="headerlink" title="随机访问迭代器"></a>随机访问迭代器</h5><ul>
<li>有些算法要求能够直接跳到容器中的任何一个元素，这叫做随机访问。</li>
<li>随机访问拥有双向迭代器的所有特性，并且支持随机访问（如指针增加运算）和用于对元素进行排序的关系运算符。</li>
</ul>
<h4 id="将指针用作迭代器"><a href="#将指针用作迭代器" class="headerlink" title="将指针用作迭代器"></a>将指针用作迭代器</h4><ul>
<li>指针满足所有迭代器要求。</li>
</ul>
<h4 id="迭代器的输入输出适配器"><a href="#迭代器的输入输出适配器" class="headerlink" title="迭代器的输入输出适配器"></a>迭代器的输入输出适配器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="comment">// *** ostream_iterator ***</span></span><br><span class="line"><span class="comment">// 第一个模板参数指出了被发送给输出流的数据类型</span></span><br><span class="line"><span class="comment">// 第二个模板参数指出输出流使用的字符类型&#123;char, wchar_t&#125;</span></span><br><span class="line"><span class="comment">// 构造函数的第一个参数指出了要用的输出流，可以是文件流</span></span><br><span class="line"><span class="comment">// 构造函数的第二个参数是发送给输出流的每个项后的分隔符</span></span><br><span class="line">ostream_iterator&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; out_iter(<span class="built_in">cout</span>, <span class="string">" "</span>);</span><br><span class="line">copy(dice.begin(), dice.end(), out_iter);	<span class="comment">// copy vector to output stream</span></span><br><span class="line"><span class="comment">// 也可使用匿名迭代器</span></span><br><span class="line">copy(dice.begin(), dice.end(), ostream_iterator&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// *** istream_iterator ***</span></span><br><span class="line"><span class="comment">// 第一个模板参数指出要读取的数据类型</span></span><br><span class="line"><span class="comment">// 第二个模板参数指出输入流使用的字符类型&#123;char, wchar_t&#125;</span></span><br><span class="line"><span class="comment">// 构造函数参数标书使用的输入流，如果省略参数表示输入失败。</span></span><br><span class="line">copy(istream_iterator&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;(<span class="built_in">cin</span>), </span><br><span class="line">    istream_iterator&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;(), dice.begin());	</span><br><span class="line"><span class="comment">//从输入流读取，直到文件结尾、类型不匹配或其他输入故障</span></span><br></pre></td></tr></table></figure>
<h4 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h4><ul>
<li>对 reverse_iterator 执行<strong>递增</strong>操作将导致它被<strong>递减</strong>。</li>
</ul>
<p>vector 类有名为 rbegin() 和 rend() 的成员函数，分别返回指向超尾和第一个元素的反向迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(dice.rbegin(), dice.rend(), out_iter);	<span class="comment">// display in reverse order</span></span><br></pre></td></tr></table></figure>
<p>反向指针通过”先递减、再解引用”来访问到每一个项。</p>
<h4 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h4><p>插入将添加新的元素，而不会覆盖已有的数据，并使用自动内存分配来确保能容纳新的元素。</p>
<p><strong>三种类型</strong>：</p>
<ul>
<li>back_insert_iterator 将元素插入到容器尾部</li>
<li>front_insert_iterator 将元素插入到容器前端</li>
<li>insert_iterator 将元素插入到构造函数指定的位置的前面</li>
</ul>
<p><strong>使用</strong>：</p>
<ul>
<li><p>将容器作为模板参数，将实际的容器标识符作为构造函数参数。</p>
<p><code>back_insert_iterator&lt;vector&lt;int&gt; &gt; back_iter(dice);</code></p>
<p>back_insert_iterator 将假定传递给它的类型有一个 push_back() 方法。</p>
</li>
<li><p>对于 insert_iterator ，还需要一个指示插入位置的构造函数参数：</p>
<p><code>insert_iterator&lt;vector&lt;int&gt; &gt; back_iter(dice, dice.begin() );</code></p>
</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>back_insert_iterator 只能用于允许在尾部快速插入的容器(时间固定的算法)，vector符合</li>
<li>front_insert_iterator 只能用于允许在起始位置做时间固定插入的容器，vector不符合，但queue满足</li>
<li>insert_iterator 没有这些限制，可以用它来插入到 vector 前端，但速度慢。</li>
</ul>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul>
<li><p>STL具有容器概念和容器类型。</p>
<p><strong>容器概念</strong>是具有相同名称（如容器、序列容器、关联容器等）的通用类别；</p>
<p><strong>容器类型</strong>是可用于创建具体容器对象的模板。</p>
</li>
<li><p>容器是存储其他对象的对象。被存储的对象必须是<strong>同类型</strong>的，可以是内置类型值。</p>
</li>
<li><p>不是任何类型的对象都能存储在容器中。</p>
<p>类型必须是可复制构造的和可赋值的。</p>
<p>基本类型满足要求；只要类定义没有将复制构造函数和赋值运算符声明为私有的，也满足要求。</p>
</li>
</ul>
<p><strong>基本的容器特征</strong></p>
<ol>
<li>上文介绍的STL通用方法</li>
<li><code>X::iterator</code> 指向 T 的迭代器类型。要求：满足正向迭代器的任何迭代器。</li>
<li><code>X::value_type</code> T 的类型。</li>
</ol>
<h4 id="所有容器"><a href="#所有容器" class="headerlink" title="所有容器"></a>所有容器</h4><p><strong>11个基本容器</strong>：</p>
<p>deque、list、</p>
<p>queue、priority_queue、</p>
<p>stack、vector、</p>
<p>map、multimap、</p>
<p>set、multiset、bitset。</p>
<p><strong>5个c++11新增</strong>：</p>
<p>forward_list、</p>
<p>unordered_map、unordered_multimap、</p>
<p>unordered_set、unordered_multiset。</p>
<h4 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h4><p><strong>7种容器</strong>：</p>
<p>deque、queue、priority_queue、</p>
<p>list、forward_list (c++11)、</p>
<p>stack、vector 。</p>
<p><strong>要求</strong>：</p>
<ul>
<li><p>正向迭代器（保证了元素按特定顺序排列，不会在两次迭代之间发生变化）</p>
</li>
<li><p>线性顺序（树的分支结构就不是）</p>
</li>
</ul>
<p><strong>通用成员</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">a</span><span class="params">(n,t)</span></span>;	<span class="comment">// 声明一个名为a的由n个t值组成的序列</span></span><br><span class="line"><span class="function">X <span class="title">a</span><span class="params">(i,j)</span></span>;	<span class="comment">// 声明并初始化为区间[i,j)的内容</span></span><br><span class="line"></span><br><span class="line">a.insert(p,t);	<span class="comment">// 将t插入到p的前面。返回迭代器。</span></span><br><span class="line">a.insert(p,n,t);<span class="comment">// 将n个t插入到p的前面。返回void。</span></span><br><span class="line">a.insert(p,i,j);<span class="comment">// 将区间[i,j)中的元素插入到p的前面。返回void。</span></span><br><span class="line"></span><br><span class="line">a.erase(p);		<span class="comment">// 删除p指向的元素。返回迭代器。</span></span><br><span class="line">a.erase(p,q);	<span class="comment">// 删除区间[p,q)中的元素。返回迭代器。</span></span><br><span class="line">a.clear();		<span class="comment">// 等价于 erase(begin(), end() )</span></span><br></pre></td></tr></table></figure>
<p><strong>可选成员</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*表达式*/</span>		<span class="comment">/*返回类型*/</span>	<span class="comment">/*含义*/</span>			<span class="comment">/*容器*/</span></span><br><span class="line">a.front();		  T&amp;		*a.begin()		<span class="built_in">list</span>、<span class="built_in">deque</span>、<span class="built_in">vector</span></span><br><span class="line">a.back();		  T&amp;		*--a.end()		<span class="built_in">list</span>、<span class="built_in">deque</span>、<span class="built_in">vector</span></span><br><span class="line">a.push_front(t);  <span class="keyword">void</span>						<span class="built_in">list</span>、<span class="built_in">deque</span>、</span><br><span class="line">a.push_back(t);	  <span class="keyword">void</span>						<span class="built_in">list</span>、<span class="built_in">deque</span>、<span class="built_in">vector</span></span><br><span class="line">a.pop_front(t);   <span class="keyword">void</span>						<span class="built_in">list</span>、<span class="built_in">deque</span>、</span><br><span class="line">a.pop_back(t);    <span class="keyword">void</span>						<span class="built_in">list</span>、<span class="built_in">deque</span>、<span class="built_in">vector</span></span><br><span class="line">a[n]			  T&amp;						    、<span class="built_in">deque</span>、<span class="built_in">vector</span></span><br><span class="line">a.at(n)			  T&amp;						    、<span class="built_in">deque</span>、<span class="built_in">vector</span></span><br><span class="line"><span class="comment">//at(n)和a[n]区别在于会检查n是否合法。必要时引发out_of_range异常。</span></span><br></pre></td></tr></table></figure>
<h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><p>简单地说，vector是数组的一种类表示。</p>
<p>除序列外，vector还是<strong>可反转容器概念</strong>的模型，增加了<code>rbegin()</code>和<code>rend()</code>。</p>
<p>vector 是最简单的序列类型，除非其他类型的特殊优点能更好地满足程序的要求，否则应默认使用这种类型。</p>
<h5 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h5><p>双端列队</p>
<p>和vector差不多。</p>
<p>主要区别：从deque的开始位置插入和删除元素的时间是固定的，而不像vector是线性的。</p>
<h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p>双向链表</p>
<p>可反转容器，不支持随机访问。</p>
<p>vector 强调的是通过随机访问进行快速访问，而 list 强调的是元素的快速插入和删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将链表x与调用链表合并。</span></span><br><span class="line"><span class="comment">//1.两个链表必须已经排序。</span></span><br><span class="line"><span class="comment">//2.合并后的经过排序的链表存在调用链表中，x清空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">list</span>&lt;T,Alloc&gt;&amp; x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从链表中删除val的所有实例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span>;</span><br><span class="line"><span class="comment">// 如果谓词返回true,删除这些元素</span></span><br><span class="line">scores.remove_if(tooBig);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用&lt;运算符对链表进行排序。O(NlogN)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表x的内容插入到pos的前面，x清空</span></span><br><span class="line"><span class="comment">// 和insert()的区别在于：splice()是移动原内容，insert()是插入副本。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator pos, <span class="built_in">list</span>&lt;T,Alloc&gt; x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将连续的相同元素压缩为单个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unique</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sort()、merge()、unique() 还各自拥有接受另一个参数的版本，该参数用于指定用来比较元素的函数。</span></span><br><span class="line"><span class="comment">   remove() 也可以有另一个参数，用于确定是否删除元素的函数。</span></span><br><span class="line"><span class="comment">   这些参数都是谓词函数。 */</span></span><br></pre></td></tr></table></figure>
<p>用途举例：</p>
<p>假如有两个邮件列表要整理，可以对每个列表进行排序，合并它们，然后删除重复的元素。</p>
<h5 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h5><p>单链表</p>
<p>不可反转，只需要正向迭代器。</p>
<h5 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h5><p>队列</p>
<p>是一个适配器类，底层默认还是 deque。</p>
<p>不允许随机访问，甚至不允许遍历。</p>
<p>操作被限制在定义队列的基本操作上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span> </span>;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span><span class="keyword">const</span> </span>;</span><br><span class="line"><span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>;	<span class="comment">// 队尾插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;		<span class="comment">// 队首弹出</span></span><br></pre></td></tr></table></figure>
<h5 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h5><p>优先队列</p>
<p>是另一个适配器类，默认的底层类是 vector。</p>
<p>支持的操作和 queue 相同。</p>
<p><strong>区别</strong>：</p>
<ul>
<li><p>最大的元素被移到队首。</p>
<p>可以修改确定哪个元素放到队首的比较方式，方法是提供一个可选的构造函数参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq1;				<span class="comment">// defult version</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq2(greater&lt;<span class="keyword">int</span>&gt;);	<span class="comment">// use greater&lt;int&gt; to order</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h5><p>栈</p>
<p>也是一个适配器类，默认底层是 vector。</p>
<p>不允许随机访问，甚至不允许遍历。</p>
<p>操作被限制在定义栈的基本操作上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span> </span>;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span><span class="keyword">const</span> </span>;</span><br><span class="line"><span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>;	<span class="comment">// 栈顶插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;				<span class="comment">// 栈顶弹出</span></span><br></pre></td></tr></table></figure>
<h5 id="array"><a href="#array" class="headerlink" title="array"></a>array</h5><p>不是STL容器，因为其长度是固定的。</p>
<p>头文件：<code>&lt;array&gt;</code></p>
<p>array没有定义调整容器大小的操作，但是定义了对它来说有意义的成员函数，比如 <code>operator[]()</code> 和 <code>at()</code></p>
<p>可以将很多STL算法用于array，比如<code>copy()</code> 和 <code>for_each()</code>。</p>
<h4 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h4><p><strong>4种容器</strong>：</p>
<p>set、multiset、</p>
<p>map、multimap。</p>
<p><strong>要求</strong>：</p>
<ul>
<li><p>关联容器将值与键关联在一起，并使用键来查找值。键被看做常量。</p>
</li>
<li><p>对于容器 X，<code>X::value_type</code> 指出存储在容器中的值类型；</p>
<p>对于关联容器，<code>X::key_type</code> 指出了键的类型。</p>
</li>
<li><p>关联容器通常是用树实现的，查找速度更快。</p>
</li>
</ul>
<p><strong>4种容器都有的性质</strong>：</p>
<ul>
<li>可反转的</li>
<li>本身就是排序的</li>
</ul>
<h5 id="multi-set"><a href="#multi-set" class="headerlink" title="(multi)set"></a>(multi)set</h5><p>值与键类型相同，对于set来说，值就是键。</p>
<p>multiset 类似于 set，区别是可以有多个值的键相同。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个模板参数是可选的，用来指示对键进行排序的比较函数或对象。默认用 less&lt;T&gt;</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; A;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>, greater&lt;<span class="built_in">string</span>&gt; &gt; A;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set_union、set_intersection、set_difference</span></span><br><span class="line"><span class="comment">// 分别查找并集、交集、差集。</span></span><br><span class="line"><span class="comment">// 接口：前两个迭代器定义了第一个集合的区间，后两个定义第二个区间，最后一个是输出迭代器。</span></span><br><span class="line">set_union(A.begin(), A.end(), B.begin(), B.end(),</span><br><span class="line">         ostream_iterator&lt;<span class="built_in">string</span>, <span class="keyword">char</span>&gt; out(<span class="built_in">cout</span>, <span class="string">" "</span>) );</span><br><span class="line"><span class="comment">// 假设要将结果放到集合C，而不是显示它，则最后一个参数应是一个指向C的迭代器。</span></span><br><span class="line"><span class="comment">// 首先想到用C.begin()，但是存在问题：</span></span><br><span class="line"><span class="comment">// 	1.关联容器的键是常量，所以 C.begin()是const迭代器，不能用作输出迭代器。</span></span><br><span class="line"><span class="comment">// 	2.与 copy() 相似，set_union() 将覆盖容器中已有的数据，并要求容器有足够的空间容纳新信息。</span></span><br><span class="line"><span class="comment">// 模板 insert_iterator 可解决这两个问题，它将复制转换为插入，还模拟了输出迭代器概念。</span></span><br><span class="line">set_union(A.begin(), A.end(), B.begin(), B.end(),</span><br><span class="line">         insert_iterator&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; &gt;(C, C.begin() ) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// lower_bound()、upper_bound()</span></span><br><span class="line"><span class="comment">// 将键作为参数并返回一个迭代器，该迭代器指向集合中第一个&#123;不小于,大于&#125;键参数的成员。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// insert()</span></span><br><span class="line"><span class="comment">// 因为排序决定了插入的位置，所以不需要指定插入位置</span></span><br></pre></td></tr></table></figure>
<h5 id="multi-map"><a href="#multi-map" class="headerlink" title="(multi)map"></a>(multi)map</h5><p>值与键类型不同</p>
<p>multimap 类似于 map，区别是可以有多个值的键相同。</p>
<ul>
<li><p>STL 使用模板 <code>pair&lt;class T, class U&gt;</code> 将建类型和数据类型存储到一个对象(<strong>值</strong>)中。</p>
<p>如果 keytype 是键类型， datatype 是存储的数据类型，则<strong>值类型</strong>为<code>pair&lt;const keytype, datatype&gt;</code></p>
</li>
<li><p>对于pair对象，可以使用 first 和 second 成员来访问其两部分</p>
<p><code>cout &lt;&lt; item.first &lt;&lt; &#39; &#39; &lt;&lt; item.second &lt;&lt; endl;</code></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板参数为：键类型，值类型，可选的排序比较函数或对象</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>, less&lt;<span class="keyword">int</span>&gt; &gt; codes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个pair，然后插入</span></span><br><span class="line">pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="built_in">string</span>&gt; item(<span class="number">213</span>, <span class="string">"Los"</span>);</span><br><span class="line">codes.insert(item);</span><br><span class="line"><span class="comment">// 或者直接插入匿名pair</span></span><br><span class="line">codes.insert(pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">213</span>, <span class="string">"Los"</span>));</span><br><span class="line"><span class="comment">// 或者使用数组表示法</span></span><br><span class="line">code[<span class="number">213</span>] = <span class="string">"Los"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count()</span></span><br><span class="line"><span class="comment">// 键作为参数，返回具有该键的元素数目。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lower_bound()、upper_bound()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// equal_range()</span></span><br><span class="line"><span class="comment">// 键作为参数，返回两个迭代器，它们表示的区间与该键匹配。</span></span><br><span class="line"><span class="comment">// 为了返回两个值，该方法将它们封装在一个 pair 对象中，它的两个模板参数都是迭代器。</span></span><br></pre></td></tr></table></figure>
<h4 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h4><p><strong>4种容器</strong>：</p>
<p>unordered_set、unordered_multiset、</p>
<p>unordered_map、unordered_multimap。</p>
<p><strong>区别</strong>：</p>
<ul>
<li><p>关联容器基于树结构，而无序关联容器基于哈希表。</p>
<p>这旨在提高添加和删除元素的速度以及查找算法的效率。</p>
</li>
</ul>
<h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><ul>
<li><p>很多STL算法都使用函数对象，也叫函数符（functor）。</p>
</li>
<li><p>函数符是可以以函数方式与( )结合使用的任意对象，包括：</p>
<p>函数名、指向函数的指针、重载了( )运算符的类对象</p>
</li>
</ul>
<h4 id="函数符概念"><a href="#函数符概念" class="headerlink" title="函数符概念"></a>函数符概念</h4><ul>
<li><p><strong>生成器</strong>（generator）：不用参数就可以调用的函数符</p>
</li>
<li><p><strong>一元函数</strong>（unary function）：一个参数</p>
</li>
<li><p><strong>二元函数</strong>（binary function）：两个参数</p>
</li>
</ul>
<hr>
<ul>
<li><strong>谓词</strong>（predicate）：返回bool值的一元函数</li>
<li><strong>二元谓词</strong>（binary predicate）：返回bool值的二元函数</li>
</ul>
<p>一些 STL 函数需要谓词参数。比如 sort。</p>
<h4 id="函数适配器概念"><a href="#函数适配器概念" class="headerlink" title="函数适配器概念"></a>函数适配器概念</h4><p>类函数符可以作为函数适配器，使函数能够满足不同的接口。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有一个接收两个参数的模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">bool</span> <span class="title">tooBig</span>(<span class="title">const</span> <span class="title">T</span> &amp; <span class="title">val</span>, <span class="title">const</span> <span class="title">T</span> &amp; <span class="title">lim</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> val &gt; lim;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以将它转化为单个参数的函数对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span>&#123;</span></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">        T cutoff;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        TooBig2(<span class="keyword">const</span> T &amp; t) : cutoff(t) &#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp; v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> tooBig&lt;T&gt;(v, cutoff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 就可以这样做</span></span><br><span class="line">TooBig2&lt;<span class="keyword">int</span>&gt; tB100&#123;<span class="number">100</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span>(tB100(x))	<span class="comment">//same as if(tooBig(x,100))</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="预定义函数符"><a href="#预定义函数符" class="headerlink" title="预定义函数符"></a>预定义函数符</h4><p>STL 定义了多个基本函数符，这是为了支持将函数符作为参数的 STL 函数。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transform(gr.begin(), gr.end(), out, <span class="built_in">sqrt</span>);</span><br><span class="line">transform(gr.begin(), gr.end(), m.begin(), out, plus&lt;<span class="keyword">double</span>&gt;());</span><br><span class="line"><span class="comment">//plus&lt;double&gt;构造函数构造了一个函数符，以完成相加运算，括号表示调用默认构造函数。</span></span><br></pre></td></tr></table></figure>
<p>头文件<code>functional</code>定义了多个模板函数对象。</p>
<h5 id="运算符和相应的函数符"><a href="#运算符和相应的函数符" class="headerlink" title="运算符和相应的函数符"></a>运算符和相应的函数符</h5><table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">函数符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">plus</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">minus</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">multiples</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">divides</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">modulus</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">negate</td>
</tr>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">equal_to</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">not_equal_to</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">greater</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">less</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center">greater_equal</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center">less_equal</td>
</tr>
<tr>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">logical_and</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">\</td>
<td></td>
<td>logical_or</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">logical_not</td>
</tr>
</tbody>
</table>
<h4 id="自适应函数符"><a href="#自适应函数符" class="headerlink" title="自适应函数符"></a>自适应函数符</h4><p>上面列出的预定义函数符都是自适应的。</p>
<ul>
<li><p><strong>原因</strong>：它携带了标识参数类型和返回类型的 typedef 成员。</p>
<p>这些成员分别是：result_type、first_argument_type、second_argument_type …</p>
</li>
<li><p><strong>意义</strong>：函数适配器对象可以使用函数对象，并认为存在这些typedef对象。</p>
<p>例如，接受一个自适应函数符参数的函数可以使用result_type成员来声明一个与函数的返回类型匹配的变量。</p>
</li>
</ul>
<h5 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h5><ul>
<li><p>STL 使用<strong><em>类</em></strong>  <strong>binder1st</strong> 和 <strong>binder2st</strong> 将自适应二元函数转换为自适应一元函数。</p>
<p>假设有一个自适应二元函数对象 f2()，则可以创建一个 binder1st 对象，该对象与一个将被用作 f2() 的第一个参数的特定值（val）相关联：</p>
<p><code>binder1st(f2, val) f1;</code></p>
</li>
<li><p>STL 提供了<strong><em>函数</em></strong>  <strong>bind1st</strong> 和 <strong>bind2st</strong> 简化使用。它们返回上述类对象。</p>
<p><code>transform(gr.begin(), gr.end(), out, bind1st(multiplies&lt;double&gt;(), 2.5))</code></p>
</li>
</ul>
<h4 id="lambda表达式-C-11"><a href="#lambda表达式-C-11" class="headerlink" title="lambda表达式 C++11"></a>lambda表达式 C++11</h4><p>提供了函数指针和函数符的替代品</p>
<p>待续。。。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li><p>算法都是内联的。</p>
</li>
<li><p>对于算法函数设计，首先，它们都使用模板来提供泛型；其次，它们都使用迭代器来提供访问容器中数据的通用表示。</p>
</li>
<li><p>可以用==来比较不同类型的容器，因为容器重载的==运算符使用迭代器来比较内容，因此如果deque对象和vector对象的内容相同并且顺序相同，则它们是相等的。</p>
</li>
<li><p>STL 将算法库分成4组：</p>
<ol>
<li>非修改式序列操作</li>
<li>修改式序列操作</li>
<li>排序和相关操作</li>
<li>通用数字运算</li>
</ol>
<p>前三组在头文件 algorithm 中，第四组在 numeric 中。</p>
</li>
<li><p><code>_copy</code></p>
<p><strong>就地算法</strong>在算法完成时，结果被放到原始数据的位置上；</p>
<p><strong>复制算法</strong>将结果发送到另一个位置。</p>
<p>STL的约定是：</p>
<ol>
<li>复制版本的名称以 <code>_copy</code> 结尾。</li>
<li>复制版本将接受一个额外的输出迭代器参数。</li>
<li>复制算法返回一个迭代器，该迭代器指向复制的最后一个值后面的位置。</li>
</ol>
</li>
<li><p><code>_if</code><br>有些函数有另一个版本，即根据将函数应用于容器元素得到的结果来执行操作。它们的名字以 <code>_if</code> 结尾。</p>
<p>它们需要一个额外的谓词参数：<code>&lt;..., class Predicate, ...&gt;</code></p>
<p>同样，STL使用诸如 Generator 和 BinaryPredicate 等术语来表示需要模拟其他函数对象概念的参数。</p>
</li>
<li><p>string类</p>
<p>string类虽然不是STL的组成部分，但设计它时考虑到了STL。例如它包含：<code>begin(),end(),rbegin(),rend()</code></p>
<p>获得区间内容的排列组合：<code>next_permutation()</code> 算法将区间内容转换为下一种排列方式。对于字符串，排列按照字母递增的顺序进行。如果成功，返回true；如果区间已处于最后的序列中，则返回false。</p>
</li>
</ul>
<h2 id="其他库"><a href="#其他库" class="headerlink" title="其他库"></a>其他库</h2><p>vector、valarray、array。</p>
<p>它们是由不同的小组开发的，用于不同目的。</p>
<p>vector 模板类是一个容器类和算法系统的一部分，它支持面向容器的操作。</p>
<p>valarray 模板类是面向数值计算的，不是STL的一部分。</p>
<p>array 是为替代内置数组而设计的，她通过提供更好、更安全的接口，让数组更紧凑、效率更高。很多STL算法也能使用。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Algorithm/查找树" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/07/Algorithm/查找树/" class="article-date">
      <time datetime="2018-12-07T05:57:22.000Z" itemprop="datePublished">2018-12-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/07/Algorithm/查找树/">查找树</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。</p>
<p>使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN)。而未优化的空间复杂度为2N，实际应用时一般还要开4N的数组以免越界，因此有时需要离散化让空间压缩。</p>
<p><img src="Picture/线段树00.png" alt="线段树00"></p>
<h2 id="平衡查找树"><a href="#平衡查找树" class="headerlink" title="平衡查找树"></a>平衡查找树</h2><p>在一颗含有N个结点的树中，我们希望树高为~lgN，这样我们就能保证所有查找都能在~lgN此比较内结束，就和二分查找一样。不幸的是，在动态插入中保证树的完美平衡的代价太高了。我们放松对完美平衡的要求，使符号表API中所有操作均能够在对数时间内完成。</p>
<h3 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p>为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键。</p>
<p>2-结点：含有一个键(及值)和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。</p>
<p>3-结点：含有两个键(及值)和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。</p>
<p><img src="Picture/2-3树01.jpeg" alt="2-3树"></p>
<p>一颗完美平衡的2-3查找树中的所有空链接到根结点的距离都是相同的。</p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中的任何一个相等，查找命中。否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中。</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>要在2-3树中插入一个新结点，我们可以和二叉查找树一样先进行一次未命中的查找，然后把新结点挂在树的底部。但这样的话树无法保持完美平衡性。<strong>我们使用2-3树的主要原因就在于它能够在插入之后继续保持平衡。</strong></p>
<h5 id="向2-结点中插入"><a href="#向2-结点中插入" class="headerlink" title="向2-结点中插入"></a>向2-结点中插入</h5><p>如果未命中的查找结束于一个2-结点，我们只要把这个2-结点替换为一个3-结点，将要插入的键保存在其中即可。</p>
<h5 id="向自身为树根的3-结点中插入"><a href="#向自身为树根的3-结点中插入" class="headerlink" title="向自身为树根的3-结点中插入"></a>向自身为树根的3-结点中插入</h5><p>只有一个3-结点的树，向其插入一个新键。</p>
<p>这棵树唯一的结点中已经没有可插入的空间了。我们又不能把新键插在其空结点上（破坏了完美平衡）。为了将新键插入，我们先临时将新键存入该结点中，使之成为一个4-结点。</p>
<p>创建一个4-结点很方便，因为很容易将它转换为一颗由3个2-结点组成的2-3树（如图所示），这棵树既是一颗含有3个结点的二叉查找树，同时也是一颗完美平衡的2-3树，其中所有空链接到根结点的距离都相等。</p>
<p><img src="Picture/2-3树02.jpeg" alt="2-3树02"></p>
<h5 id="向父结点为2-结点的3-结点中插入"><a href="#向父结点为2-结点的3-结点中插入" class="headerlink" title="向父结点为2-结点的3-结点中插入"></a>向父结点为2-结点的3-结点中插入</h5><p>我们先像刚才一样构造一个临时的4-结点并将其分解，但此时我们不会为中键创建一个新结点，而是将其移动至原来的父结点中。</p>
<p><img src="Picture/2-3树03.jpeg" alt="2-3树03"></p>
<h5 id="向父结点为3-结点的3-结点中插入"><a href="#向父结点为3-结点的3-结点中插入" class="headerlink" title="向父结点为3-结点的3-结点中插入"></a>向父结点为3-结点的3-结点中插入</h5><p>我们再次和刚才一样构造一个临时的4-结点并分解它，然后将它的中键插入它的父结点中。但父结点也是一个3-结点，因此我们再用这个中键构造一个新的临时4-结点，然后在这个结点上进行相同的变换，即分解这个父结点并将它的中键插入到它的父结点中去。</p>
<p>我们就这样一直向上不断分解临时的4-结点并将中键插入更高的父结点，直至遇到一个2-结点并将它替换为一个不需要继续分解的3-结点，或者是到达3-结点的根。</p>
<p><img src="Picture/2-3树04.jpeg" alt="2-3树04"></p>
<h5 id="插入总结"><a href="#插入总结" class="headerlink" title="插入总结"></a>插入总结</h5><p>先找插入结点，若结点有空(即2-结点)，则直接插入。如结点没空(即3-结点)，则插入使其临时容纳这个元素，然后分裂此结点，把中间元素移到其父结点中。对父结点亦如此处理。（中键一直往上移，直到找到空位，在此过程中没有空位就先搞个临时的，再分裂。）</p>
<p> ★2-3树插入算法的根本在于这些变换都是局部的：除了相关的结点和链接之外不必修改或者检查树的其他部分。每次变换中，变更的链接数量不会超过一个很小的常数。所有局部变换都不会影响整棵树的有序性和平衡性。</p>
<h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>和标准的二叉查找树由上向下生长不同，2-3树的生长是由下向上的。</p>
<p><img src="Picture/2-3树05.jpeg" alt="2-3树05"></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>2-3树在最坏情况下仍有较好的性能。每个操作中处理每个结点的时间都不会超过一个很小的常数，且这两个操作都只会访问一条路径上的结点，所以任何查找或者插入的成本都肯定不会超过对数级别。</p>
<p>完美平衡的2-3树要平展的多。例如，含有10亿个结点的一颗2-3树的高度仅在19到30之间。我们最多只需要访问30个结点就能在10亿个键中进行任意查找和插入操作。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>我们需要维护两种不同类型的结点，查找和插入操作的实现需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。</p>
<p>平衡一棵树的初衷是为了消除最坏情况，但我们希望这种保障所需的代码能够越少越好。</p>
<h3 id="红黑二叉查找树"><a href="#红黑二叉查找树" class="headerlink" title="红黑二叉查找树"></a>红黑二叉查找树</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>若是要在代码级理解红黑树，则势必需要记住其复杂的插入和旋转的各种情况，我认为那只有助于增加大家对红黑树的恐惧，实际面试和工作中几乎不会遇到需要自己动手实现红黑树的情况(很多语言的标准库中就有红黑树的实现)。 </p>
<p>☆理解红黑树一句话就够了：<strong>红黑树就是用红链接表示3-结点的2-3树</strong>。</p>
<p>那么红黑树的插入、构造就可转化为2-3树的问题。这样，我们就不用记那么复杂且让人头疼的红黑树插入旋转的各种情况了。只要清楚2-3树的插入方式即可。</p>
<p><strong>红黑树的本质</strong>：</p>
<p>红黑树是对2-3查找树的改进，它能用一种统一的方式完成所有变换。</p>
<h5 id="用红链接替换3-结点"><a href="#用红链接替换3-结点" class="headerlink" title="用红链接替换3-结点"></a>用红链接替换3-结点</h5><p>★红黑树背后的思想是用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。</p>
<p>我们将树中的链接分为两种类型：</p>
<p><strong>黑链接</strong>是2-3树中的普通链接。</p>
<p><strong>红链接</strong>将两个2-结点连接起来构成一个3-结点，确切地说，我们将3-结点表示为由一条<strong>左斜</strong>的红色链接相连的两个2-结点。</p>
<p>这种表示法的一个优点是，我们无需修改就可以直接使用标准二叉查找树的get()方法。对于任意的2-3树，只要对结点进行转换，我们都可以立即派生出一颗对应的二叉查找树。我们将用这种方式表示2-3树的二叉查找树称为红黑树。</p>
<p><img src="Picture/2-3树06.jpeg" alt="2-3树06"></p>
<p><strong>红黑树的另一种定义</strong>是满足下列条件的二叉查找树：</p>
<p>⑴红链接均为左链接。</p>
<p>⑵没有任何一个结点同时和两条红链接相连。</p>
<p>⑶<strong>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同</strong>。</p>
<p><strong>如果我们将一颗红黑树中的红链接画平，那么所有的空链接到根结点的距离都将是相同的</strong>。如果我们将由红链接相连的结点合并，得到的就是一颗2-3树。</p>
<p>相反，如果将一颗2-3树中的3-结点画作由红色左链接相连的两个2-结点，那么不会存在能够和两条红链接相连的结点，且树必然是完美平衡的。</p>
<p><img src="Picture/2-3树07.jpeg" alt="2-3树07"></p>
<p>无论我们用何种方式去定义它们，红黑树都既是二叉查找树，也是2-3树。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>2-3树的深度很小，平衡性好，效率高，但是其有两种不同的结点，实际代码实现比较复杂。而红黑树用红链接表示2-3树中另类的3-结点，统一了树中的结点类型，使代码实现简单化，又不破坏其高效性。</p>
<h4 id="颜色表示"><a href="#颜色表示" class="headerlink" title="颜色表示"></a>颜色表示</h4><p>因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们将链接的颜色保存在表示结点的Node数据类型的布尔变量color中（若指向它的链接是红色的，那么该变量为true，黑色则为false）。</p>
<p>当我们提到一个结点颜色时，我们指的是指向该结点的链接的颜色。</p>
<h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><h5 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h5><p>在我们实现的某些操作中可能会出现红色右链接或者两条连续的红链接，但在操作完成前这些情况都会被小心地旋转并修复。</p>
<p>（我们在这里不讨论旋转的几种情况，把红黑树看做2-3树，自然可以得到正确的旋转后结果）</p>
<p>在插入时我们可以使用旋转操作帮助我们保证2-3树和红黑树之间的一一对应关系，因为旋转操作可以保持红黑树的两个重要性质：有序性和完美平衡性。</p>
<h5 id="向2-结点中插入-1"><a href="#向2-结点中插入-1" class="headerlink" title="向2-结点中插入"></a>向2-结点中插入</h5><p>向红黑树中插入操作时，想想2-3树的插入操作。红黑树与2-3树在本质上是相同的，只是它们对3结点的表示不同。</p>
<p>向一个只含有一个2-结点的2-3树中插入新键后，2-结点变为3-结点。我们再把这个3-结点转化为红结点即可。</p>
<p><img src="Picture/2-3树08.jpeg" alt="2-3树08"></p>
<p>（这图一开始没看懂，再仔细想：2-3树如果命中结点是2-结点，则直接成为3-结点，既然是3-结点了，所以要用红链接表示）</p>
<h5 id="向一颗双键树（即一个3-结点）中插入"><a href="#向一颗双键树（即一个3-结点）中插入" class="headerlink" title="向一颗双键树（即一个3-结点）中插入"></a>向一颗双键树（即一个3-结点）中插入</h5><p>向红黑树中插入操作时，想想2-3树的插入操作。你把红黑树当做2-3树来处理插入，一切都变得简单了。</p>
<p>向2-3树中的一个3-结点插入新键，这个3结点临时成为4-结点，然后分裂成3个2结点</p>
<p><img src="Picture/2-3树09.jpeg" alt="2-3树09"></p>
<h4 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h4><p><img src="Picture/2-3树10.png" alt="2-3树10"></p>
<h3 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>平衡二叉树(Balance Binary Tree)又称AVL树。</p>
<p>它或者是一颗空树，或者是具有下列性质的二叉树：</p>
<ol>
<li>它的左子树和右子树都是平衡二叉树</li>
<li>左子树和右子树的深度之差的绝对值不超过1。</li>
</ol>
<p>其旋转操作 用2-3树的分裂来类比想象。</p>
<h2 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h2><p>B树和B-树是同一种树，只不过英语中B-tree被中国人翻译成了B-树，让人以为B树和B-树是两种树，实际上，两者就是同一种树，</p>
<p>M为设定的非叶子结点最多子树个数，N为关键字总数。</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p><strong>B 树</strong>可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。</p>
<ul>
<li>根节点至少有两个子节点</li>
<li>每个节点有M-1个key，并且以升序排列</li>
<li>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</li>
<li>其它节点至少有M/2个子节点</li>
</ul>
<p>B树的插入及平衡化操作和2-3树很相似，B-树的性能总是等价于二分查找（与M值无关）。</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p><strong>B+</strong>树是对B树的一种变形树，它与B树的差异在于：</p>
<ul>
<li>有k个子结点的结点必然有k个关键码；</li>
<li>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。</li>
<li>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。</p>
<p>B+ 树的优点在于：</p>
<ul>
<li>由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。</li>
<li>B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</li>
</ul>
<p>但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。下面是B 树和B+树的区别图：</p>
<p><img src="Picture/B树01.png" alt="B树01"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对B树和B+树的分析和对前面讲解的2-3树的分析类似，</p>
<p>对于一颗节点为N度为M的子树，查找和插入需要logM-1N ~ logM/2N次比较。这个很好证明，对于度为M的B树，每一个节点的子节点个数为M/2 到 M-1之间，所以树的高度在logM-1N至logM/2N之间。</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h3><p>在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tree/">Tree</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Database/SQLserver/远程登入sqlserver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/06/Database/SQLserver/远程登入sqlserver/" class="article-date">
      <time datetime="2018-12-06T06:18:58.000Z" itemprop="datePublished">2018-12-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/Database/SQLserver/远程登入sqlserver/">远程登入 SQL server</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="https://jingyan.baidu.com/article/6c67b1d6ca06f02787bb1ed1.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/6c67b1d6ca06f02787bb1ed1.html</a></p>
<ol>
<li><p>登录sqlserver manager 后，右键选择“属性”。左侧选择“安全性”，选中右侧的“SQL Server 和 Windows 身份验证模式”以启用混合登录模式</p>
</li>
<li><p>选择“连接”，勾选“允许远程连接此服务器”，然后点“确定”</p>
</li>
<li>展开“安全性”，“登录名”选择一个服务器登入名，右键选择“属性”，左侧选择“常规”，右侧选择“SQL Server 身份验证”，并设置密码</li>
<li>打开sql server配置管理器，在左则选择sql server网络配置节点下的sqlexpress的协议，在右侧的TCP/IP默认是“否”，右键启用或者双击打开设置面板将其修改为“是”。</li>
<li>重启服务器</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/SQLserver/">SQLserver</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQLserver/">SQLserver</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Database/Mysql/mysql c api" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/04/Database/Mysql/mysql c api/" class="article-date">
      <time datetime="2018-12-04T14:18:57.000Z" itemprop="datePublished">2018-12-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/Database/Mysql/mysql c api/">mysql c&amp;c++ api</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="mac-os环境"><a href="#mac-os环境" class="headerlink" title="mac os环境"></a>mac os环境</h2><h3 id="Download-Connector-C"><a href="#Download-Connector-C" class="headerlink" title="Download Connector/C++"></a>Download Connector/C++</h3><p><a href="https://dev.mysql.com/downloads/connector/cpp/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/connector/cpp/</a></p>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;mysql/mysql.h&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Compiler-Arguments"><a href="#Compiler-Arguments" class="headerlink" title="Compiler Arguments"></a>Compiler Arguments</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp  `mysql_config --libs`</span><br><span class="line"><span class="comment">/*在unix环境中反引号 `` 和 $() 都是命令替换。</span></span><br><span class="line"><span class="comment">在本机(Mac)上直接输入 mysql_config --libs 产生的结果是: </span></span><br><span class="line"><span class="comment">-L/usr/local/Cellar/mysql/5.7.21/lib -lmysqlclient -lssl -lcrypto</span></span><br><span class="line"><span class="comment">所以等于是参数直接替换为后者，两者是相同效果。</span></span><br><span class="line"><span class="comment">同理 mysql_config --cflags</span></span><br><span class="line"><span class="comment">-I/usr/local/Cellar/mysql/5.7.21/include</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>注：18.9.30更新macOS Mojave 后，编译选项报错，所以我只用了 -lmysqlclient ，把 -lssl -lcrypto 删了，然后未发生错误。</p>
<p>Clion 只需要添加两句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -I/usr/local/Cellar/mysql/5.7.21/include&quot;)</span><br><span class="line"></span><br><span class="line">add_executable(Project01 main.c)</span><br><span class="line"></span><br><span class="line">target_link_libraries(Project01 -L/usr/local/Cellar/mysql/5.7.21/lib -lmysqlclient)</span><br></pre></td></tr></table></figure>
<h3 id="Use-in-Program"><a href="#Use-in-Program" class="headerlink" title="Use in Program"></a>Use in Program</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">//连接数据库，成功返回0</span><br><span class="line">int connectMysql(MYSQL * mysql)&#123;</span><br><span class="line">    int     ret = 0;</span><br><span class="line">    MYSQL   *con = NULL;</span><br><span class="line"></span><br><span class="line">    con = mysql_init(mysql);</span><br><span class="line">    if (con == NULL) &#123;</span><br><span class="line">        ret = mysql_errno(mysql);</span><br><span class="line">        printf(&quot;func mysql_init() err :%d\n&quot;, ret);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //连接mysql服务器</span><br><span class="line">    //MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd,</span><br><span class="line">    //const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag) ;</span><br><span class="line">    con = mysql_real_connect(mysql, MYSQLHOST, MYSQLUSR, MYSQLPAS, MYSQLDB, 0, NULL, 0 );</span><br><span class="line">    if (con == NULL) &#123;</span><br><span class="line">        ret = mysql_errno(mysql);</span><br><span class="line">        printf(&quot;func mysql_real_connect() err :%d\n&quot;, ret);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">#ifdef NOTDEFMYSQL</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;func mysql_real_connect() ok\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*插入名字和密码，成功则返回0*/</span><br><span class="line">int insertNamePass(MYSQL* mysql, const char* name, const char* pass)&#123;</span><br><span class="line">    char query[51 + MAXNAME + MAXPASS] = &quot;insert into users(username,password) values(\&quot;&quot;;</span><br><span class="line">    strncat(query, name, MAXNAME);</span><br><span class="line">    strcat(query, &quot;\&quot;,\&quot;&quot;);</span><br><span class="line">    strncat(query, pass, MAXPASS);</span><br><span class="line">    strcat(query, &quot;\&quot;)&quot;);</span><br><span class="line"></span><br><span class="line">    return mysql_real_query(mysql, query, (unsigned int)strlen(query));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*如果名字存在则返回0*/</span><br><span class="line">int hasName(MYSQL* mysql, const char * name)&#123;</span><br><span class="line">    char query[38 + MAXNAME] = &quot;SELECT 1 FROM users WHERE username=\&quot;&quot;;</span><br><span class="line">    strncat(query, name, MAXNAME);</span><br><span class="line">    strcat(query, &quot;\&quot;&quot;);</span><br><span class="line"></span><br><span class="line">    if (mysql_real_query(mysql, query, (unsigned int)strlen(query) ) )</span><br><span class="line">    &#123;</span><br><span class="line">        puts(&quot;MySQL query is error!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        MYSQL_RES *result = mysql_store_result(mysql);</span><br><span class="line">        if( mysql_num_rows(result) )&#123;</span><br><span class="line">            mysql_free_result(result);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//检测用户的密码是否匹配，匹配则返回0</span><br><span class="line">int passRight(MYSQL* mysql, const char * name, const char * pass)&#123;</span><br><span class="line">    char query[45 + MAXNAME] = &quot;select password from users where username=\&quot;&quot;;</span><br><span class="line">    strncat(query, name, MAXNAME);</span><br><span class="line">    strcat(query, &quot;\&quot;&quot;);</span><br><span class="line"></span><br><span class="line">    if (mysql_real_query(mysql, query, (unsigned int)strlen(query) ) )</span><br><span class="line">    &#123;</span><br><span class="line">        puts(&quot;MySQL query is error!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        MYSQL_RES *result = mysql_store_result(mysql);</span><br><span class="line">        MYSQL_ROW row = mysql_fetch_row(result);</span><br><span class="line">        if( !strncmp(row[0], pass, MAXPASS))&#123;</span><br><span class="line">            mysql_free_result(result);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        mysql_free_result(result);</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回用户分数,2 Bytes</span><br><span class="line">short getGrade(MYSQL* mysql, const char * name)&#123;</span><br><span class="line">    char query[42 + MAXNAME] = &quot;select grade from users where username=\&quot;&quot;;</span><br><span class="line">    strncat(query, name, MAXNAME);</span><br><span class="line">    strcat(query, &quot;\&quot;&quot;);</span><br><span class="line"></span><br><span class="line">    if (mysql_real_query(mysql, query, (unsigned int)strlen(query) ) )</span><br><span class="line">    &#123;</span><br><span class="line">        puts(&quot;MySQL query is error!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        MYSQL_RES *result = mysql_store_result(mysql);</span><br><span class="line">        MYSQL_ROW row = mysql_fetch_row(result);</span><br><span class="line">        short grade = (short)strtol(row[0], NULL, 10);</span><br><span class="line">        mysql_free_result(result);</span><br><span class="line">        return grade;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Mysql/">Mysql</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mysql/">Mysql</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Database/Mysql/mac 使用 mysql" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/04/Database/Mysql/mac 使用 mysql/" class="article-date">
      <time datetime="2018-12-04T14:17:58.000Z" itemprop="datePublished">2018-12-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/Database/Mysql/mac 使用 mysql/">mac 使用 mysql</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p>1、安装：<code>sunyichaodeMacBook-Pro:~ sunyichao$ brew install mysql</code><br>2、开启mysql：<code>mysql.server start</code>(Linux下是<code>service mysql start</code>)<br>2、使用mysql的配置脚本：<code>/usr/local/opt/mysql/bin/mysql_secure_installation //mysql 提供的配置向导</code><br>启动这个脚本后，即可根据如下命令提示进行初始化设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">sunyichaodeMacBook-Pro:~ sunyichao$ /usr/local/opt/mysql/bin/mysql_secure_installation   //mysql 提供的配置向导</span><br><span class="line">Securing the MySQL server deployment.</span><br><span class="line">Connecting to MySQL using a blank password.</span><br><span class="line">VALIDATE PASSWORD PLUGIN can be used to test passwordsand improve security. It     checks the strength of password and allows the users to set only those passwords which are secure enough. Would you like to setup VALIDATE PASSWORD plugin?</span><br><span class="line"></span><br><span class="line">Press y|Y for Yes, any other key for No: k //是否采用mysql密码安全检测插件（这里作为演示选择否，密码检查插件要求密码复杂程度高，大小写字母+数字+字符等）</span><br><span class="line">Please set the password for root here. // 首次使用自带配置脚本，设置root密码</span><br><span class="line"></span><br><span class="line">New password:</span><br><span class="line"></span><br><span class="line">Re-enter new password:</span><br><span class="line"></span><br><span class="line">By default, a MySQL installation has an anonymous user, allowing anyone to log into MySQL without having to have a user account created for This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment.    </span><br><span class="line">Remove anonymous users? [Y/n] Y //是否删除匿名用户</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">Normally, root should only be allowed to connect from &apos;localhost&apos;.This</span><br><span class="line">ensures that someone cannot guess at the root password from the network.</span><br><span class="line"></span><br><span class="line">Disallow root login remotely? [Y/n] Y //是否禁止远程登录</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">By default, MySQL comes with a database named &apos;test&apos; that anyone can</span><br><span class="line">access.This is also intended only for testing, and should be removed</span><br><span class="line">before moving into a production environment.</span><br><span class="line"></span><br><span class="line">Remove test database and access to it? [Y/n] Y //删除测试数据库，并登录</span><br><span class="line"> Dropping test database...</span><br><span class="line"> ... Success!</span><br><span class="line"> Removing privileges on test database...</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">Reloading the privilege tables will ensure that all changes made so far</span><br><span class="line">will take effect immediately.</span><br><span class="line"></span><br><span class="line">Reload privilege tables now? [Y/n] Y//重新载入权限表</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">All done!  If you&apos;ve completed all of the above steps, your MySQL</span><br><span class="line">installation should now be secure.</span><br><span class="line"></span><br><span class="line">Thanks for using MySQL!</span><br><span class="line"></span><br><span class="line">Cleaning up...</span><br><span class="line">sunyichaodeMacBook-Pro:~ sunyichao$</span><br></pre></td></tr></table></figure>
<p>//以上内容来自<a href="https://segmentfault.com/q/1010000000475470里的回答" target="_blank" rel="noopener">https://segmentfault.com/q/1010000000475470里的回答</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Mysql/">Mysql</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mysql/">Mysql</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C_C++/Mess/C++显式实例化的用途" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/04/C_C++/Mess/C++显式实例化的用途/" class="article-date">
      <time datetime="2018-12-04T14:15:28.000Z" itemprop="datePublished">2018-12-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/C_C++/Mess/C++显式实例化的用途/">C++显式实例化的用途</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>摘自<a href="https://stackoverflow.com/questions/2351148/explicit-instantiation-when-is-it-used" target="_blank" rel="noopener">https://stackoverflow.com/questions/2351148/explicit-instantiation-when-is-it-used</a></p>
<p>学习时遇到了这个问题，百度了一圈，对看到的帖子很失望，基本都在不懂装懂。所以谷歌了一下找到答案，翻译成中文：</p>
<p>显式实例化让你能够先创建模版的某个实例，而不是在使用它的时候再隐式创建。主要的用途就是用来写库文件，因为没有实例化的模版不能放入对象(.obj)文件中。在库文件里使用了显式实例化后，模版的实例化代码就不需要在每个使用到的对象里拷贝一份了（隐式实例化），编译器只需要链接到相应的库函数。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C_C++/Mess/C++ofstream输出为1的情况" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/04/C_C++/Mess/C++ofstream输出为1的情况/" class="article-date">
      <time datetime="2018-12-04T14:15:08.000Z" itemprop="datePublished">2018-12-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/C_C++/Mess/C++ofstream输出为1的情况/">fstream输出为1的情况</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在学C++文件操作时，我曾尝试直接将一个文件输入流接到文件输出流。</p>
<p>如<code>fout &lt;&lt; fin;</code> 然而运行后输出的文件内容之有一个’1’。</p>
<p>我接着又尝试<code>fout &lt;&lt; fin &lt;&lt; fin &lt;&lt; fin;</code>结果输出文件内容是’111’。</p>
<p>查阅文档发现原因：</p>
<p>ofstream类的&lt;&lt;运算符没有重载fstream类参数，这种情况下（以及其他没有重载的指针类型），会隐式转化成bool类型，然后只要指针不是空的，就会输出’1’（当然，如果使用了std::boolalpha控制符，则会输出’true’）。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Backend/Dreamweaver服务器配置" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/04/Backend/Dreamweaver服务器配置/" class="article-date">
      <time datetime="2018-12-04T14:13:08.000Z" itemprop="datePublished">2018-12-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/Backend/Dreamweaver服务器配置/">Dreamweaver 连接到 Linux 云服务器 php</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ol>
<li>首先要开启Linux的lamp服务（Linux、Apache、mysql、php），下载httpd、mysql、php。打开httpd服务和vsftpd服务。</li>
<li>在DW站点设置里面添加服务器，协议选择SFTP，用户名和密码为Linux的用户名和密码。选择为testing server。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Backend/">Backend</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dreamweaver/">Dreamweaver</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Macos/Mac杂项记录" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/04/Macos/Mac杂项记录/" class="article-date">
      <time datetime="2018-12-04T14:12:29.000Z" itemprop="datePublished">2018-12-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/Macos/Mac杂项记录/">Mac杂项</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="硬件失灵"><a href="#硬件失灵" class="headerlink" title="硬件失灵"></a>硬件失灵</h3><p>有时候键盘某个按键会失灵、扬声器没声音、touch bar 没反应、App Store 有问题，感觉是bug，重启电脑就行了。</p>
<h3 id="终端直接进入桌面"><a href="#终端直接进入桌面" class="headerlink" title="终端直接进入桌面"></a>终端直接进入桌面</h3><p>因为我一般将临时文件放在桌面，这样便于操作，但是终端开启时默认目录是用户家目录，经常需要<code>cd Desktop/</code>比较麻烦，所以设置成开启终端自动执行<code>cd Desktop/</code>：偏好设置-&gt;描述文件-&gt;Shell-&gt;启动命令。</p>
<h3 id="Sublime"><a href="#Sublime" class="headerlink" title="Sublime"></a>Sublime</h3><p>File - &gt; Reopen with Encoding  可以用不同编码方式打开文件，经常以此查看文件的十六进制编码。</p>
<p>(需要安装)</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Macos/">Macos</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Macos/">Macos</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Macos/mac软件推荐" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/04/Macos/mac软件推荐/" class="article-date">
      <time datetime="2018-12-04T14:11:36.000Z" itemprop="datePublished">2018-12-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/Macos/mac软件推荐/">mac软件推荐</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><h4 id="LyricsX"><a href="#LyricsX" class="headerlink" title="LyricsX"></a>LyricsX</h4><p>可以显示iTunes的歌词，而且桌面歌词很人性化。</p>
<h4 id="Capo"><a href="#Capo" class="headerlink" title="Capo"></a>Capo</h4><p>可以查看歌曲的调式、所有和弦，可以转调，可以变速。非常有趣又实用的音乐软件。</p>
<h3 id="词典"><a href="#词典" class="headerlink" title="词典"></a>词典</h3><h4 id="欧路词典"><a href="#欧路词典" class="headerlink" title="欧路词典"></a>欧路词典</h4><p>支持touchbar，而且支持多标签页。付费软件。</p>
<h4 id="有道词典"><a href="#有道词典" class="headerlink" title="有道词典"></a>有道词典</h4><p>相比欧路词典逊色，但是免费。</p>
<h3 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h3><h4 id="wallcat"><a href="#wallcat" class="headerlink" title="wallcat"></a>wallcat</h4><p>在其他壁纸软件用腻了之后，最终就使用这个软件了，十分推荐。</p>
<p>每天自动更新四种风格的壁纸各一张。当天可以任意切换且仅能切换这四张壁纸。</p>
<p>显示桌面（系统自带的操作）后，使用mac自带的截图（截取选定部分）可以截取壁纸（无桌面文件图标）。</p>
<p>就可以将好看的壁纸收集到一个文件夹内，然后设置屏幕保护程序里的文件夹为这个文件夹，就可以在屏保的时候看到这些精美图片啦。</p>
<h4 id="Artpaper"><a href="#Artpaper" class="headerlink" title="Artpaper"></a>Artpaper</h4><p>复古油画文艺风格壁纸</p>
<h4 id="Wallpaper-Wizard"><a href="#Wallpaper-Wizard" class="headerlink" title="Wallpaper Wizard"></a>Wallpaper Wizard</h4><p>可以从壁纸库选择各种分类的壁纸</p>
<h4 id="iWall"><a href="#iWall" class="headerlink" title="iWall"></a>iWall</h4><p>动态桌面，可以在桌面播放指定视频。</p>
<h3 id="播放器"><a href="#播放器" class="headerlink" title="播放器"></a>播放器</h3><h4 id="Movist"><a href="#Movist" class="headerlink" title="Movist"></a>Movist</h4><p>太优秀了，所以本人只用这一个播放器。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Macos/">Macos</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Macos/">Macos</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2019 Skuaka
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 1;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>