<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="Skuaka">


    
    


<meta name="description" content="For you, a thousand times over.">
<meta name="keywords" content="skuaka">
<meta property="og:type" content="website">
<meta property="og:title" content="Skuaka">
<meta property="og:url" content="http://skuaka.cn/page/7/index.html">
<meta property="og:site_name" content="Skuaka">
<meta property="og:description" content="For you, a thousand times over.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Skuaka">
<meta name="twitter:description" content="For you, a thousand times over.">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Skuaka" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/avatar.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Skuaka</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Skuaka</a></h1>
        </hgroup>

        
        <p class="header-subtitle">For you, a thousand times over.</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">Home</a></li>
                        
                            <li><a href="/archives/">Archives</a></li>
                        
                            <li><a href="/tags/">Tags</a></li>
                        
                            <li><a href="/about/">about</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCIE/">CCIE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DDos/">DDos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DTD/">DTD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DoNotStarve/">DoNotStarve</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dreamweaver/">Dreamweaver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kali/">Kali</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Macos/">Macos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MetaProgram/">MetaProgram</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mp3/">Mp3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenGL/">OpenGL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Perl/">Perl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QT/">QT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Raspberrypi/">Raspberrypi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLserver/">SQLserver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Socks5/">Socks5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wifi/">Wifi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wireshark/">Wireshark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/base64/">base64</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/clion/">clion</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcc-gdb/">gcc,gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unp/">unp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vultr/">vultr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a></li></ul>
                    </div>
                </section>
                
                
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Skuaka</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Skuaka</a></h1>
            </hgroup>
            
            <p class="header-subtitle">For you, a thousand times over.</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">Home</a></li>
                
                    <li><a href="/archives/">Archives</a></li>
                
                    <li><a href="/tags/">Tags</a></li>
                
                    <li><a href="/about/">about</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" target="_blank" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me">
</nav>
      <div class="body-wrap">
  
    <article id="post-Operating System/操作系统期末背诵点" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/01/10/Operating System/操作系统期末背诵点/" class="article-date">
      <time datetime="2019-01-10T03:37:02.000Z" itemprop="datePublished">2019-01-10</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/10/Operating System/操作系统期末背诵点/">操作系统期末背诵点</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="操作系统期末背诵点"><a href="#操作系统期末背诵点" class="headerlink" title="操作系统期末背诵点"></a>操作系统期末背诵点</h1><h3 id="大知识点"><a href="#大知识点" class="headerlink" title="大知识点"></a>大知识点</h3><p>PV操作中的生产者/消费者，读/写者 P50</p>
<p>银行家算法 P73</p>
<p>可变分区 P92</p>
<p>地址转换 P95-97</p>
<p>页面置换 P107</p>
<p>移臂调度 P133</p>
<p>作业调度 补充内容</p>
<h3 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h3><ol>
<li><p>操作系统的主要特性</p>
<p>并发性，共享性，异步性，虚拟性。</p>
</li>
<li><p>存储管理</p>
<ul>
<li><p>内存分配和回收</p>
</li>
<li><p>内存保护：确保每道程序在自己的内存空间中运行，彼此不干扰。</p>
</li>
<li>地址映射：把用逻辑地址编程的应用程序装入主存，并通过硬件将逻辑地址转化为物理地址。</li>
<li>内存共享：让主存中的多个应用程序实现存储共享，提高资源利用率。</li>
<li>内存扩充：不是扩大物理内存，是借助虚拟存储技术从逻辑上扩充内存。</li>
</ul>
</li>
<li><p>操作接口</p>
<p>操作接口又称为作业级接口</p>
<p>实现方式：操作控制命令、图形操作界面、作业控制语言</p>
</li>
<li><p>操作系统的结构</p>
<ul>
<li><p>整体式结构：按功能分成模块，每个模块有独立功能。</p>
</li>
<li><p>层次式结构：模块化，操作系统划分成若干层次，上层基于下层实现。</p>
</li>
<li><p>C/S结构：</p>
</li>
<li>虚拟机结构：可运行不同操作系统。</li>
</ul>
</li>
<li><p>多道程序设计</p>
<p>优点：充分发挥计算机硬件的并发性，消除了处理器和外围设备的互相等待现象，增加单位时间内执行的作业数，提高系统效率。</p>
<p>缺点：对于某一个作业而言，执行时间可能会变长。</p>
<ul>
<li><p>题目1</p>
<p>一道作业计算11分钟，另一道计算3分钟，再打印6分钟；</p>
<p>在单道程序设计中：11+3+6</p>
<p>在多道程序设计中：3+11</p>
</li>
<li><p>题目2</p>
<p>1MB主存，操作系统200KB，每个用户进程200KB，用户进程等待I/O的时间为70%</p>
<p>若增加1MB主存，CPU利用率提高多少？</p>
<p>（800KB可以容下4个用户进程，4个都等待时CPU才空闲）1-0.7^4=0.76</p>
<p>（增加1M后，容下9个用户进程）1-0.7^9=0.96</p>
<p>利用率提高了 (0.96 - 0.76)/0.76 = 26%</p>
</li>
</ul>
</li>
<li><p>进程的结构性（进程控制块 PCB）</p>
<p>进程控制块：记录和描述进程的动态运行情况</p>
<p>进程是由 程序代码段、数据块、进程控制块 三部分组成的。（进程三要素：代码块、数据块、堆栈）</p>
</li>
<li><p>进程的状态转换</p>
<p>运行态–时间片到-&gt;就绪态–调度-&gt;运行态</p>
<p>运行态–发生等待事件-&gt;等待态–等待事件结束-&gt;就绪态</p>
</li>
<li><p>特权指令</p>
<p>只能在核心态下运行的指令称为特权指令，其他为非特权指令。</p>
</li>
<li><p>系统操作和原语</p>
<p>原语是在操作系统内核实现的，系统操作是由系统进程或系统服务器实现的。</p>
<p>原语在运行中不允许被中断（原子性）。</p>
<p>原语执行是顺序的，不可能并发执行。</p>
</li>
<li><p>多级反馈队列调度算法（了解）</p>
<p>将就绪进程分成多个就绪队列，各队列有不同的优先级，同一个队列优先级相同，进程时间片越短优先级越高，调用时采用先来先服务，对每一个就绪队列来说，是时间片轮转法。</p>
<p>只有高一级就绪列队为空，才调度下一级就绪队列。</p>
<p>如果新进程的优先级比当前正在cpu上运行的进程高，则系统会抢占CPU上的进程，将它放回到调度前所在的队列的队尾，然后进行新一次的处理器调度。</p>
</li>
<li><p>PV操作和信号量</p>
<p>PV操作都是原语操作（如上）</p>
<p>信号量（Semaphore）代表该类资源可用的个数（若为负数表明还欠进程若干资源）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(Semaphore s)</span></span>&#123;</span><br><span class="line">    --s;</span><br><span class="line">    <span class="keyword">if</span>(s&lt;<span class="number">0</span>)</span><br><span class="line">        wait(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(Semaphore s)</span></span>&#123;</span><br><span class="line">    ++s;</span><br><span class="line">    <span class="keyword">if</span>(s&lt;=<span class="number">0</span>)</span><br><span class="line">        Revoke(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果s&lt;=0,表明原先s最多是-1(即最少有一个进程在等待,具体为abs(s)个),所以需要唤醒在s上等待的进程</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>管程的特点</p>
<ul>
<li>互斥性：任何时刻只能最多有一个进程进入管程活动，其他想进♂入的必须等待。</li>
<li>安全性：管程中的局部变量只能由该管程的方法或函数访问</li>
<li>共享性：特定方法和函数能被其他管程或进程访问</li>
</ul>
</li>
<li><p>进程通信的方式</p>
<ul>
<li><p>管道文件通信：一个文件从管道写数据，另一个读</p>
</li>
<li><p>共享内存：在内存区域开辟一个共享存储区</p>
</li>
<li><p>消息传递</p>
<p>一种方式：直接消息传递方式。<code>Send(Target,Message);Receive(Source,&amp;Message);</code></p>
<p>这种方式无缓冲，先发或先接收都要等待另一方。</p>
</li>
<li><p>信号</p>
</li>
</ul>
</li>
<li><p>地址重定位</p>
<p>静态重定位：简单易实现，运行速度快；程序在内存中的空间必须连续、受限制，不可移动，不利于程序共享<br>动态重定位：需要硬件支持，运行速度慢；~~~可以不连续、可以移动，利于程序共享。</p>
</li>
<li><p>分段存储管理</p>
<p>（理解）分页存储管理的地址转换过程中，逻辑地址可以看成页号与页内偏移两部分组成，但实际上分页方式下的地址空间仍是一维连续的地址空间。</p>
<p>而分段存储管理中，被划分为若干段，各段之间可以是不连续的、相互独立的。</p>
</li>
<li><p>I/O控制方式（类似微机原理）</p>
<p>程序查询方式、中断方式、DMA方式、<strong>通道方式</strong></p>
<p>周期窃取：DMA控制器获得总线控制权，cpu处理效率下降。</p>
<ul>
<li><p>通道命令字 channel command word，CCW</p>
</li>
<li><p>通道地址字 CAW</p>
</li>
<li><p>通道状态字 CSW</p>
</li>
</ul>
<p>根据信息交换的方式不同，<strong>通道可以分为</strong>：</p>
<ul>
<li>字节多路通道：传送单位为字节，交叉方式（分时），允许多个设备同时操作、同时传输。</li>
<li>数组选择通道：一次传输一批数据，传输效率高，一次只能执行一个通道程序。</li>
<li>数组多路通道：是一种对通道程序在硬件级别上的多道程序设计的实现。兼有字节多路通道的分时以及数组选择通道的传输效率高特点。</li>
</ul>
</li>
<li><p>I/O缓冲技术</p>
<ul>
<li>单缓冲技术：在CPU和IO设备间建立一个缓冲区</li>
<li>双缓冲技术：建立两个缓冲区</li>
<li>多缓冲技术：<strong>循环队列</strong>的方式使用多个缓冲区</li>
<li>缓冲池技术：将多个专用缓冲区进行统一管理，动态分配，成为公用缓冲区</li>
</ul>
</li>
<li><p>外围的设备分配回收 P128</p>
<p>设备绝对号，设备相对号；设备类表，设备分配表。</p>
</li>
<li><p>磁盘例题 P132</p>
</li>
<li><p>spooling技术</p>
<p>作业的输入被送到输入井中保存，当作业调度时，直接从输入井中挑选作业。</p>
<p>作业运行产生的结果暂存在硬盘中的输出井中（即可算作作业成功），由“缓输出程序”统一管理。</p>
<p>这时CPU和外设真正并行工作，称为spooling操作。</p>
<p>Spooling系统由三部分组成：</p>
<ul>
<li><p>输入井 和 输出井</p>
<p>输入井的作业有四种状态：</p>
<p>输入状态、后备状态（等待调度）、执行状态、完成状态。</p>
</li>
<li><p>预输入进程 和 缓输出进程：管理外设和井</p>
</li>
<li><p>井管理进程：管理CPU和井</p>
</li>
</ul>
</li>
<li><p>文件的逻辑结构</p>
<ul>
<li>无结构的字符流式文件</li>
<li>有结构的记录式文件</li>
</ul>
</li>
<li><p>文件的物理结构</p>
<ul>
<li><p>顺序结构文件：把逻辑文件的信息顺序地存储到连续的物理盘块中</p>
</li>
<li><p>链接结构文件：（单向链表）每个物理块中设置一个指针，指向该文件的下一个物理块号。</p>
</li>
<li><p>索引结构文件：为每个文件建立索引表，每个表目支出文件逻辑记录所在的物理块号。</p>
<p>例题：</p>
<p>设文件索引表的每个表目占4字节，存放一个盘块的块号，磁盘块大小为512B。</p>
<p>问该文件采用直接、二级、三级索引所能管理的最大存储空间为多少字节？</p>
<p>首先计算索引表项目大小：512/4 = 128 个</p>
<p>直接索引 128*512</p>
<p>二级索引 128^2*512</p>
<p>三级索引 128^3*512</p>
</li>
</ul>
</li>
<li><p>空闲空间管理方法</p>
<ul>
<li><p>空闲文件目录：将文件存储设备上的每个连续空白区看成一个空白文件，为所有空白文件建立一个目录。</p>
</li>
<li><p>空闲块表：将所有空闲区链接在一起，形成链表</p>
</li>
<li><p>位示图：又称字位映像表。用若干字节构成一张表，每一个位按顺序对应一个物理块，1表示占用，0表示空闲。</p>
</li>
</ul>
</li>
<li><p>文件存取控制（简答题）P156</p>
<p>什么是文件存储控制矩阵，有什么优缺点？</p>
<p>采用二维矩阵的思想，一维表示所有用户，另一维表示所有文件。</p>
<p>二维矩阵中的一个元素的内容表示该用户对该文件的存取控制权限。</p>
<p>当一个用户向文件系统提出存取请求时，由文件系统中的一个存取控制验证模块将本次存取请求与存取控制矩阵中相应元素提供的存取权限进行比较，匹配则执行，否则就拒绝。</p>
<p>优点：实现简单。</p>
<p>缺点：往往矩阵容量过大，影响系统执行效率。</p>
<p>改进方法是存取控制表。如linux中的文件属主、同用户组、一般用户。</p>
</li>
<li><p>文件完整性</p>
<p>通常采用文件复制的方法来保证文件完整性（备份）</p>
<p>全量转储，也称为周期性转储。</p>
<p>增量转储：只存储上次转储后改变的信息，缩短转储时间。</p>
</li>
<li><p>硬件抽象层（填空题）</p>
<p>Hardware Abstraction Layer，HAL：将内核、设备驱动程序以及执行体同硬件分隔开来，使他们可以适应多种平台。</p>
</li>
<li><p>CreateProcess函数</p>
<p>创建进程</p>
<p>ExitProcess函数</p>
<p>结束当前应用程序的执行，并且设置退出码，但不会调用析构函数，c/c++应该避免使用。</p>
</li>
<li><p>后台命令：命令后面加上 &amp;</p>
</li>
<li><p>管道线 操作符<code>|</code>把一个命令的标准输出连接到另一个命令的标准输入上。</p>
</li>
<li><p>gcc编译命令</p>
<p><code>gcc -o hello hello.c</code></p>
<p>gdb是c/c++调试器</p>
</li>
</ol>
<h1 id="我在复习，，，"><a href="#我在复习，，，" class="headerlink" title="我在复习，，，"></a>我在复习，，，</h1>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-QT/QT入门" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/01/05/QT/QT入门/" class="article-date">
      <time datetime="2019-01-05T05:11:18.000Z" itemprop="datePublished">2019-01-05</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/05/QT/QT入门/">QT 入门</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Qt5-入门"><a href="#Qt5-入门" class="headerlink" title="Qt5 入门"></a>Qt5 入门</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="QT与OpenGL"><a href="#QT与OpenGL" class="headerlink" title="QT与OpenGL"></a>QT与OpenGL</h3><p>Qt 5.2.0 for Windows 32-bit (MinGW 4.8, OpenGL, 689 MB)<br>Qt 5.2.0 for Windows 32-bit (VS 2010, 570 MB) 、<br>Qt 5.2.0 for Windows 32-bit (VS 2010, OpenGL, 569 MB)、<br>Qt 5.2.0 for Windows 32-bit (VS 2012, 579 MB)</p>
<p>这四个首先是编译器的区别：第一个是MinGW；第二、三个是VS2010；第四个是VS2012。<strong>标记有OpenGL的含义是使用OpenGL后端；否则的话使用ANGLE后端。</strong>ANGLE是Google发起的一个开源项目，旨在将OpenGL ES 2.0 API映射到DirectX 9 API。如果你的应用程序使用了不包含在OpenGL ES中的OpenGL API；或者<strong>需要运行在Windows XP平台，那么需要选择OpenGL版本（意思是说OpenGL版本是全版本，自带所有API）</strong></p>
<h3 id="元对象"><a href="#元对象" class="headerlink" title="元对象"></a>元对象</h3><p>元对象（meta object）意思是<strong>描述另一个对象结构的对象</strong>，比如获得一个对象有多少成员函数，有哪些属性。在Qt中，我们将要用到的是QMetaObject这个类。</p>
<p>元对象系统基于以下3点：</p>
<ul>
<li>以QObject作为基类</li>
<li>类声明的私有区域中，Q_Object宏指令使我们能够使用元对象的特性，比如动态属性、信号、槽等</li>
<li>元对象编译器（<strong>Meta-Object Compiler</strong>  moc）为QObject子类生成具有元对象特性的代码</li>
</ul>
<p>我们可以通过QObject类的一个成员函数获得该类的元对象：</p>
<p><code>QMetaObject *QObject::metaObject() const</code>通过这个元对象，进而可以获取一个QObject对象的更多信息：</p>
<p><code>QMetaObject::className()</code> 返回运行时类的名称（不需要C++中的运行时类型识别机制RTTI）</p>
<p><code>QMetaObject::methodCount()</code> 返回类中方法的个数</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QLabel <span class="title">label</span><span class="params">(<span class="string">"Hello, world"</span>)</span></span>;</span><br><span class="line">    label.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意！！！</strong> </p>
<p>不能使用new创建Qlabel，<code>QLabel *label = new QLabel(&quot;Hello, world&quot;);</code></p>
<p>label 是建立在堆上的，app 是建立在栈上的。这意味着，label 会在 app 之后析构。也就是说，label 的生命周期长于 app 的生命周期。<strong>这是 Qt 编程的大忌</strong>。</p>
<h3 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a>信号与槽</h3><p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// !!! Qt 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">"Quit"</span>)</span></span>;</span><br><span class="line">    QObject::connect(&amp;button, &amp;QPushButton::clicked, &amp;QApplication::quit);</span><br><span class="line">    button.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h4><p>在 <strong>Qt 5 中</strong>，QObject::connect() 有五个重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(<span class="keyword">const</span> QObject *, <span class="keyword">const</span> <span class="keyword">char</span> *,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> QObject *, <span class="keyword">const</span> <span class="keyword">char</span> *,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Qt::ConnectionType)</span></span>;</span><br><span class="line"></span><br><span class="line">QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(<span class="keyword">const</span> QObject *, <span class="keyword">const</span> QMetaMethod &amp;,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> QObject *, <span class="keyword">const</span> QMetaMethod &amp;,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Qt::ConnectionType)</span></span>;</span><br><span class="line"></span><br><span class="line">QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(<span class="keyword">const</span> QObject *, <span class="keyword">const</span> <span class="keyword">char</span> *,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span> *,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Qt::ConnectionType)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(<span class="keyword">const</span> QObject *, PointerToMemberFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> QObject *, PointerToMemberFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Qt::ConnectionType)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">QMetaObject::Connection connect(const QObject *, PointerToMemberFunction,</span><br><span class="line">                                Functor);</span><br></pre></td></tr></table></figure>
<p>最常用的一般形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect(sender, signal,</span><br><span class="line">        receiver, slot);</span><br></pre></td></tr></table></figure>
<p>connect() 一般会使用前面四个参数，第一个是发出信号的对象，第二个是发送对象发出的信号，第三个是接收信号的对象，第四个是接收对象在接收到信号之后所需要调用的函数。</p>
<p>可以套用这个形式去分析上面给出的五个重载。</p>
<ul>
<li>第一个函数将 signal 和 slot 作为字符串处理。</li>
<li>第二个函数的 signal 和 slot 都是 const QMetaMethod &amp;。我们可以将每个函数看做是 QMetaMethod 的子类。因此，这种写法可以使用 QMetaMethod 进行类型比对。</li>
<li>第三个函数缺少了 receiver。这个函数其实是将 this 指针作为 receiver。</li>
<li>第四个函数 signal 和 slot 类型则是 PointerToMemberFunction，这是指向成员函数的指针。</li>
<li>第五个，前面两个参数没有什么不同，最后一个参数是 Functor 类型。这个类型可以接受 static 函数、全局函数以及 Lambda 表达式。</li>
</ul>
<hr>
<p><strong>注意事项</strong>：</p>
<ul>
<li><p>使用函数指针能够获得<strong>编译期的类型检查</strong>。信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。如果不一致，允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。</p>
</li>
<li><p><strong>如果信号有重载</strong>，可以使用一个函数指针来指明到底是哪一个信号。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (Newspaper:: *newPaperNameDate)(<span class="keyword">const</span> QString &amp;, <span class="keyword">const</span> QDate &amp;) = &amp;Newspaper::newPaper;</span><br><span class="line">QObject::connect(&amp;newspaper, newPaperNameDate,</span><br><span class="line">                 &amp;reader,    &amp;Reader::receiveNewspaper);</span><br></pre></td></tr></table></figure>
<p>  也可以使用匿名指针：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect(&amp;newspaper,</span><br><span class="line">                 <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> (Newspaper:: *)(<span class="keyword">const</span> QString &amp;, <span class="keyword">const</span> QDate &amp;)&gt;(&amp;Newspaper::newPaper),</span><br><span class="line">                 <span class="comment">//(void (Newspaper:: *)(const QString &amp;, const QDate &amp;))&amp;Newspaper::newPaper,</span></span><br><span class="line">                 &amp;reader,</span><br><span class="line">                 &amp;Reader::receiveNewspaper);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可以使用 C 风格的强制类型转换。但此时，如果你改变了信号的类型，那么你就会有一个潜在的运行时错误。</p>
<p>而<code>static_cast&lt;&gt;</code>则是 C++ 推荐的风格，当参数类型改变时，编译器会检测到这个错误。</p>
</li>
</ul>
</li>
<li><p>这里我们只是强调了函数参数的问题。如果前面的对象都错了呢？此时，编译器会直接失败，因为 connect() 函数会去寻找 <code>sender-&gt;*signal</code>，如果这两个参数不满足，则会直接报错。</p>
</li>
<li><p>有一种情况，槽函数的参数可以比信号的多，那就是<strong>槽函数的参数带有默认值</strong>。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Newspaper</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">newPaper</span><span class="params">(<span class="keyword">const</span> QString &amp;name)</span></span>;</span><br><span class="line"><span class="comment">// Reader</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receiveNewspaper</span><span class="params">(<span class="keyword">const</span> QString &amp;name, <span class="keyword">const</span> QDate &amp;date = QDate::currentDate())</span></span>;</span><br></pre></td></tr></table></figure>
<p>  不过我们不能在函数指针中使用函数参数的默认值。这是 <strong>C++ 语言的限制</strong>：参数默认值只能使用在直接地函数调用中。当使用函数指针取其地址的时候，默认参数是不可见的！</p>
<p>  当然，此时你可以选择 Qt 4 的连接语法。如果你还是想使用 Qt 5 的新语法，目前的办法只有一个：<strong>Lambda 表达式</strong>。目前能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。于是，使用connect的第五个重载，我们的代码就变成了：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect(&amp;newspaper,</span><br><span class="line">                 <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> (Newspaper:: *)(<span class="keyword">const</span> QString &amp;)&gt;(&amp;Newspaper::newPaper),</span><br><span class="line">                 [=](<span class="keyword">const</span> QString &amp;name) &#123; <span class="comment">/* Your code here. */</span> &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="自定义信号槽-基本框架"><a href="#自定义信号槽-基本框架" class="headerlink" title="自定义信号槽(基本框架)"></a>自定义信号槽(基本框架)</h4><p>读者接收报纸信息的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!!! Qt5</span></span><br><span class="line"><span class="comment">////////// newspaper.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Newspaper(<span class="keyword">const</span> QString &amp; name) :</span><br><span class="line">        m_name(name)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">emit <span class="title">newPaper</span><span class="params">(m_name)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">newPaper</span><span class="params">(<span class="keyword">const</span> QString &amp;name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////// reader.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Reader() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receiveNewspaper</span><span class="params">(<span class="keyword">const</span> QString &amp; name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"Receives Newspaper: "</span> &lt;&lt; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"newspaper.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"reader.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Newspaper <span class="title">newspaper</span><span class="params">(<span class="string">"Newspaper A"</span>)</span></span>;</span><br><span class="line">    Reader reader;</span><br><span class="line">    QObject::connect(&amp;newspaper, &amp;Newspaper::newPaper,</span><br><span class="line">                     &amp;reader,    &amp;Reader::receiveNewspaper);</span><br><span class="line">    newspaper.send();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong></p>
<ul>
<li>为了使用信号槽，必须继承 QObject。</li>
<li><p>凡是 QObject 类（不管是直接子类还是间接子类），都应该在第一行代码写上 Q_OBJECT。</p>
<ul>
<li>不管是不是使用信号槽，<strong>都应该添加这个宏</strong>。这个宏的展开将为我们的类提供信号槽机制、国际化机制以及 Qt 提供的不基于 C++ RTTI 的反射能力。除了信号槽，其它很多操作都会依赖于这个宏。</li>
<li>这个宏将由 moc 做特殊处理，不仅仅是宏展开这么简单。moc 会读取标记了 Q_OBJECT 的<strong>头文件</strong>，生成以 moc_ 为前缀的文件，比如 newspaper.h 将生成 moc_newspaper.cpp。可以到构建目录查看这个文件，看看到底增加了什么内容。</li>
<li>注意，由于 moc 只处理头文件中的标记了 Q_OBJECT 的类声明，不会处理 cpp 文件中的类似声明。因此，如果我们的 Newspaper 和 Reader 类位于 main.cpp 中，是无法得到 moc 的处理的。解决方法是，我们手动调用 moc 工具处理 main.cpp，并且将 main.cpp 中的 include “newspaper.h” 改为 include “moc_newspaper.h” 就可以了。不过，这是相当繁琐的步骤。</li>
</ul>
</li>
<li>signals 块所列出的，就是该类的信号。信号就是函数名，返回值是 void，参数是该类需要让外界知道的数据。（moc 会自动帮我们实现信号函数所需要的函数体）</li>
<li><p>emit 是 Qt 对 C++ 的扩展，是一个关键字（宏）。emit 用来发出信号。</p>
</li>
<li><p>槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响；</p>
</li>
</ul>
<h3 id="Qt模块"><a href="#Qt模块" class="headerlink" title="Qt模块"></a>Qt模块</h3><p>Qt 5 模块分为 Essentials Modules 和 Add-on Modules 两部分。前者是基础模块，在所有平台上都可用；后者是扩展模块，建立在基础模块的基础之上，在能够运行 Qt 的平台之上可以酌情引入。</p>
<p><strong>Qt 基础模块</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- Qt Core，提供核心的非 GUI 功能，所有模块都需要这个模块。这个模块的类包括了动画框架、定时器、各个容器类、时间日期类、事件、IO、JSON、插件机制、智能指针、图形（矩形、路径等）、线程、XML 等。所有这些类都可以通过 &lt;QtCore&gt; 头文件引入。</span><br><span class="line"></span><br><span class="line">- Qt Gui，提供 GUI 程序的基本功能，包括与窗口系统的集成、事件处理、OpenGL 和 OpenGL ES 集成、<span class="number">2</span>D 图像、字体、拖放等。这些类一般由 Qt 用户界面类内部使用，当然也可以用于访问底层的 OpenGL ES 图像 API。Qt Gui 模块提供的是所有图形用户界面程序都需要的通用功能。</span><br><span class="line"></span><br><span class="line">- Qt Multimedia，提供视频、音频、收音机以及摄像头等功能。这些类可以通过 &lt;QtMultimedia&gt; 引入，而且需要在 pro 文件中添加 QT += multimedia。</span><br><span class="line"></span><br><span class="line">- Qt Network，提供跨平台的网络功能。这些类可以通过 &lt;QtNetwork&gt; 引入，而且需要在 pro 文件中添加 QT += network。</span><br><span class="line"></span><br><span class="line">- Qt Qml，提供供 QML（一种脚本语言，也提供 JavaScript 的交互机制） 使用的 C++ API。这些类可以通过 &lt;QtQml&gt; 引入，而且需要在 pro 文件中添加 QT += qml。</span><br><span class="line"></span><br><span class="line">- Qt Quick，允许在 Qt/C++ 程序中嵌入 Qt Quick（一种基于 Qt 的高度动画的用户界面，适合于移动平台开发）。这些类可以通过 &lt;QtQuick&gt; 引入，而且需要在 pro 文件中添加 QT += quick。</span><br><span class="line"></span><br><span class="line">- Qt SQL，允许使用 SQL 访问数据库。这些类可以通过 &lt;QtSql&gt; 引入，而且需要在 pro 文件中添加 QT += sql。</span><br><span class="line"></span><br><span class="line">- Qt Test，提供 Qt 程序的单元测试功能。这些类可以通过 &lt;QtTest&gt; 引入，而且需要在 pro 文件中添加 QT += testlib。</span><br><span class="line"></span><br><span class="line">- Qt Webkit，基于 WebKit2 的实现以及一套全新的 QML API（顺便说一下，Qt <span class="number">4.8</span> 附带的是 QtWebkit <span class="number">2.2</span>）。</span><br></pre></td></tr></table></figure>
<p><strong>Qt 扩展模块</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Qt 3D，提供声明式语法，在 Qt 程序中可以简单地嵌入 3D 图像。Qt 3D 为 Qt Quick 添加了 3D 内容渲染。Qt 3D 提供了 QML 和 C++ 两套 API，用于开发 3D 程序。</span><br><span class="line">Qt Bluetooth，提供用于访问蓝牙无线设备的 C++ 和 QML API。</span><br><span class="line">Qt Contacts，用于访问地址簿或者联系人数据库的 C++ 和 QML API。</span><br><span class="line">Qt Concurrent，封装了底层线程技术的类库，方便开发多线程程序。</span><br><span class="line">Qt D-Bus，这是一个仅供 Unix 平台使用的类库，用于利用 D-Bus 协议进行进程间交互。</span><br><span class="line">Qt Graphical Effects，提供一系列用于实现图像特效的类，比如模糊、锐化等。</span><br><span class="line">Qt Image Formats，支持图片格式的一系列插件，包括 TIFF、MNG、TGA 和 WBMP。</span><br><span class="line">Qt JS Backend，该模块没有公开的 API，是 V8 JavaScript 引擎的一个移植。这个模块仅供 QtQml 模块内部使用。</span><br><span class="line">Qt Location，提供定位机制、地图和导航技术、位置搜索等功能的 QML 和 C++ API。</span><br><span class="line">Qt OpenGL，方便在 Qt 应用程序中使用 OpenGL。该模块仅仅为了程序从 Qt 4 移植到 Qt 5 的方便才保留下来，如果你需要在新的 Qt 5 程序中使用 OpenGL 相关技术，需要使用的是 QtGui 模块中的 QOpenGL。</span><br><span class="line">Qt Organizer，使用 QML 和 C++ API 访问组织事件（organizer event）。organizer API 是 Personal Information Management API 的一部分，用于访问 Calendar 信息。通过 Organizer API 可以实现：从日历数据库访问日历时间、导入 iCalendar 事件或者将自己的事件导出到 iCalendar。</span><br><span class="line">Qt Print Support，提供对打印功能的支持。</span><br><span class="line">Qt Publish and Subscribe，为应用程序提供对项目值的读取、导航、订阅等的功能。</span><br><span class="line">Qt Quick 1，从 Qt 4 移植过来的 QtDeclarative 模块，用于提供与 Qt 4 的兼容。如果你需要开发新的程序，需要使用 QtQuick 模块。</span><br><span class="line">Qt Script，提供脚本化机制。这也是为提供与 Qt 4 的兼容性，如果要使用脚本化支持，请使用 QtQml 模块的 QJS* 类。</span><br><span class="line">Qt Script Tools，为使用了 Qt Script 模块的应用程序提供的额外的组件。</span><br><span class="line">Qt Sensors，提供访问各类传感器的 QML 和 C++ 接口。</span><br><span class="line">Qt Service Framework，提供客户端发现其他设备的服务。Qt Service Framework 为在不同平台上发现、实现和访问服务定义了一套统一的机制。</span><br><span class="line">Qt SVG，提供渲染和创建 SVG 文件的功能。</span><br><span class="line">Qt System Info，提供一套 API，用于发现系统相关的信息，比如电池使用量、锁屏、硬件特性等。</span><br><span class="line">Qt Tools，提供了 Qt 开发的方便工具，包括 Qt CLucene、Qt Designer、Qt Help 以及 Qt UI Tools 。</span><br><span class="line">Qt Versit，提供了对 Versit API 的支持。Versit API 是 Personal Information Management API 的一部分，用于 QContacts 和 vCard 以及 QOrganizerItems 和 iCalendar 之间的相互转换。</span><br><span class="line">Qt Wayland，仅用于 Linux 平台，用于替代 QWS，包括 Qt Compositor API（server）和 Wayland 平台插件（clients）。</span><br><span class="line">Qt WebKit，从 Qt 4 移植来的基于 WebKit1 和 QWidget 的 API。</span><br><span class="line">Qt Widgets，使用 C++ 扩展的 Qt Gui 模块，提供了一些界面组件，比如按钮、单选框等。</span><br><span class="line">Qt XML，SAX 和 DOM 的 C++ 实现。该模块已经废除，请使用 QXmlStreamReader/Writer。</span><br><span class="line">Qt XML Patterns，提供对 XPath、XQuery、XSLT 和 XML Schema 验证的支持。</span><br></pre></td></tr></table></figure>
<h3 id="QMainWindow"><a href="#QMainWindow" class="headerlink" title="QMainWindow"></a>QMainWindow</h3><p>QMainWindow 是 Qt 框架带来的一个预定义好的主窗口类。经典的主窗口，通常是由一个标题栏，一个菜单栏，若干工具栏和一个任务栏。在这些子组件之间则是我们的工作区。QMainWindow 正是这样的一种布局。</p>
<p>通常我们的程序主窗口会继承自 QMainWindow，以便获得 QMainWindow 提供的各种便利的函数。这也是 Qt Creator 生成的代码所做的。</p>
<h3 id="Pro文件"><a href="#Pro文件" class="headerlink" title="Pro文件"></a>Pro文件</h3><p>TARGET 是生成的程序的名字。</p>
<p>TEMPLATE 是生成 makefile 所使用的模板，比如 app 就是编译成一个可执行程序，而 lib 则是编译成一个链接库（默认是动态链接库）。</p>
<h3 id="QAction"><a href="#QAction" class="headerlink" title="QAction"></a>QAction</h3><p>Qt 使用 QAction 类作为动作。这个类就是代表了窗口的一个“动作”。</p>
<p>无论是出现在菜单栏还是工具栏，用户选择之后，所执行的动作应该都是一样的。因此，Qt 并没有专门的菜单项类，只是使用一个 QAction 类，抽象出公共的动作。当我们把 QAction 对象添加到菜单，就显示成一个菜单项，添加到工具栏，就显示成一个工具按钮。用户可以通过点击菜单项、点击工具栏按钮、点击快捷键来激活这个动作。</p>
<p>QAction 包含了图标、菜单文字、快捷键、状态栏文字、浮动帮助等信息。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// !!! Qt 5</span></span><br><span class="line"><span class="comment">// ========== mainwindow.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MainWindow(QWidget *parent = <span class="number">0</span>);</span><br><span class="line">    ~MainWindow();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    QAction *openAction;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== mainwindow.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QAction&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMenuBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QStatusBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QToolBar&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">    QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    setWindowTitle(tr(<span class="string">"Main Window"</span>));</span><br><span class="line"></span><br><span class="line">    openAction = <span class="keyword">new</span> QAction(QIcon(<span class="string">":/images/doc-open"</span>), tr(<span class="string">"&amp;Open..."</span>), <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//openAction = new QAction("open", this);</span></span><br><span class="line">    openAction-&gt;setShortcuts(QKeySequence::Open);</span><br><span class="line">    openAction-&gt;setStatusTip(tr(<span class="string">"Open an existing file"</span>));</span><br><span class="line">    connect(openAction, &amp;QAction::triggered, <span class="keyword">this</span>, &amp;MainWindow::open);</span><br><span class="line"></span><br><span class="line">    QMenu *file = menuBar()-&gt;addMenu(tr(<span class="string">"&amp;File"</span>));</span><br><span class="line">    file-&gt;addAction(openAction);</span><br><span class="line"></span><br><span class="line">    QToolBar *toolBar = addToolBar(tr(<span class="string">"&amp;File"</span>));</span><br><span class="line">    toolBar-&gt;addAction(openAction);</span><br><span class="line"></span><br><span class="line">    statusBar() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MainWindow::open()</span><br><span class="line">&#123;</span><br><span class="line">    QMessageBox::information(<span class="keyword">this</span>, tr(<span class="string">"Information"</span>), tr(<span class="string">"Open"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序解释：</p>
<ul>
<li><p>QIcon，传入值是一个字符串，这个字符串对应于 Qt 资源文件中的一段路径。</p>
</li>
<li><p>QAction 第二个参数中，文本值前面有一个 &amp;，意味着这将成为一个快捷键。</p>
</li>
<li><p>setShortcut() 函数用于说明这个 QAction 的快捷键。</p>
<p>Qt 的 QKeySequence 为我们定义了很多内置的快捷键，根据平台不同而不同。</p>
</li>
<li><p>setStatusTip() 实现了当用户鼠标滑过这个 action 时，会在主窗口下方的状态栏显示相应的提示。</p>
</li>
<li><p>connect() 函数，将这个 QAction 的 triggered() 信号与 MainWindow 类的 open() 函数连接起来。</p>
</li>
<li><p>下面的 menuBar()、toolBar() 和 statusBar() 三个是 QMainWindow 的函数，用于创建并返回菜单栏、工具栏和状态栏。我们把 QAction 对象添加到这个菜单和工具栏。</p>
</li>
</ul>
<h3 id="tr"><a href="#tr" class="headerlink" title="tr()"></a>tr()</h3><p>函数 tr()全名是QObject::tr(),被它处理的字符串可以使用工具提取出来翻译成其他语言, 也就是做国际化使用。</p>
<p>只要记住,Qt 的最佳实践:如果你想让你的程序国际化的话,那么,所有用户可见的字符串都要使用 QObject::tr()!</p>
<p>例子：<code>tr(&quot;Cannot open file:\n%1&quot;).arg(path)</code></p>
<h3 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h3><ul>
<li><p>Qt 资源系统是一个<strong>跨平台</strong>的资源机制，用于将程序运行时所需要的资源以二进制的形式存储于可执行文件内部。如果你的程序需要加载特定的资源（图标、文本翻译等），那么，将其放置在资源文件中，就再也不需要担心这些文件的丢失。也就是说，如果你将资源以资源文件形式存储，它是会编译到可执行文件内部。</p>
</li>
<li><p>当我们编译工程之后，我们可以在构建目录中找到 qrc_res.cpp 文件，这就是 Qt 将我们的资源编译成了 C++ 代码。</p>
</li>
<li><p>通过使用冒号开头的路径来找到这个文件。比如，我们的前缀是 <code>/images</code>，文件是 <code>document-open.png</code>，那么就可以使用 <code>:/images/document-open.png</code> 找到这个文件。</p>
</li>
</ul>
<p><strong>别名</strong></p>
<p>如果我们要更改文件名，比如将 docuemnt-open.png 改成 docopen.png，那么，所有使用了这个名字的路径都需要修改。所以，更好的办法是，我们给这个文件取一个“别名”(Alias)，以后就以这个别名来引用这个文件。</p>
<p><strong>语言</strong>（待实践）</p>
<p>可以看到资源编辑窗口最下方有一个“语言”。这个可以对资源进行国际化。</p>
<p>比如我们新建一个前缀，将语言设置为 fr，再添加一个文件 document-open-fr.png。我们可以使用 <code>:/images/fr/doc-open</code> 引用到 document-open-fr.png 这个文件。这个“语言”的作用是，如果 Qt 发现，本机的本地化信息是 fr 的话（<code>QLocale::system().name()</code> 返回 fr_FR），则使用 <code>:/images/fr/doc-open</code> 这个图片；如果不是，则默认使用 :/images/doc-open 这个。</p>
<h3 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h3><p>​    标准 C++ 对象模型在运行时效率方面卓有成效，但是在某些特定问题域下的静态特性就显得捉襟见肘。GUI 界面需要同时具有运行时的效率以及更高级别的灵活性。为了解决这一问题，Qt “扩展”了标准 C++。所谓“扩展”，实际是在使用标准 C++ 编译器编译 Qt 源程序之前，Qt 先使用一个叫做 moc（Meta Object Compiler，元对象编译器）的工具，先对 Qt 源代码进行一次预处理（<em>注意，这个预处理与标准 C++ 的预处理有所不同。Qt 的 moc 预处理发生在标准 C++ 预处理器工作之前，并且 Qt 的 moc 预处理不是递归的。</em>），生成标准 C++ 源代码，然后再使用标准 C++ 编译器进行编译。</p>
<p><strong>特性</strong></p>
<p>Qt 使用 moc，为标准 C++ 增加了一些特性：</p>
<ul>
<li>信号槽机制，用于解决对象之间的通讯，这个我们已经了解过了，可以认为是 Qt 最明显的特性之一；</li>
<li>可查询，并且可设计的对象属性；</li>
<li>强大的事件机制以及事件过滤器；</li>
<li>基于上下文的字符串翻译机制（国际化），也就是 tr() 函数，我们简单地介绍过；</li>
<li>复杂的定时器实现，用于在事件驱动的 GUI 中嵌入能够精确控制的任务集成；</li>
<li>层次化的可查询的对象树，提供一种自然的方式管理对象关系。</li>
<li>智能指针（QPointer），在对象析构之后自动设为 0，防止野指针；</li>
<li>能够跨越库边界的动态转换机制。</li>
</ul>
<p>通过继承 QObject 类，我们可以很方便地获得这些特性。moc 其实实现的是一个叫做元对象系统（meta-object system）的机制。</p>
<p>虽然利用模板可以达到类似的效果，但是 Qt 没有选择使用模板。按照 Qt 官方的说法，模板虽然是内置语言特性，但是其语法实在是复杂，并且由于 GUI 是动态的，利用静态的模板机制有时候很难处理。而自己使用 moc 生成代码更为灵活，虽然效率有些降低（一个信号槽的调用大约相当于四个模板函数调用），不过在现代计算机上，这点性能损耗实在是可以忽略。</p>
<p><strong>对象树</strong></p>
<p>QObjects 是以对象树的形式组织起来的。当你创建一个 QObject 对象时，会看到 QObject 的构造函数接收一个 QObject 指针作为参数，这个参数就是 parent，也就是父对象指针。</p>
<p>这相当于，在创建 QObject 对象时，可以提供一个其父对象，我们创建的这个 QObject 对象会自动添加到其父对象的 children() 列表。当父对象析构的时候，这个列表中的所有对象也会被析构。（<strong>注意，这里的父对象并不是继承意义上的父类！</strong>）这种机制在 GUI 程序设计中相当有用。例如，一个按钮有一个 QShortcut（快捷键）对象作为其子对象。当我们删除按钮的时候，这个快捷键理应被删除。</p>
<p>QWidget 是能够在屏幕上显示的一切组件的父类。QWidget 继承自 QObject。</p>
<p>当一个 QObject 对象在堆上创建的时候，Qt 会同时为其创建一个对象树。不过，对象树中对象的顺序是没有定义的，销毁这些对象的顺序也是未定义的。Qt 保证的是，任何对象树中的 QObject 对象 delete 的时候，如果这个对象有 parent，则自动将其从 parent 的 children() 列表中删除；如果有孩子，则自动 delete 每一个孩子。Qt 保证没有 QObject 会被 delete 两次，这是由析构顺序决定的。</p>
<p><strong>补充</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    QWidget window;</span><br><span class="line">    <span class="function">QPushButton <span class="title">quit</span><span class="params">(<span class="string">"Quit"</span>, &amp;window)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为父组件的 window 和作为子组件的 quit 都是 QObject 的子类（事实上，它们都是 QWidget 的子类，而 QWidget 是 QObject 的子类）。这段代码是正确的，局部对象的析构顺序应该按照其创建顺序的相反过程。</p>
<p>但是，如果我们使用下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">QPushButton <span class="title">quit</span><span class="params">(<span class="string">"Quit"</span>)</span></span>;</span><br><span class="line">    QWidget window;</span><br><span class="line"></span><br><span class="line">    quit.setParent(&amp;window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>析构顺序就有了问题。在上面的代码中，作为父对象的 window 会首先被析构，因为它是最后一个创建的对象。在析构过程中，它会调用子对象列表中每一个对象的析构函数，也就是说， quit 此时就被析构了。然后，代码继续执行，在 window 析构之后，quit 也会被析构，因为 quit 也是一个局部变量，在超出作用域的时候当然也需要析构。但是，这时候已经是第二次调用 quit 的析构函数了，C++ 不允许调用两次析构函数，因此，程序崩溃了。</p>
<p>所以，我们最好从开始就养成良好习惯，在 Qt 中，<strong>尽量在构造的时候就指定 parent 对象</strong>，并且大胆在堆上创建。</p>
<h3 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.setWindowTitle(<span class="string">"Enter your age"</span>);</span><br><span class="line"></span><br><span class="line">    QSpinBox *spinBox = <span class="keyword">new</span> QSpinBox(&amp;window);</span><br><span class="line">    QSlider *slider = <span class="keyword">new</span> QSlider(Qt::Horizontal, &amp;window);</span><br><span class="line">    spinBox-&gt;setRange(<span class="number">0</span>, <span class="number">130</span>);</span><br><span class="line">    slider-&gt;setRange(<span class="number">0</span>, <span class="number">130</span>);</span><br><span class="line"></span><br><span class="line">    QObject::connect(slider, &amp;QSlider::valueChanged, spinBox, &amp;QSpinBox::setValue);</span><br><span class="line">    <span class="keyword">void</span> (QSpinBox:: *spinBoxSignal)(<span class="keyword">int</span>) = &amp;QSpinBox::valueChanged;	<span class="comment">// 1</span></span><br><span class="line">    QObject::connect(spinBox, spinBoxSignal, slider, &amp;QSlider::setValue);</span><br><span class="line">    spinBox-&gt;setValue(<span class="number">35</span>);</span><br><span class="line"></span><br><span class="line">    QHBoxLayout *layout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    layout-&gt;addWidget(spinBox);</span><br><span class="line">    layout-&gt;addWidget(slider);</span><br><span class="line">    window.setLayout(layout);</span><br><span class="line"></span><br><span class="line">    window.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<ol>
<li><p>将 slider 的 valueChanged() 信号同 spinBox 的 setValue() 函数相连时，如果直接写<code>&amp;QSpinBox::valueChanged</code>，编译器会报错，原因是编译器认为 QSpinBox::valueChanged 是一个 overloaded 的函数。看一下 QSpinBox 的文档发现，QSpinBox 的确有两个信号：</p>
<ul>
<li>void valueChanged(int)</li>
<li>void valueChanged(const QString &amp;)</li>
</ul>
<p>那么我们就显式指定一个函数。方法就是，我们创建一个函数指针，这个函数指针参数指定为 int。</p>
</li>
<li><p>仔细观察这两个 connect() 的作用，它们实际完成了一个双向的数据绑定。当然，对于 Qt 自己的信号函数，我们可以比较放心地使用。但是，如果是我们自己的信号，应当注意避免发生无限循环！</p>
</li>
<li><p>我们创建了一个 QHBoxLayout 对象。显然，这就是一个布局管理器。然后将这两个组件都添加到这个布局管理器，并且把该布局管理器设置为窗口的布局管理器。布局管理器很聪明地做出了正确的行为：保持 QSpinBox 宽度不变，自动拉伸 QSlider 的宽度。</p>
</li>
</ol>
<p>Qt 提供了几种布局管理器供我们选择：</p>
<ul>
<li>QHBoxLayout：按照水平方向从左到右布局；</li>
<li>QVBoxLayout：按照竖直方向从上到下布局；</li>
<li>QGridLayout：在一个网格中进行布局，类似于 HTML 的 table；</li>
<li>QFormLayout：按照表格布局，每一行前面是一段文本，文本后面跟随一个组件（通常是输入框），类似 HTML 的 form；</li>
<li>QStackedLayout：层叠的布局，允许我们将几个组件按照 Z 轴方向堆叠，可以形成向导那种一页一页的效果。</li>
</ul>
<h3 id="菜单栏、工具栏、状态栏"><a href="#菜单栏、工具栏、状态栏" class="headerlink" title="菜单栏、工具栏、状态栏"></a>菜单栏、工具栏、状态栏</h3><ul>
<li><p>Qt 将用户与界面进行交互的元素抽象为一种“动作”，使用 QAction 类表示。QAction 可以添加到菜单上、工具栏上。</p>
</li>
<li><p>我们假设窗口还是建立在 QMainWindow 类之上，这会让我们的开发简单许多。</p>
<p>当然，在实际开发过程中，QMainWindow 通常只作为“主窗口”，对话框窗口则更多地使用 QDialog 类。我们会在后面看到，QDialog 类会缺少一些 QMainWindow 类提供方便的函数，比如 menuBar() 以及 toolBar()。</p>
</li>
</ul>
<p><strong>菜单栏</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QMenu *file = menuBar()-&gt;addMenu(tr(<span class="string">"&amp;File"</span>));</span><br><span class="line">file-&gt;addAction(openAction);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>menuBar() 是 QMainWindow 提供的函数，因此你是不会在 QWidget 或者 QDialog 中找到它的。这个函数会返回窗口的菜单栏，如果没有菜单栏则会新创建一个。</p>
</li>
<li><p>使用其 addMenu() 函数为其添加菜单。</p>
</li>
<li><p>至于 &amp; 符号，已经解释过，这可以为菜单创建一个快捷键。</p>
</li>
<li>当我们创建出来了菜单对象时，就可以把 QAction 添加到这个菜单上面，也就是 addAction() 函数的作用。</li>
</ul>
<p><strong>工具栏</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QToolBar *toolBar = addToolBar(tr(<span class="string">"&amp;File"</span>));</span><br><span class="line">toolBar-&gt;addAction(openAction);</span><br></pre></td></tr></table></figure>
<ul>
<li>为什么前面一个是 menuBar() 而现在的是 addToolBar() 呢？因为一个窗口只有一个菜单栏，但是却可能有多个工具栏。</li>
<li><p>工具栏可以设置成固定的、浮动的等等，具体设置可以参考 Qt 文档。</p>
<p><strong>状态栏</strong></p>
</li>
</ul>
<p>前面我们说过，使用 QAction::setStatusTip() 可以设置该动作在状态栏上的提示文本。但我们现在把鼠标放在按钮上，是看不到这个提示文本的。原因很简单，我们没有添加一个状态栏。QMainWindow 有一个 statusBar() 函数，只需要添加下句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statusBar();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>同前面的 menuBar() 的实现类似，这个函数会返回一个 QStatusBar 对象，如果没有则先创建再返回。</p>
</li>
<li><p>QStatusBar 继承了 QWidget，因此，我们可以将其它任意 QWidget 子类添加到状态栏，从而实现类似 Photoshop 窗口底部那种有比例显示、有网格开关的复杂状态栏。请参考 Qt 文档。</p>
</li>
</ul>
<h3 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h3><ul>
<li><p>Qt 中使用 QDialog 类实现对话框。像主窗口一样，我们通常会设计一个类继承 QDialog。</p>
</li>
<li><p>QDialog 对于其 parent 指针都有额外的解释：</p>
<p>如果 parent 为 NULL，则该对话框会作为一个顶层窗口，否则则作为其父组件的子对话框（此时，其默认出现的位置是 parent 的中心）。</p>
<p>顶层窗口与非顶层窗口的区别在于，顶层窗口在任务栏会有自己的位置，而非顶层窗口则会共享其父组件的位置。</p>
</li>
</ul>
<p>下面修改了前面QAction示例的 open函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::open()</span><br><span class="line">&#123;</span><br><span class="line">    QDialog dialog;			<span class="comment">//顶层窗口</span></span><br><span class="line">    <span class="comment">//QDialog dialog(this);	//非顶层窗口</span></span><br><span class="line">    dialog.setWindowTitle(tr(<span class="string">"Hello, dialog!"</span>));</span><br><span class="line">    dialog.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模态和非模态"><a href="#模态和非模态" class="headerlink" title="模态和非模态"></a>模态和非模态</h4><p>对话框分为模态对话框和非模态对话框：</p>
<ul>
<li>模态对话框，就是会阻塞同一应用程序中其它窗口的输入。比如“打开文件”功能。</li>
<li>非模态对话框，不会阻塞同一应用程序中其它窗口的输入。例如查找对话框。</li>
</ul>
<p>Qt 有两种级别的模态对话框：</p>
<ul>
<li>应用程序级别的模态(默认)，当该种模态的对话框出现时，用户必须首先对对话框进行交互，直到关闭对话框，然后才能访问程序中其他的窗口。</li>
<li>窗口级别的模态，该模态仅仅阻塞与对话框关联的窗口，但是依然允许用户与程序中其它窗口交互。窗口级别的模态尤其适用于多窗口模式。</li>
</ul>
<p>实现方法：</p>
<ul>
<li><p>使用 QDialog::exec() 实现应用程序级别的模态对话框，</p>
</li>
<li><p>使用 QDialog::open() 实现窗口级别的模态对话框，</p>
</li>
<li><p>使用 QDialog::show() 实现非模态对话框。</p>
</li>
</ul>
<h5 id="非模态对话框的使用"><a href="#非模态对话框的使用" class="headerlink" title="非模态对话框的使用"></a>非模态对话框的使用</h5><p>我们试着将 exec() 修改为 show()，看看非模态对话框，但是对话框竟然一闪而过！</p>
<p>因为，show() 函数不会阻塞当前线程，对话框会显示出来，然后函数立即返回，代码继续执行。</p>
<p>注意，dialog 是建立在栈上的，show() 函数返回，MainWindow::open() 函数结束，dialog 超出作用域被析构，因此对话框消失了。</p>
<ol>
<li><p>我们将 dialog 改成堆上建立：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::open()</span><br><span class="line">&#123;</span><br><span class="line">    QDialog *dialog = <span class="keyword">new</span> QDialog;</span><br><span class="line">    dialog-&gt;setWindowTitle(tr(<span class="string">"Hello, dialog!"</span>));</span><br><span class="line">    dialog-&gt;show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 但是dialog 这时存在内存泄露！dialog 使用 new 在堆上分配空间，却一直没有 delete。解决方案也很简单：将 MainWindow 的指针赋给 dialog 即可。还记得我们前面说过的 Qt 的对象系统吗？</p>
<p> 不过，这样做有两个问题：</p>
<p> 如果我们的对话框不是在一个界面类中出现呢？由于 QWidget 的 parent 必须是 QWidget 指针，那就限制了我们不能将一个普通的 C++ 类指针传给 Qt 对话框。</p>
<p> 另外，如果对内存占用有严格限制的话，当我们将主窗口作为 parent 时，主窗口不关闭，对话框就不会被销毁，所以会一直占用内存。</p>
</li>
<li><p>更好地，我们可以设置 dialog 的 WindowAttribute：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::open()</span><br><span class="line">&#123;</span><br><span class="line">    QDialog *dialog = <span class="keyword">new</span> QDialog;</span><br><span class="line">    dialog-&gt;setAttribute(Qt::WA_DeleteOnClose);</span><br><span class="line">    dialog-&gt;setWindowTitle(tr(<span class="string">"Hello, dialog!"</span>));</span><br><span class="line">    dialog-&gt;show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> setAttribute() 函数设置对话框关闭时，自动销毁对话框。</p>
</li>
<li><p>另外，QObject 还有一个 deleteLater() 函数，该函数会在当前事件循环结束时销毁该对话框（具体到这里，需要使用 exec() 开始一个新的事件循环）。关于事件循环，我们会在后面的文章中详细说明。</p>
</li>
</ol>
<h4 id="对话框数据传递"><a href="#对话框数据传递" class="headerlink" title="对话框数据传递"></a>对话框数据传递</h4><p>对话框用于完成一个简单的任务。对话框与主窗口之间的数据交互相当重要。</p>
<p>本节将讲解如何在对话框和主窗口之间进行数据交互。对话框分为模态和非模态两种，分别进行阐述。</p>
<p><strong>模态对话框</strong></p>
<p>模态对话框使用了 exec() 函数将其显示出来。exec() 函数的真正含义是开启一个新的事件循环，既然是无限循环，在开启了事件循环的地方，代码就会被阻塞，后面的语句也就不会被执行到。因此，我们可以在 exec() 函数之后直接从对话框的对象获取到数据值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::open()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QDialog <span class="title">dialog</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    dialog.setWindowTitle(tr(<span class="string">"Hello, dialog!"</span>));</span><br><span class="line">    dialog.exec();</span><br><span class="line">    qDebug() &lt;&lt; dialog.result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>qDebug() 类似于 std::cout，将后面的信息输出到标准输出，一般就是控制台。需要头文件。</li>
<li>注意，如果我们设置 dialog 的属性为 WA_DeleteOnClose，那么当对话框关闭时，对象被销毁，我们就不能使用这种办法获取数据了。</li>
</ul>
<p>实际上，QDialog::exec() 是有返回值的，其返回值是 QDialog::Accepted 或者 QDialog::Rejected。可以以此判断对话框的返回值，也就是用户是点击了“确定”还是“取消”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QDialog <span class="title">dialog</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (dialog.exec() == QDialog::Accepted) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非模态对话框</strong></p>
<p>因为 show() 函数不会阻塞主线程，用户还没有来得及输入，就要执行后面的代码。那么我们就应该换一种思路获取数据，那就是使用信号槽机制。</p>
<p>由于非模态对话框在关闭时可以调用 QDialog::accept() 或者 QDialog::reject() 或者更通用的 QDialog::done() 函数，所以我们可以在这里发出信号。另外，如果找不到合适的信号发出点，我们可以重写 QDialog::closeEvent() 函数，在这里发出信号。在需要接收数据的窗口（这里是主窗口）连接到这个信号即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!!! Qt 5</span></span><br><span class="line"><span class="comment">// in dialog:</span></span><br><span class="line"><span class="keyword">void</span> UserAgeDialog::accept()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">emit <span class="title">userAgeChanged</span><span class="params">(newAge)</span></span>; <span class="comment">// newAge is an int</span></span><br><span class="line">    QDialog::accept();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in main window:</span></span><br><span class="line"><span class="keyword">void</span> MainWindow::showUserAgeDialog()</span><br><span class="line">&#123;</span><br><span class="line">    UserAgeDialog *dialog = <span class="keyword">new</span> UserAgeDialog(<span class="keyword">this</span>);</span><br><span class="line">    connect(dialog, &amp;UserAgeDialog::userAgeChanged, <span class="keyword">this</span>, &amp;MainWindow::setUserAge);</span><br><span class="line">    dialog-&gt;show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MainWindow::setUserAge(<span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line">    userAge = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要担心如果对话框关闭，是不是还能获取到数据。因为 Qt 信号槽的机制保证，在槽函数在调用的时候，我们始终可以使用 sender() 函数获取到 signal 的发出者。</p>
<p>顺便说一句，sender() 函数的存在使我们可以利用这个函数，来实现一个只能打开一个的非模态对话框（方法就是在对话框打开时在一个对话框映射表中记录下标记，在对话框关闭时利用 sender() 函数判断是不是该对话框，然后从映射表中将其删除）。</p>
<h4 id="标准对话框"><a href="#标准对话框" class="headerlink" title="标准对话框"></a>标准对话框</h4><p>所谓标准对话框，是 Qt 内置的一系列对话框，用于简化开发。</p>
<hr>
<p>Qt 的内置对话框大致分为以下几类：</p>
<ul>
<li>QColorDialog：选择颜色；</li>
<li>QFileDialog：选择文件或者目录；</li>
<li>QFontDialog：选择字体；</li>
<li>QInputDialog：允许用户输入一个值，并将其值返回；</li>
<li>QMessageBox：模态对话框，用于显示信息、询问问题等；</li>
<li>QProgressDialog：显示操作过程。</li>
</ul>
<p>在前面有了对话框的基础之上，应该可以结合文档很轻松地学习 Qt 的标准对话框。</p>
<hr>
<h5 id="消息对话框"><a href="#消息对话框" class="headerlink" title="消息对话框"></a>消息对话框</h5><p>这里简单地介绍一下 QMessageBox ，我们一般会使用其提供的几个 static 函数：</p>
<ul>
<li><p>void about(QWidget * parent, const QString &amp; title, const QString &amp; text)：显示关于对话框。这是一个最简单的对话框，其标题是 title，内容是 text，父窗口是 parent。对话框只有一个 OK 按钮。</p>
</li>
<li><p>void aboutQt(QWidget * parent, const QString &amp; title = QString())：显示关于 Qt 对话框。该对话框用于显示有关 Qt 的信息。</p>
</li>
<li><p>StandardButton critical(QWidget * parent, const QString &amp; title, const QString &amp; text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton)：显示严重错误对话框。这个对话框将显示一个红色的错误符号。我们可以通过 buttons 参数指明其显示的按钮。默认情况下只有一个 Ok 按钮，我们可以使用 StandardButtons 类型指定多种按钮。</p>
</li>
<li><p>StandardButton information(QWidget * parent, const QString &amp; title, const QString &amp; text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton)：QMessageBox::information() 函数与 QMessageBox::critical() 类似，不同之处在于这个对话框提供一个普通信息图标。</p>
</li>
<li><p>StandardButton question(QWidget * parent, const QString &amp; title, const QString &amp; text, StandardButtons buttons = StandardButtons( Yes | No ), StandardButton defaultButton = NoButton)：QMessageBox::question() 函数与 QMessageBox::critical() 类似，不同之处在于这个对话框提供一个问号图标，并且其显示的按钮是“是”和“否”两个。</p>
</li>
<li><p>StandardButton warning(QWidget * parent, const QString &amp; title, const QString &amp; text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton)：QMessageBox::warning() 函数与 QMessageBox::critical() 类似，不同之处在于这个对话框提供一个叹号图标。</p>
</li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (QMessageBox::Yes == QMessageBox::question(<span class="keyword">this</span>,</span><br><span class="line">                                              tr(<span class="string">"Question"</span>),</span><br><span class="line">                                              tr(<span class="string">"Are you OK?"</span>),</span><br><span class="line">                                              QMessageBox::Yes | QMessageBox::No,</span><br><span class="line">                                              QMessageBox::Yes)) &#123;</span><br><span class="line">    QMessageBox::information(<span class="keyword">this</span>, tr(<span class="string">"Hmmm..."</span>), tr(<span class="string">"I'm glad to hear that!"</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    QMessageBox::information(<span class="keyword">this</span>, tr(<span class="string">"Hmmm..."</span>), tr(<span class="string">"I'm sorry!"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这个对话框的父窗口是 this。QMessageBox 是 QDialog 的子类，这意味着它的初始显示位置将会是在 parent 窗口的中央。</p>
</li>
<li><p>我们使用或运算符（|）指定对话框应该出现的按钮。这里我们希望是一个 Yes 和一个 No。</p>
</li>
<li>最后一个参数指定默认选择的按钮。</li>
</ul>
<hr>
<p>QMessageBox 类的 static 函数优点是方便使用，缺点也很明显：非常不灵活。我们只能使用简单的几种形式。</p>
<p>为了能够定制 QMessageBox 细节，我们必须使用 QMessageBox 的属性设置 API。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox msgBox;</span><br><span class="line">msgBox.setText(tr(<span class="string">"The document has been modified."</span>));</span><br><span class="line">msgBox.setInformativeText(tr(<span class="string">"Do you want to save your changes?"</span>));</span><br><span class="line">msgBox.setDetailedText(tr(<span class="string">"Differences here..."</span>));</span><br><span class="line">msgBox.setStandardButtons(QMessageBox::Save</span><br><span class="line">                          | QMessageBox::Discard</span><br><span class="line">                          | QMessageBox::Cancel);</span><br><span class="line">msgBox.setDefaultButton(QMessageBox::Save);</span><br><span class="line"><span class="keyword">int</span> ret = msgBox.exec();</span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line"><span class="keyword">case</span> QMessageBox::Save:</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"Save document!"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> QMessageBox::Discard:</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"Discard changes!"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> QMessageBox::Cancel:</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"Close document!"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置其标题为“The document has been modified.”，informationText 则是会在对话框中显示的文字。</li>
<li>下面我们使用了一个 detailedText，也就是详细信息，当我们点击了详细信息按钮时，对话框可以自动显示更多信息。</li>
<li><p>我们自己定义的对话框的按钮有三个：保存、丢弃和取消。然后我们使用了 exec() 使其成为一个模态对话框，根据其返回值进行相应的操作。</p>
</li>
<li><p>我们并没有指定按钮的顺序，Qt 已经帮我们按照不同平台的使用习惯对其进行了调整。这一点在 Mac OS 上也会有相应的体现。</p>
<p>对于一个普通的 QDialog 而言，Qt 使用的是 QDialogButtonBox 这个类来实现不同平台的对话框按钮顺序的显示的。</p>
</li>
</ul>
<hr>
<h5 id="文件对话框"><a href="#文件对话框" class="headerlink" title="文件对话框"></a>文件对话框</h5><p>在本节中，我们将尝试编写一个简单的文本文件编辑器，我们将使用 QFileDialog 来打开一个文本文件，并将修改过的文件保存到硬盘。</p>
<p>（此程序仅用于演示，很多必须的操作并没有进行。比如，我们没有检查这个文件的实际类型是不是一个文本文件。并且直接读取文件所有内容，如果文件过大，程序会立刻死掉。）</p>
<ol>
<li><p>首先，我们需要创建一个带有文本编辑功能的窗口：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">openAction = <span class="keyword">new</span> QAction(<span class="string">"open"</span>, <span class="keyword">this</span>);</span><br><span class="line">openAction-&gt;setShortcuts(QKeySequence::Open);</span><br><span class="line">openAction-&gt;setStatusTip(tr(<span class="string">"Open an existing file"</span>));</span><br><span class="line"></span><br><span class="line">saveAction = <span class="keyword">new</span> QAction(QIcon(<span class="string">"file-save"</span>), <span class="keyword">this</span>);</span><br><span class="line">saveAction-&gt;setShortcuts(QKeySequence::Save);</span><br><span class="line">saveAction-&gt;setStatusTip(tr(<span class="string">"Save a new file"</span>));</span><br><span class="line"></span><br><span class="line">QMenu *file = menuBar()-&gt;addMenu(tr(<span class="string">"&amp;File"</span>));</span><br><span class="line">file-&gt;addAction(openAction);</span><br><span class="line">file-&gt;addAction(saveAction);</span><br><span class="line"></span><br><span class="line">QToolBar *toolBar = addToolBar(tr(<span class="string">"&amp;File"</span>));</span><br><span class="line">toolBar-&gt;addAction(openAction);</span><br><span class="line">toolBar-&gt;addAction(saveAction);</span><br><span class="line"></span><br><span class="line">textEdit = <span class="keyword">new</span> QTextEdit(<span class="keyword">this</span>);</span><br><span class="line">setCentralWidget(textEdit);</span><br></pre></td></tr></table></figure>
<ul>
<li>我们在菜单和工具栏添加了两个动作：打开和保存。</li>
<li>接下来是一个 <strong>QTextEdit</strong> 类，这个类用于显示富文本文件。也就是说，它不仅仅用于显示文本，还可以显示图片、表格等等。不过，我们现在只用它显示纯文本文件。</li>
<li>QMainWindow 有一个 setCentralWidget() 函数，可以将一个组件作为窗口的中心组件，放在窗口中央显示区。</li>
</ul>
</li>
<li><p>我们使用 connect() 函数，为这两个 QAction 对象添加响应的动作：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect(openAction, &amp;QAction::triggered, <span class="keyword">this</span>, &amp;MainWindow::openFile);</span><br><span class="line">connect(saveAction, &amp;QAction::triggered, <span class="keyword">this</span>, &amp;MainWindow::saveFile);</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面是最主要的 openFile() 和 saveFile() 这两个函数的代码：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::openFile()</span><br><span class="line">&#123;</span><br><span class="line">    QString path = QFileDialog::getOpenFileName(<span class="keyword">this</span>,</span><br><span class="line">                                                tr(<span class="string">"Open File"</span>),</span><br><span class="line">                                                <span class="string">"."</span>,</span><br><span class="line">                                                tr(<span class="string">"Text Files(*.txt)"</span>));</span><br><span class="line">    <span class="keyword">if</span>(!path.isEmpty()) &#123;</span><br><span class="line">        <span class="function">QFile <span class="title">file</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!file.open(QIODevice::ReadOnly | QIODevice::Text)) &#123;</span><br><span class="line">            QMessageBox::warning(<span class="keyword">this</span>, tr(<span class="string">"Read File"</span>),</span><br><span class="line">                                 tr(<span class="string">"Cannot open file:\n%1"</span>).arg(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">QTextStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">        textEdit-&gt;setText(in.readAll());</span><br><span class="line">        file.close();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        QMessageBox::warning(<span class="keyword">this</span>, tr(<span class="string">"Path"</span>),</span><br><span class="line">                             tr(<span class="string">"You did not select any file."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MainWindow::saveFile()</span><br><span class="line">&#123;</span><br><span class="line">    QString path = QFileDialog::getSaveFileName(<span class="keyword">this</span>,</span><br><span class="line">                                                tr(<span class="string">"Open File"</span>),</span><br><span class="line">                                                <span class="string">"."</span>,</span><br><span class="line">                                                tr(<span class="string">"Text Files(*.txt)"</span>));</span><br><span class="line">    <span class="keyword">if</span>(!path.isEmpty()) &#123;</span><br><span class="line">        <span class="function">QFile <span class="title">file</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!file.open(QIODevice::WriteOnly | QIODevice::Text)) &#123;</span><br><span class="line">            QMessageBox::warning(<span class="keyword">this</span>, tr(<span class="string">"Write File"</span>),</span><br><span class="line">                                       tr(<span class="string">"Cannot open file:\n%1"</span>).arg(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">QTextStream <span class="title">out</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">        out &lt;&lt; textEdit-&gt;toPlainText();</span><br><span class="line">        file.close();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        QMessageBox::warning(<span class="keyword">this</span>, tr(<span class="string">"Path"</span>),</span><br><span class="line">                             tr(<span class="string">"You did not select any file."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在 openFile() 函数中，我们使用 <code>QFileDialog::getOpenFileName()</code> 来获取需要打开的文件的路径。这个函数具有一个长长的签名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">getOpenFileName</span><span class="params">(QWidget * parent = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> QString &amp; caption = QString(),</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> QString &amp; dir = QString(),</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> QString &amp; filter = QString(),</span></span></span><br><span class="line"><span class="function"><span class="params">                        QString * selectedFilter = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                        Options options = <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>不过注意，它的所有参数都是可选的</p>
<ul>
<li><p>parent：父窗口；</p>
</li>
<li><p>caption：对话框标题；</p>
</li>
<li><p>dir：对话框打开时的默认目录，“.” 代表程序运行目录，“/” 代表 Windows 当前盘符的根目录、Linux 平台的根目录，这个参数也可以是平台相关的，比如“C:\”等；</p>
</li>
<li><p>filter：过滤器。用于过滤特定的后缀名。如果我们使用<code>“Image Files(*.jpg *.png)”</code>，则只能显示后缀名是 jpg 或者 png 的文件。如果需要多个过滤器，使用“;;”分割，比如<code>“JPEG Files(*.jpg);;PNG Files(*.png)”</code>；</p>
</li>
<li><p>selectedFilter：默认选择的过滤器；</p>
</li>
<li><p>options：对话框的一些参数设定，比如只显示文件夹等等，它的取值是 enum QFileDialog::Option，每个选项可以使用 | 运算组合起来。</p>
</li>
</ul>
</li>
<li><p>QFileDialog::getOpenFileName() 返回值是选择的文件路径。我们将其赋值给 path。通过判断 path 是否为空，可以确定用户是否选择了某一文件。</p>
</li>
<li><p>我们创建一个 QFile 对象，将用户选择的文件路径传递给这个对象。</p>
</li>
<li><p>然后打开这个文件，使用的是 QFile::open()，其参数是指定的打开方式，这里我们使用只读方式和文本方式打开这个文件。打开成功则返回 true。</p>
</li>
<li><p>使用 QTextStream::readAll() 读取文件所有内容，然后将其赋值给 QTextEdit 显示出来。最后不要忘记关闭文件。</p>
<p>saveFile() 函数也是类似的，只不过最后一步，我们使用 &lt;&lt; 重定向，将 QTextEdit 的内容输出到一个文件中。</p>
</li>
</ul>
</li>
</ol>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件（event）是由系统或者 Qt 本身在不同的时刻发出的。当用户按下鼠标、敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。</p>
<p>Qt 中的事件和信号槽并不是相互替代的。</p>
<ul>
<li><p>信号由具体的对象发出，然后会马上交给由 connect() 函数连接的槽进行处理；而对于事件，Qt 使用一个事件队列对所有发出的事件进行维护，当新的事件产生时，会被追加到事件队列的尾部。前一个事件完成后，取出后面的事件进行处理。但是，必要的时候，Qt 的事件也可以不进入事件队列，而是直接处理。</p>
<p>即<strong>信号槽是同步的，事件可以是同步的或者异步的。</strong></p>
</li>
<li><p><strong>事件处理函数的返回值是有意义的</strong>，我们要根据这个返回值来确定是否还要继续事件的处理，比如在QT中，事件处理函数如果返回true，则这个事件处理已完成，QApplication会接着处理下一个事件，而如果返回false，那么事件分派函数会继续向上寻找下一个可以处理该事件的注册方法。信号处理函数的返回值对信号分派器来说是无意义的。</p>
</li>
<li><p>信号一旦发出，对应的槽函数一定会被执行。但是，<strong>事件则可以使用“事件过滤器”进行过滤</strong>，对于有些事件进行额外的处理，另外的事件则不关心。</p>
</li>
<li><p>总的来说，如果我们使用组件，我们关心的是信号槽；如果我们自定义组件，我们关心的是事件。因为我们可以通过事件来改变组件的默认操作。</p>
</li>
</ul>
<p>在执行 exec() 函数之后，程序将进入事件循环来监听应用程序的事件。当事件发生时，Qt 将创建一个事件对象。Qt 中所有事件类都继承于 QEvent。在事件对象创建完毕后，Qt 将这个事件对象传递给 QObject 的 event() 函数。event() 函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数（event handler）。</p>
<p>在所有组件的父类 QWidget 中，定义了很多事件处理的回调函数，如 keyPressEvent()、keyReleaseEvent()、mouseDoubleClickEvent()、mouseMoveEvent ()、mousePressEvent()、mouseReleaseEvent() 等。这些函数都是 protected virtual 的，也就是说，我们可以在子类中重新实现这些函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLabel</span> :</span> <span class="keyword">public</span> QLabel</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> EventLabel::mouseMoveEvent(QMouseEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;setText(QString(<span class="string">"&lt;center&gt;&lt;h1&gt;Move: (%1, %2)&lt;/h1&gt;&lt;/center&gt;"</span>)</span><br><span class="line">                  .arg(QString::number(event-&gt;x()), QString::number(event-&gt;y())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> EventLabel::mousePressEvent(QMouseEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;setText(QString(<span class="string">"&lt;center&gt;&lt;h1&gt;Press: (%1, %2)&lt;/h1&gt;&lt;/center&gt;"</span>)</span><br><span class="line">                  .arg(QString::number(event-&gt;x()), QString::number(event-&gt;y())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> EventLabel::mouseReleaseEvent(QMouseEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    QString msg;</span><br><span class="line">    msg.<span class="built_in">sprintf</span>(<span class="string">"&lt;center&gt;&lt;h1&gt;Release: (%d, %d)&lt;/h1&gt;&lt;/center&gt;"</span>,</span><br><span class="line">                event-&gt;x(), event-&gt;y());</span><br><span class="line">    <span class="keyword">this</span>-&gt;setText(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    EventLabel *label = <span class="keyword">new</span> EventLabel;</span><br><span class="line">    label-&gt;setWindowTitle(<span class="string">"MouseEvent Demo"</span>);</span><br><span class="line">    label-&gt;resize(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">    label-&gt;show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>EventLabel 继承了 QLabel，覆盖了 mousePressEvent()、mouseMoveEvent() 和 MouseReleaseEvent() 三个函数。我们并没有添加什么功能，只是在鼠标按下（press）、鼠标移动（move）和鼠标释放（release）的时候，把当前鼠标的坐标值显示在这个 Label 上面。由于 QLabel 是支持 HTML 代码的，因此我们直接使用了 HTML 代码来格式化文字。</p>
</li>
<li><p>运行上面的代码，当我们点击了一下鼠标之后，label 上将显示鼠标当前坐标值。</p>
<p>为什么要点击鼠标之后才能在 mouseMoveEvent() 函数中显示鼠标坐标值？这是因为 QWidget 中有一个 mouseTracking 属性，该属性用于设置是否追踪鼠标。只有鼠标被追踪时，mouseMoveEvent() 才会发出。默认的 mouseTracking 是 false，组件在至少一次鼠标点击之后，才能够被追踪。如果 mouseTracking 为 true，则 mouseMoveEvent() 直接可以被发出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label-&gt;setMouseTracking(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="接收与忽略"><a href="#接收与忽略" class="headerlink" title="接收与忽略"></a>接收与忽略</h4><p>通过调用父类的同名函数，我们可以把 Qt 的事件传递看成链状：如果子类没有处理这个事件，就会继续向其父类传递。Qt 的事件对象有两个函数：accept() 和 ignore()。在事件处理函数中，可以使用 isAccepted() 来查询这个事件是不是已经被接收了。如果一个事件处理函数调用了一个事件对象的 accept() 函数，这个事件就不会被继续传播给其父组件；如果它调用了事件的 ignore() 函数，Qt 会从其父组件中寻找另外的接受者。</p>
<p>事实上，我们很少会使用 accept() 和 ignore() 函数，而是像上面的示例一样，如果希望忽略事件（所谓忽略，是指自己不想要这个事件），只要调用父类的响应函数即可。（Qt 中的事件都是 protected 的，因此，重写的函数必定存在着其父类中的响应函数。）</p>
<p>为了避免自己去调用 accept() 和 ignore() 函数，而是尽量调用父类实现，Qt 做了特殊的设计：事件对象默认是 accept 的，而作为所有组件的父类 QWidget 的默认实现则是调用 ignore()。这么一来，如果你自己实现事件处理函数，不调用 QWidget 的默认实现，你就等于是接受了事件；如果你要忽略事件，只需调用 QWidget 的默认实现。</p>
<hr>
<p>在一个情形下，我们必须使用 accept() 和 ignore() 函数，那就是<strong>窗口关闭的事件</strong>。对于 QCloseEvent 事件，调用 accept() 意味着 Qt 会停止事件的传播（窗口关闭了），调用 ignore() 则意味着事件继续传播。</p>
<p>在上面的文件对话框例子中添加如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mainwindow.cpp</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">connect(textEdit, &amp;QTextEdit::textChanged, [=]() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;setWindowModified(<span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MainWindow::closeEvent(QCloseEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isWindowModified()) &#123;</span><br><span class="line">        <span class="keyword">bool</span> <span class="built_in">exit</span> = QMessageBox::question(<span class="keyword">this</span>,</span><br><span class="line">                                      tr(<span class="string">"Quit"</span>),</span><br><span class="line">                                      tr(<span class="string">"Are you sure to quit this application?"</span>),</span><br><span class="line">                                      QMessageBox::Yes | QMessageBox::No,</span><br><span class="line">                                      QMessageBox::No) == QMessageBox::Yes;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exit</span>) &#123;</span><br><span class="line">            event-&gt;accept();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            event-&gt;ignore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event-&gt;accept();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重写event"><a href="#重写event" class="headerlink" title="重写event()"></a>重写event()</h4><p>event() 函数主要用于事件的分发。所以，如果你希望在事件分发之前做一些操作，就可以重写这个 event() 函数了。例如，我们希望在一个 QWidget 组件中监听 tab 键的按下，那么就可以继承 QWidget，并重写它的 event() 函数，来达到这个目的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> CustomWidget::event(QEvent *e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;type() == QEvent::KeyPress) &#123;</span><br><span class="line">        QKeyEvent *keyEvent = <span class="keyword">static_cast</span>&lt;QKeyEvent *&gt;(e);</span><br><span class="line">        <span class="keyword">if</span> (keyEvent-&gt;key() == Qt::Key_Tab) &#123;</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">"You press tab."</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::event(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>CustomWidget 是一个普通的 QWidget 子类。我们重写了它的 event() 函数，这个函数有一个 QEvent 对象作为参数，也就是需要转发的事件对象。</p>
</li>
<li><p>函数返回值是 bool 类型。如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false。如果返回值是 true，并且，该事件对象设置了 accept()，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。</p>
</li>
<li><p>注意，在 event() 函数中，调用事件对象的 accept() 和 ignore() 函数是没有作用的，不会影响到事件的传播。</p>
</li>
<li><p>QEvent::type() 函数返回值是 QEvent::Type 类型的枚举。我们处理过自己感兴趣的事件之后，可以直接返回 true，表示我们已经对此事件进行了处理；对于其它我们不关心的事件，则需要调用父类的 event() 函数继续转发。</p>
</li>
</ul>
<p><strong>由此可见</strong>，event() 是一个集中处理不同类型的事件的地方。如果你不想重写一大堆事件处理器，就可以重写这个 event() 函数，通过 QEvent::type() 判断不同的事件。鉴于重写 event() 函数需要十分小心注意父类的同名函数的调用，一不留神就可能出现问题，所以一般还是建议只重写事件处理器（当然，也必须记得是不是应该调用父类的同名处理器）。这其实暗示了 event() 函数的另外一个作用：屏蔽掉某些不需要的事件处理器。正如我们前面的 CustomTextEdit 例子看到的那样，我们创建了一个只能响应 tab 键的组件。这种作用是重写事件处理器所不能实现的。</p>
<h4 id="事件过滤器"><a href="#事件过滤器" class="headerlink" title="事件过滤器"></a>事件过滤器</h4><p>有时候，对象需要查看、甚至要拦截发送到另外对象的事件。例如，对话框可能想要拦截按键事件，不让别的组件接收到；或者要修改回车键的默认处理。QObject 有一个 eventFilter() 函数，用于建立事件过滤器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">bool</span> QObject::eventFilter ( QObject * watched, QEvent * event );</span><br></pre></td></tr></table></figure>
<p>它会检查接收到的事件。如果这个事件是我们感兴趣的类型，就进行我们自己的处理；如果不是，就继续转发。</p>
<ul>
<li><p>这个函数返回一个 bool 类型，如果你想将参数 event 过滤出来，不想让它继续转发，就返回 true，否则返回 false。</p>
</li>
<li><p>事件过滤器的调用时间是目标对象（也就是参数里面的 watched 对象）接收到事件对象之前。也就是说，如果你在事件过滤器中停止了某个事件，那么，watched 对象以及以后所有的事件过滤器根本不会知道这个事件。</p>
</li>
</ul>
<hr>
<p>eventFilter() 函数相当于创建了过滤器。安装过滤器需要调用 QObject::installEventFilter() 函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> QObject::installEventFilter ( QObject * filterObj )</span><br></pre></td></tr></table></figure>
<p>这个函数接受一个 QObject * 类型的参数。记得刚刚我们说的，eventFilter() 函数是 QObject 的一个成员函数，因此，任意 QObject 都可以作为事件过滤器。过滤器可以通过 QObject::removeEventFilter() 函数移除。</p>
<p>另一个例子见事件层次。</p>
<p>我们可以向一个对象上面安装多个事件处理器，只要调用多次 installEventFilter() 函数。如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序。</p>
<p><strong>例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     MainWindow();</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     QTextEdit *textEdit;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> MainWindow::MainWindow()</span><br><span class="line"> &#123;</span><br><span class="line">     textEdit = <span class="keyword">new</span> QTextEdit;</span><br><span class="line">     setCentralWidget(textEdit);</span><br><span class="line"> </span><br><span class="line">     textEdit-&gt;installEventFilter(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">bool</span> MainWindow::eventFilter(QObject *obj, QEvent *event)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (obj == textEdit) &#123;</span><br><span class="line">         <span class="keyword">if</span> (event-&gt;type() == QEvent::KeyPress) &#123;</span><br><span class="line">             QKeyEvent *keyEvent = <span class="keyword">static_cast</span>&lt;QKeyEvent *&gt;(event);</span><br><span class="line">             qDebug() &lt;&lt; <span class="string">"Ate key press"</span> &lt;&lt; keyEvent-&gt;key();</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// pass the event on to the parent class</span></span><br><span class="line">         <span class="keyword">return</span> QMainWindow::eventFilter(obj, event);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>重写event()的Tab 键例子可以改写为事件过滤器版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> FilterObject::eventFilter(QObject *object, QEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (object == target &amp;&amp; event-&gt;type() == QEvent::KeyPress) &#123;</span><br><span class="line">        QKeyEvent *keyEvent = <span class="keyword">static_cast</span>&lt;QKeyEvent *&gt;(event);</span><br><span class="line">        <span class="keyword">if</span> (keyEvent-&gt;key() == Qt::Key_Tab) &#123;</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">"You press tab."</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>PS：</strong></p>
<p>尽管事件过滤器很强大，但这种行为会严重降低整个应用程序的事件分发效率。因此，除非是不得不使用的情况，否则的话我们不应该这么做。</p>
<p><strong>注意，如果你在事件过滤器中 delete 了某个接收组件，务必将函数返回值设为 true。否则，Qt 还是会将事件分发给这个接收组件，从而导致程序崩溃。</strong></p>
<p>事件过滤器和被安装过滤器的组件<strong>必须在同一线程</strong>，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</p>
<h4 id="事件层次"><a href="#事件层次" class="headerlink" title="事件层次"></a>事件层次</h4><p>Qt 中有很多种事件：鼠标事件、键盘事件、大小改变的事件、位置移动的事件等等。如何处理这些事件，实际有两种选择：</p>
<ol>
<li>所有事件对应一个事件处理函数，在这个事件处理函数中用一个很大的分支语句进行选择。</li>
<li>每一种事件对应一个事件处理函数。Qt 就是使用的这种机制。event() 对所有事件处理函数进行分发。</li>
</ol>
<p>但event() 函数会有两个问题：</p>
<ul>
<li><p>event() 函数是一个 protected 的函数，这意味着我们要想重写 event()，必须继承一个已有的类。试想，我的程序根本不想要鼠标事件，程序中所有组件都不允许处理鼠标事件，是不是我得继承所有组件，一一重写其 event() 函数？protected 函数带来的另外一个问题是，如果我基于第三方库进行开发，而对方没有提供源代码，只有一个链接库，其它都是封装好的。我怎么去继承这种库中的组件呢？</p>
</li>
<li><p>event() 函数的确有一定的控制，不过有时候我的需求更严格一些：我希望那些组件根本看不到这种事件。event() 函数虽然可以拦截，但其实也是接收到了 QMouseEvent 对象。我连让它收都收不到。这样做的好处是，模拟一种系统根本没有那个事件的效果，所以其它组件根本不会收到这个事件，也就无需修改自己的事件处理函数。这种需求怎么办呢？</p>
</li>
</ul>
<p>这两个问题是 event() 函数无法处理的。于是，Qt 提供了另外一种解决方案：事件过滤器。事件过滤器给我们一种能力，让我们能够完全移除某种事件。事件过滤器可以安装到任意 QObject 类型上面，并且可以安装多个。</p>
<p><strong>如果要实现全局的事件过滤器，则可以安装到 QApplication 或者 QCoreApplication 上面。</strong></p>
<p>事件过滤器可以解决刚刚我们提出的 event() 函数的两点不足：首先，事件过滤器不是 protected 的，因此我们可以向任何 QObject 子类安装事件过滤器；其次，事件过滤器在目标对象接收到事件之前进行处理，如果我们将事件过滤掉，目标对象根本不会见到这个事件。</p>
<hr>
<p>事实上，还有一种方法，我们没有介绍。Qt 事件的调用最终都会追溯到 QCoreApplication::notify() 函数，因此，最大的控制权实际上是重写 QCoreApplication::notify()。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">bool</span> QCoreApplication::notify ( QObject * receiver, QEvent * event );</span><br></pre></td></tr></table></figure>
<p>该函数会将 event 发送给 receiver，也就是调用 receiver-&gt;event(event)，其返回值就是来自 receiver 的事件处理器。注意，这个函数为任意线程的任意对象的任意事件调用，因此，它不存在事件过滤器的线程的问题。不过我们并不推荐这么做，因为 notify() 函数只有一个，而事件过滤器要灵活得多。</p>
<hr>
<p>现在我们可以总结一下 Qt 的事件处理，实际上是有五个层次：</p>
<ul>
<li>重写 paintEvent()、mousePressEvent() 等事件处理函数。这是最普通、最简单的形式，同时功能也最简单。</li>
<li>重写 event() 函数。event() 函数是所有对象的事件入口，QObject 和 QWidget 中的实现，默认是把事件传递给特定的事件处理函数。</li>
<li>在特定对象上面安装事件过滤器。该过滤器仅过滤该对象接收到的事件。</li>
<li>在 QCoreApplication::instance() 上面安装事件过滤器。该过滤器将过滤所有对象的所有事件，因此和 notify() 函数一样强大，但是它更灵活，因为可以安装多个过滤器。全局的事件过滤器可以看到 disabled 组件上面发出的鼠标事件。全局过滤器有一个问题：只能用在主线程。</li>
<li>重写 QCoreApplication::notify() 函数。这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程的限制。但是全局范围内只能有一个被使用（因为 QCoreApplication 是单例的）。</li>
</ul>
<p>关于调用顺序的<strong>例子</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Label()</span><br><span class="line">    &#123;</span><br><span class="line">        installEventFilter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (watched == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (event-&gt;type() == QEvent::MouseButtonPress) &#123;</span><br><span class="line">                qDebug() &lt;&lt; <span class="string">"eventFilter"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"mousePressEvent"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;type() == QEvent::MouseButtonPress) &#123;</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">"event"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> QWidget::event(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventFilter</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EventFilter(QObject *watched, QObject *parent = <span class="number">0</span>) :</span><br><span class="line">        QObject(parent),</span><br><span class="line">        m_watched(watched)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (watched == m_watched) &#123;</span><br><span class="line">            <span class="keyword">if</span> (event-&gt;type() == QEvent::MouseButtonPress) &#123;</span><br><span class="line">                qDebug() &lt;&lt; <span class="string">"QApplication::eventFilter"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QObject *m_watched;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    Label label;</span><br><span class="line">    app.installEventFilter(<span class="keyword">new</span> EventFilter(&amp;label, &amp;label));</span><br><span class="line">    label.show();</span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，鼠标点击之后的输出结果是：</p>
<p>QApplication::eventFilter eventFilter event mousePressEvent</p>
<p>因此可以知道，全局事件过滤器被第一个调用，之后是该对象上面的事件过滤器，其次是 event() 函数，最后是特定的事件处理函数。</p>
<h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><p>(待实践)</p>
<p>Qt 自定义事件很简单，需要继承的类是 QEvent。</p>
<p><strong>继承 QEvent 类，最重要的是提供一个 QEvent::Type 类型的参数，作为自定义事件的类型值。</strong>回忆一下，这个 type 是我们在处理事件时用于识别事件类型的代号。比如在 event() 函数中，我们使用 QEvent::type() 获得这个事件类型，然后与我们定义的实际类型对比。</p>
<p><strong>QEvent::Type 是 QEvent 定义的一个枚举。因此，我们可以传递一个 int 值。</strong>但是需要注意的是，我们的自定义事件类型不能和已经存在的 type 值重复，否则会有不可预料的错误发生。因为系统会将你新增加的事件当做系统事件进行派发和调用。</p>
<p>在 Qt 中，系统保留 0 – 999 的值，也就是说，你的事件 type 要大于 999。</p>
<p>这种数值当然非常难记，所以 <strong>Qt 定义了两个边界值：QEvent::User 和 QEvent::MaxUser</strong>。我们的自定义事件的 type 应该在这两个值的范围之间。其中，QEvent::User 的值是 1000，QEvent::MaxUser 的值是 65535。</p>
<p>但是，这样并不能保证自定义事件相互之间不会被覆盖。为了解决这个问题，Qt 提供了一个函数：registerEventType()，用于<strong>自定义事件的注册</strong>。该函数签名如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> QEvent::registerEventType( <span class="keyword">int</span> hint = <span class="number">-1</span> );</span><br></pre></td></tr></table></figure>
<p>这个函数是 static 的，因此可以使用 QEvent 类直接调用。函数接受一个 int 值，其默认值是 -1；函数返回值是向系统注册的新的 Type 类型的值。如果 hint 不会发生任何覆盖，则会直接返回这个值；否则，系统会自动分配一个合法值并返回。因此，使用这个函数即可完成 type 值的指定。这个函数是线程安全的，不必另外添加同步。</p>
<hr>
<p>可以在 QEvent 子类中添加自己的事件所需要的数据，然后进行事件的发送。Qt 中提供了<strong>两种事件发送方式</strong>：</p>
<ol>
<li><p>直接将 event 事件发送给 receiver 接受者，使用的是 QCoreApplication::notify() 函数。函数返回值就是事件处理函数的返回值。在事件被发送的时候，event 对象并不会被销毁。通常我们会在栈上创建 event 对象，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> QCoreApplication::sendEvent(QObject *receiver,</span><br><span class="line">                                        QEvent *event);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMouseEvent <span class="title">event</span><span class="params">(QEvent::MouseButtonPress, pos, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">QApplication::sendEvent(mainWindow, &amp;event);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将 event 事件及其接受者 receiver 一同追加到事件队列中，函数立即返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> QCoreApplication::postEvent(QObject *receiver,</span><br><span class="line">                                        QEvent *event);</span><br></pre></td></tr></table></figure>
<p>因为 post 事件队列会持有事件对象，并且在其 post 的时候将其 delete 掉，因此，<strong>我们必须在堆上创建 event 对象</strong>。当对象被发送之后，再试图访问 event 对象就会出现问题。</p>
<p>当控制权返回到主线程循环是，保存在事件队列中的所有事件都通过 notify() 函数发送出去。</p>
<p>事件会根据 post 的顺序进行处理。如果你想要改变事件的处理顺序，可以考虑为其指定一个优先级。默认的优先级是 Qt::NormalEventPriority。</p>
<p>这个函数是线程安全的。</p>
</li>
<li><p>Qt 还提供了一个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> QCoreApplication::sendPostedEvents(QObject *receiver,</span><br><span class="line">                                               <span class="keyword">int</span> event_type);</span><br></pre></td></tr></table></figure>
<p>这个函数的作用是，将事件队列中的接受者为 receiver，事件类似为 event_type 的所有事件立即发送给 receiver 进行处理。需要注意的是，来自窗口系统的事件并不由这个函数进行处理，而是 processEvent()。详细信息请参考 Qt API 手册。</p>
</li>
</ol>
<hr>
<p>现在，我们已经能够自定义事件对象，已经能够将事件发送出去，还剩下最后一步：<strong>处理自定义事件</strong>。同前面我们讲解的那些处理方法没有什么区别。我们可以重写 QObject::customEvent() 函数，该函数接收一个 QEvent 对象作为参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> QObject::customEvent(QEvent *event);</span><br></pre></td></tr></table></figure>
<p>我们可以通过转换 event 对象类型来判断不同的事件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CustomWidget::customEvent(QEvent *event) &#123;</span><br><span class="line">    CustomEvent *customEvent = <span class="keyword">static_cast</span>&lt;CustomEvent *&gt;(event);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，我们也可以在 event() 函数中直接处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> CustomWidget::event(QEvent *event) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;type() == MyCustomEventType) &#123;</span><br><span class="line">        CustomEvent *myEvent = <span class="keyword">static_cast</span>&lt;CustomEvent *&gt;(event);</span><br><span class="line">        <span class="comment">// processing...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::event(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="绘制系统"><a href="#绘制系统" class="headerlink" title="绘制系统"></a>绘制系统</h3><p>Qt 的绘图系统允许使用相同的 API 在屏幕和其它打印设备上进行绘制。整个绘图系统基于 QPainter，QPainterDevice 和 QPaintEngine 三个类。</p>
<ul>
<li><p>QPainter 用来执行绘制的操作；</p>
</li>
<li><p>QPaintDevice 是一个二维空间的抽象，这个二维空间允许 QPainter 在其上面进行绘制，也就是 QPainter 工作的空间；</p>
</li>
<li><p>QPaintEngine 提供了画笔（QPainter）在不同的设备上进行绘制的统一的接口。QPaintEngine 类应用于 QPainter 和 QPaintDevice 之间，通常对开发人员是透明的。除非你需要自定义一个设备，否则你是不需要关心 QPaintEngine 这个类的。</p>
</li>
</ul>
<p><strong>Qt 的绘图系统实际上是，使用 QPainter 在 QPainterDevice 上进行绘制，它们之间使用 QPaintEngine 进行通讯（也就是翻译 QPainter 的指令）。</strong></p>
<p>通过一个实例来介绍 QPainter 的使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//paintedwidget.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintedWidget</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PaintedWidget(QWidget *parent = <span class="number">0</span>);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//paintedwidget.cpp</span></span><br><span class="line">PaintedWidget::PaintedWidget(QWidget *parent) :</span><br><span class="line">    QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    resize(<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">    setWindowTitle(tr(<span class="string">"Paint Demo"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PaintedWidget::paintEvent(QPaintEvent *)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.drawLine(<span class="number">80</span>, <span class="number">100</span>, <span class="number">650</span>, <span class="number">500</span>);</span><br><span class="line">    painter.setPen(Qt::red);</span><br><span class="line">    painter.drawRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">400</span>);</span><br><span class="line">    painter.setPen(QPen(Qt::green, <span class="number">5</span>));</span><br><span class="line">    painter.setBrush(Qt::blue);</span><br><span class="line">    painter.drawEllipse(<span class="number">50</span>, <span class="number">150</span>, <span class="number">400</span>, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    PaintedWidget pa;</span><br><span class="line">    pa.show();</span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>注意我们重写了 QWidget 的 paintEvent() 函数。这或许是我们在理解了 Qt 事件系统之后首次实际应用。</p>
</li>
<li><p>首先，我们在栈上创建了一个 QPainter 对象，也就是说，每次运行 paintEvent() 函数的时候，都会重建这个 QPainter 对象。注意：由于我们每次重建 QPainter，因此第一次运行时所设置的画笔颜色、状态等，第二次再进入这个函数时就会全部丢失。有时候我们希望保存画笔状态，就必须自己保存数据，或者将 QPainter 作为类的成员变量。</p>
</li>
<li><p>QPainter 接收一个 QPaintDevice 指针作为参数。QPaintDevice 有很多子类，比如 QWidget、QPixmap、QPicture、QImage、QPrinter 等。现在我们希望画在这个组件，因此传入的是 this 指针。</p>
</li>
<li><p>QPainter 有很多以 draw 开头的函数，用于各种图形的绘制，比如这里的 drawLine()，drawRect() 以及 drawEllipse() 等。</p>
<p>​    当绘制轮廓线时，使用 QPainter 的 pen() 属性。比如，我们调用了 painter.setPen(Qt::red) 将 pen 设置为红色，则下面绘制的矩形具有红色的轮廓线。接下来，我们将 pen 修改为绿色，5 像素宽(painter.setPen(QPen(Qt::green, 5))），又设置了画刷为蓝色。这时候再调用 draw 函数，则是具有绿色 5 像素宽轮廓线、蓝色填充的椭圆。</p>
</li>
<li><p>可以看到直线是第一个绘制，位于最下一层；矩形是第二个绘制，在中间一层；椭圆是最后绘制，在最上层。</p>
</li>
</ul>
<p>如果了解 OpenGL，肯定听说过这么一句话：OpenGL 是一个状态机。所谓状态机，就是说，OpenGL 保存的只是各种状态。比如，将画笔颜色设置成红色，那么，除非你重新设置另外的颜色，它的颜色会一直是红色。QPainter 也是这样，它的状态不会自己恢复，除非你使用了各种设置函数。</p>
<p>正因为 QPainter 是一个状态机，才会引出我们前面曾经介绍过的一个细节问题：由于 paintEvent() 是需要重复进入的，因此，需要注意第二次进入时，QPainter 的状态是不是和第一次一致，否则的话可能会造成闪烁的现象。这个闪烁并不是由于双缓冲的问题，而是由于绘制状态的快速切换。</p>
<h4 id="画刷和画笔"><a href="#画刷和画笔" class="headerlink" title="画刷和画笔"></a>画刷和画笔</h4><p>QPen 和 QBrush</p>
<p><strong>QBrush</strong> 定义了 QPainter 的填充模式，具有样式、颜色、渐变以及纹理等属性。</p>
<ul>
<li><p>画刷的 style() 定义了填充的<strong>样式</strong>，使用 Qt::BrushStyle 枚举，默认值是 Qt::NoBrush，也就是不进行任何填充。</p>
<p><img src="http://118.25.53.128/Picture/Qt/brush-fill-pattern.png" alt="brush-fill-pattern"></p>
</li>
<li><p>画刷的 color() 定义了填充模式的<strong>颜色</strong>。这个颜色可以是 Qt 预定义的颜色常量，也就是 Qt::GlobalColor，也可以是任意 QColor 对象。</p>
</li>
<li><p>画刷的 gradient() 定义了<strong>渐变</strong>填充。这个属性只有在<em>样式</em>是 Qt::LinearGradientPattern、Qt::RadialGradientPattern 或者 Qt::ConicalGradientPattern 之一时才有效。渐变可以由 QGradient 对象表示。Qt 提供了三种渐变：QLinearGradient、QConicalGradient 和 QRadialGradient，它们都是 QGradient 的子类。我们可以使用如下代码片段来定义一个渐变的画刷：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRadialGradient <span class="title">gradient</span><span class="params">(<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line">gradient.setColorAt(<span class="number">0</span>, QColor::fromRgbF(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">gradient.setColorAt(<span class="number">1</span>, QColor::fromRgbF(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="function">QBrush <span class="title">brush</span><span class="params">(gradient)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当画刷样式是 Qt::TexturePattern 时，texture() 定义了用于填充的<strong>纹理</strong>。注意，即使你没有设置样式为 Qt::TexturePattern，当你调用 setTexture() 函数时，QBrush 会自动将 style() 设置为 Qt::TexturePattern。</p>
</li>
</ul>
<hr>
<p><strong>QPen</strong> 定义了用于 QPainter 应该怎样画线或者轮廓线。具有样式、宽度、画刷、笔帽样式和连接样式等属性。</p>
<ul>
<li><p><strong>画笔样式</strong> style() 定义了线的样式。</p>
<p><img src="http://118.25.53.128/Picture/Qt/pen-style.png" alt="pen-style"></p>
</li>
<li><p><strong>画笔宽度</strong> width() 或 widthF() 定义了画笔的宽。注意，不存在宽度为 0 的线。假设你设置 width 为 0，QPainter 依然会绘制出一条线，而这个线的宽度为 1 像素。</p>
</li>
<li><p><strong>画刷</strong> brush() 用于填充画笔所绘制的线条。</p>
</li>
<li><p><strong>笔帽样式</strong> capStyle() 定义了使用 QPainter 绘制的线的末端。</p>
<p><img src="http://118.25.53.128/Picture/Qt/cap-style-2.png" alt="cap-style-2"></p>
</li>
<li><p><strong>连接样式</strong> joinStyle() 定义了两条线如何连接起来。</p>
<p><img src="http://118.25.53.128/Picture/Qt/join-style-2.png" alt="join-style-2"></p>
</li>
</ul>
<p>默认的画笔属性是纯黑色，0 像素，方形笔帽（Qt::SquareCap），斜面型连接（Qt::BevelJoin）。</p>
<p>这么多参数既可以在构造时指定，也可以使用 set 函数指定，完全取决于你的习惯：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="function">QPen <span class="title">pen</span><span class="params">(Qt::green, <span class="number">3</span>, Qt::DashDotLine, Qt::RoundCap, Qt::RoundJoin)</span></span>;</span><br><span class="line">painter.setPen(pen);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">QPen pen;  <span class="comment">// creates a default pen</span></span><br><span class="line"></span><br><span class="line">pen.setStyle(Qt::DashDotLine);</span><br><span class="line">pen.setWidth(<span class="number">3</span>);</span><br><span class="line">pen.setBrush(Qt::green);</span><br><span class="line">pen.setCapStyle(Qt::RoundCap);</span><br><span class="line">pen.setJoinStyle(Qt::RoundJoin);</span><br><span class="line"></span><br><span class="line">painter.setPen(pen);</span><br></pre></td></tr></table></figure>
<p>可以使用 setDashPattern() 函数自定义样式。setDashPattern() 函数需要一个包含偶数个元素的列表，其中，奇数位置的元素代表线段长度；偶数位置的元素代表间隔长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QPen pen;</span><br><span class="line">QVector&lt;qreal&gt; dashes;</span><br><span class="line">qreal space = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">dashes &lt;&lt; <span class="number">1</span> &lt;&lt; space &lt;&lt; <span class="number">3</span> &lt;&lt; space &lt;&lt; <span class="number">9</span> &lt;&lt; space</span><br><span class="line">        &lt;&lt; <span class="number">27</span> &lt;&lt; space &lt;&lt; <span class="number">9</span> &lt;&lt; space;</span><br><span class="line"> </span><br><span class="line">pen.setDashPattern(dashes);</span><br><span class="line">painter.setPen(pen);</span><br></pre></td></tr></table></figure>
<p>效果如图所示：<img src="http://118.25.53.128/Picture/Qt/dash_pattern.jpg" alt="dash_pattern"></p>
<p>注意，我们前面说了，QPainter 也是一个状态机，这里我们所说的这些属性都是处于这个状态机之中的，因此，我们应该记得是否要将其保存下来或者是重新构建。</p>
<h4 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h4><p>我们在光栅图形显示器上绘制非水平、非垂直的直线或多边形边界时，或多或少会呈现锯齿状外观。这是因为直线和多边形的边界是连续的，而光栅则是由离散的点组成。在光栅显示设备上表现直线、多边形等，必须在离散位置采样。由于采样不充分重建后造成的信息失真，就叫走样；用于减少或消除这种效果的技术，就称为反走样。</p>
<p>反走样是图形学中的重要概念，用以防止通常所说的“锯齿”现象的出现。很多系统的绘图 API 里面都内置了有关反走样的算法，不过由于性能问题，默认一般是关闭的，Qt 也不例外。下面我们来看看代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PaintedWidget::paintEvent(QPaintEvent *)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.setPen(QPen(Qt::black, <span class="number">5</span>, Qt::DashDotLine, Qt::RoundCap));</span><br><span class="line">    painter.setBrush(Qt::yellow);</span><br><span class="line">    painter.drawEllipse(<span class="number">50</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">    painter.setRenderHint(QPainter::Antialiasing, <span class="literal">true</span>);</span><br><span class="line">    painter.setPen(QPen(Qt::black, <span class="number">5</span>, Qt::DashDotLine, Qt::RoundCap));</span><br><span class="line">    painter.setBrush(Qt::yellow);</span><br><span class="line">    painter.drawEllipse(<span class="number">300</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">150</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://118.25.53.128/Picture/Qt/qt-antialiasing.png" alt="qt-antialiasing"></p>
<p>第二个椭圆的绘制与第一个十分相似，唯一的区别是多了一句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">painter.setRenderHint(QPainter::Antialiasing, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>我们通过这条语句，将 Antialiasing 属性（也就是反走样）设置为 true。经过这句设置，我们就打开了<code>QPainter</code>的反走样功能。还记得我们曾经说过，<code>QPainter</code>是一个状态机，因此，只要这里我们打开了它，之后所有的代码都会是反走样绘制的了。</p>
<hr>
<p>由于反走样需要比较复杂的算法，在一些对图像质量要求不是很高的应用中，是不需要进行反走样的。为了提高效率，一般的图形绘制系统，如 Java2D、OpenGL 之类都是默认不进行反走样的。</p>
<p>虽然反走样比不反走样的图像质量高很多，但是，没有反走样的图形绘制还是有很大用处的。首先，就像前面说的一样，在一些对图像质量要求不高的环境下，或者说性能受限的环境下，比如嵌入式和手机环境，一般是不进行反走样的。另外，在一些必须精确操作像素的应用中，也是不能进行反走样的。这是由于反走样技术本身的限制的。请看下面的图片：</p>
<p><img src="http://118.25.53.128/Picture/Qt/ps-points.png" alt="ps-points"></p>
<p>这是使用 Photoshop 的铅笔和画笔工具绘制的 1 像素的点，放大 3200% 的视图。在一定程度上，我们可以认为，Photoshop 的铅笔工具是不进行反走样，而画笔是要进行反走样的。在放大的情况下就会知道，有反走样的情况下是不能进行精确到 1 像素的操作的。因为反走样很难让你控制到 1 个像素。这不是 Photoshop 画笔工具的缺陷，而是反走样算法的问题。反走样之所以看起来比较模糊，就是因为它需要以一种近似色来替换原始的像素色，这样一来就会显得模糊而圆滑。</p>
<h4 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h4><p>渐变是绘图中很常见的一种功能，可以把几种颜色混合在一起，让它们能够自然地过渡，而不是一下子变成另一种颜色。渐变的算法比较复杂，写得不好的话效率会很低，好在很多绘图系统都内置了渐变的功能，Qt 也不例外。渐变一般是用在填充里面的，所以，设置渐变是在QBrush里面。</p>
<p>Qt 提供了三种渐变：线性渐变（QLinearGradient）、辐射渐变（QRadialGradient）和角度渐变（QConicalGradient）。我们可以在 Qt API 手册中看到这几种渐变的区别：</p>
<p><img src="http://118.25.53.128/Picture/Qt/QLinearGradient.png" alt="QLinearGradient"></p>
<p><img src="http://118.25.53.128/Picture/Qt/QRadialGradient.png" alt="QRadialGradient"></p>
<p><img src="http://118.25.53.128/Picture/Qt/QConicalGradient.png" alt="QConicalGradient"></p>
<hr>
<p>下面我们通过一个示例看看如何使用渐变进行填充：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PaintedWidget::paintEvent(QPaintEvent *)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.setRenderHint(QPainter::Antialiasing, <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function">QLinearGradient <span class="title">linearGradient</span><span class="params">(<span class="number">60</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">    linearGradient.setColorAt(<span class="number">0.2</span>, Qt::white);</span><br><span class="line">    linearGradient.setColorAt(<span class="number">0.6</span>, Qt::green);</span><br><span class="line">    linearGradient.setColorAt(<span class="number">1.0</span>, Qt::black);</span><br><span class="line">    </span><br><span class="line">    painter.setBrush(QBrush(linearGradient));</span><br><span class="line">    painter.drawEllipse(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">150</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://118.25.53.128/Picture/Qt/gradient-demo.png" alt="gradient-demo"></p>
<p>首先我们打开了反走样，然后创建一个QLinearGradient对象实例。QLinearGradient也就是线性渐变，其构造函数有四个参数，分别是 x1，y1，x2，y2，即渐变的起始点和终止点。在这里，我们从 (60, 50) 点开始渐变，到 (200, 200) 点止。渐变的颜色是在 setColorAt() 函数中指定的。下面是这个函数的签名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> QGradient::setColorAt ( qreal position, <span class="keyword">const</span> QColor &amp; color )</span><br></pre></td></tr></table></figure>
<p>这个函数的作用是，把 position 位置的颜色设置成 color。其中，position 是一个 [0, 1] 闭区间的数字，是相对于我们建立渐变对象时做的那个起始点和终止点区间的一个比例。</p>
<hr>
<p>下面绘制一个<strong>色轮</strong>（color wheel）：</p>
<p><img src="http://118.25.53.128/Picture/Qt/color-wheel.png" alt="color-wheel"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ColorWheel::paintEvent(QPaintEvent *)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.setRenderHint(QPainter::Antialiasing);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> r = <span class="number">150</span>;</span><br><span class="line">    <span class="function">QConicalGradient <span class="title">conicalGradient</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    conicalGradient.setColorAt(<span class="number">0.0</span>, Qt::red);</span><br><span class="line">    conicalGradient.setColorAt(<span class="number">60.0</span>/<span class="number">360.0</span>, Qt::yellow);</span><br><span class="line">    conicalGradient.setColorAt(<span class="number">120.0</span>/<span class="number">360.0</span>, Qt::green);</span><br><span class="line">    conicalGradient.setColorAt(<span class="number">180.0</span>/<span class="number">360.0</span>, Qt::cyan);</span><br><span class="line">    conicalGradient.setColorAt(<span class="number">240.0</span>/<span class="number">360.0</span>, Qt::blue);</span><br><span class="line">    conicalGradient.setColorAt(<span class="number">300.0</span>/<span class="number">360.0</span>, Qt::magenta);</span><br><span class="line">    conicalGradient.setColorAt(<span class="number">1.0</span>, Qt::red);</span><br><span class="line"></span><br><span class="line">    painter.translate(r, r);</span><br><span class="line"></span><br><span class="line">    <span class="function">QBrush <span class="title">brush</span><span class="params">(conicalGradient)</span></span>;</span><br><span class="line">    painter.setPen(Qt::NoPen);</span><br><span class="line">    painter.setBrush(brush);</span><br><span class="line">    painter.drawEllipse(QPoint(<span class="number">0</span>, <span class="number">0</span>), r, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>首先我们打开了反走样，然后创建一个QConicalGradient对象实例。QConicalGradient也就是角度渐变，其构造函数有三个参数，前两个参数 cx 和 cy 组成角度渐变的中心点，第三个参数是渐变的起始角度。</p>
</li>
<li><p>类似线性渐变，角度渐变的<code>setColorAt()</code>函数同样接受两个参数，第一个是角度比例，第二个是颜色。</p>
<p><em>至于颜色的分布，这是由颜色空间定义的，有兴趣的朋友可以查阅有关颜色模型的理论。</em></p>
</li>
<li><p><code>QPainter::translate(x, y)</code> 将坐标系的原点设置到 (x, y) 点。原本坐标系原点位于左上角，我们使用translate(r, r)，将坐标原点设置为 (r, r)。这么一来，左上角的点的坐标就应该是 (-r, -r)。</p>
</li>
<li><p>最后，我们使用<code>drawEllipse()</code>函数绘制圆盘。由于我们已经把坐标原点设置为 (r, r)，因此，在绘制时，圆心应该是新的坐标 (0, 0)，而不是原来的 (r, r)。</p>
</li>
</ul>
<p>如果去掉 translate() 函数的调用，不仅需要修改最后的绘制语句，还要修改 QConicalGradient 定义时传入的中心点的坐标。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function">QConicalGradient <span class="title">conicalGradient</span><span class="params">(r, r, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">painter.drawEllipse(QPoint(r, r), r, r);</span><br></pre></td></tr></table></figure>
<h4 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h4><p>由于QPaintDeice 是进行绘制的对象，因此，所谓坐标系统，也就是QPaintDevice 上面的坐标。默认坐标系统位于设备的左上角，也就是坐标原点 (0, 0)。x 轴方向向右；y 轴方向向下。在基于像素的设备上（比如显示器），坐标的默认单位是像素，在打印机上则是点（1/72 英寸）。</p>
<p>将QPainter 的逻辑坐标与QPaintDevice 的物理坐标进行映射的工作，是由QPainter 的变换矩阵（transformation matrix）、视口（viewport）和窗口（window）完成的。如果你不理解这些术语，可以简单了解下有关图形学的内容。实际上，对图形的操作，底层的数学都是进行的矩阵变换、相乘等运算。</p>
<p>在 Qt 的坐标系统中，每个像素占据 1×1 的空间。你可以把它想象成一张方格纸，每个小格都是1个像素。<strong>方格的焦点定义了坐标，也就是说，像素 (x, y) 的中心位置其实是在 (x + 0.5, y + 0.5) 的位置上。</strong>这个坐标系统实际上是一个“<strong>半像素坐标系</strong>”。我们可以通过下面的示意图来理解这种坐标系：</p>
<p><img src="http://118.25.53.128/Picture/Qt/coordinate-system-demo.png" alt="coordinate-system-demo"></p>
<p><strong>注意，这是坐标的逻辑表示，实际绘制则与此不同。</strong>因为在实际设备上，像素是最小单位，我们不能像上面一样，在两个像素之间进行绘制。所以在实际绘制时，Qt 的定义是，绘制点所在像素是逻辑定义点的右下方的像素：</p>
<p><img src="http://118.25.53.128/Picture/Qt/coordinate-system-demo.png" alt="coordinate-system-demo"></p>
<p><strong>当绘制大于1个像素时</strong>，情况比较复杂：如果绘制<strong>像素是偶数</strong>，则会将逻辑坐标值夹在相等的两部分像素之间；如果是<strong>奇数</strong>，则会在右下方多出一个像素。具体请看下面的图示：</p>
<p><img src="http://118.25.53.128/Picture/Qt/mutilpx-painting.png" alt="mutilpx-painting"></p>
<p>Qt 的这种处理，带来的一个问题是，我们可能获取不到真实的坐标值。由于历史原因，QRect::right() 和QRect::bottom() 的返回值并不是矩形右下角点的真实坐标值：QRect::right() 返回的是 left() + width() – 1；QRect::bottom() 则返回 top() + height() – 1，上图的绿色点指出了这两个函数的返回点的坐标。</p>
<p>为避免这个问题，我们建议是使用 QRectF。QRectF 使用浮点值，而不是整数值，来描述坐标。这个类的两个函数 QRectF::right() 和 QRectF::bottom() 是正确的。如果你不得不使用 QRect，那么可以利用 x() + width() 和 y() + height() 来替代 right() 和 bottom() 函数。</p>
<p>对于反走样，实际绘制会包裹住逻辑坐标值：</p>
<p><img src="http://118.25.53.128/Picture/Qt/anti-aliasing-painting.png" alt="anti-aliasing-painting"></p>
<hr>
<p>Qt 同样提供了坐标变换。每一种变换都对应着一个矩阵乘法。</p>
<p>前面说过，QPainter 是一个状态机。那么，有时我想保存下当前的状态：当我临时绘制某些图像时，就可能想这么做。当然，我们有最原始的办法：将可能改变的状态，比如画笔颜色、粗细等，在临时绘制结束之后再全部恢复。对此，QPainter 提供了内置的函数：save() 和 restore()。save() 就是保存下当前状态；restore() 则恢复上一次保存的结果。这两个函数<strong>必须</strong>成对出现：QPainter 使用<strong>栈</strong>来保存数据，每一次 save()，将当前状态压入栈顶，restore() 则弹出栈顶进行恢复。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PaintDemo::paintEvent(QPaintEvent *)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>, Qt::red);</span><br><span class="line">    </span><br><span class="line">    painter.save();</span><br><span class="line">    painter.translate(<span class="number">100</span>, <span class="number">0</span>); <span class="comment">// 向右平移 100px</span></span><br><span class="line">    painter.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>, Qt::yellow);</span><br><span class="line">    painter.restore();</span><br><span class="line">    </span><br><span class="line">    painter.save();</span><br><span class="line">    painter.translate(<span class="number">300</span>, <span class="number">0</span>); <span class="comment">// 向右平移 300px</span></span><br><span class="line">    painter.rotate(<span class="number">30</span>); <span class="comment">// 顺时针旋转 30 度</span></span><br><span class="line">    painter.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>, Qt::green);</span><br><span class="line">    painter.restore();</span><br><span class="line">    </span><br><span class="line">    painter.save();</span><br><span class="line">    painter.translate(<span class="number">400</span>, <span class="number">0</span>); <span class="comment">// 向右平移 400px</span></span><br><span class="line">    painter.scale(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 横坐标单位放大 2 倍，纵坐标放大 3 倍</span></span><br><span class="line">    painter.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>, Qt::blue);</span><br><span class="line">    painter.restore();</span><br><span class="line">    </span><br><span class="line">    painter.save();</span><br><span class="line">    painter.translate(<span class="number">600</span>, <span class="number">0</span>); <span class="comment">// 向右平移 600px</span></span><br><span class="line">    painter.shear(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 横向不变，纵向扭曲 1 倍</span></span><br><span class="line">    painter.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>, Qt::cyan);</span><br><span class="line">    painter.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://118.25.53.128/Picture/Qt/coordinate-transformations-demo.png" alt="coordinate-transformations-demo"></p>
<p>注意：所有这些操作都是针对坐标系的，因此在绘制时，我们提供的矩形的坐标参数都是不变的。</p>
<hr>
<p>Qt 的坐标分为<strong>逻辑坐标</strong>和<strong>物理坐标</strong>。在我们绘制时，提供给QPainter 的都是逻辑坐标。之前我们看到的坐标变换，也是针对逻辑坐标的。所谓物理坐标，就是绘制底层QPaintDevice 的坐标。要想在设备上绘制，必须提供设备认识的物理坐标。Qt 使用 viewport-window 机制将我们提供的逻辑坐标转换成绘制设备使用的物理坐标，方法是，在逻辑坐标和物理坐标之间提供一层“窗口”坐标。视口是由任意矩形指定的物理坐标；窗口则是该矩形的逻辑坐标表示。默认情况下，物理坐标和逻辑坐标是一致的，都等于设备矩形。</p>
<p>视口坐标（也就是物理坐标）和窗口坐标是一个简单的线性变换。</p>
<p>比如一个 400×400 的<strong>窗口</strong>，我们添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PaintDemo::paintEvent(QPaintEvent *)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.setWindow(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    painter.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>, Qt::red);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将窗口矩形设置为左上角坐标为 (0, 0)，长和宽都是 200px。我们可以理解成，逻辑坐标被“重新分配”。这段代码的运行结果是将整个窗口进行了填充。</p>
<p>试比较下面两行代码的区别（还是 400×400 的窗口）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">painter.translate(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">painter.setWindow(<span class="number">-160</span>, <span class="number">-320</span>, <span class="number">320</span>, <span class="number">640</span>);</span><br></pre></td></tr></table></figure>
<p>第一行代码，我们将坐标原点设置到 (200, 200) 处，横坐标范围是 [-200, 200]，纵坐标范围是 [-200, 200]。第二行代码，坐标原点也是在窗口正中心，但是，我们将物理宽 400px 映射成窗口宽 320px，物理高 400px 映射成窗口高 640px，此时，横坐标范围是 [-160, 160]，纵坐标范围是 [-320, 320]。</p>
<p>这种变换是简单的线性变换。假设原来有个点坐标是 (64， 60)，那么新的窗口坐标下对应的坐标应该是 ((-160 + 64 <em> 320 / 400), (-320 + 60 </em> 640 / 400)) = (-108.8, -224)。</p>
<hr>
<p>下面我们再来理解下<strong>视口</strong>的含义。还是以一段代码为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PaintDemo::paintEvent(QPaintEvent *)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.setViewport(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    painter.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>, Qt::red);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码和前面一样，只是把setWindow() 换成了setViewport()。</p>
<p>前面我们说过，window 代表窗口坐标，viewport 代表物理坐标。也就是说，我们将物理坐标区域定义为左上角位于 (0, 0)，长高都是 200px 的矩形。然后还是绘制和上面一样的矩形。</p>
<p>只有 1/16 的窗口被填充。这是由于，我们修改了物理坐标，但是没有修改相应的窗口坐标。默认的逻辑坐标范围是左上角坐标为 (0, 0)，长宽都是 400px 的矩形。当我们将物理坐标修改为左上角位于 (0, 0)，长高都是 200px 的矩形时，窗口坐标范围不变，也就是说，我们将物理宽 200px 映射成窗口宽 400px，物理高 200px 映射成窗口高 400px，所以，原始点 (200, 200) 的坐标变成了 ((0 + 200 <em> 200 / 400), (0 + 200 </em> 200 / 400)) = (100, 100)。</p>
<p>现在我们可以用一张图示总结一下逻辑坐标、窗口坐标和物理坐标之间的关系：</p>
<p><img src="http://118.25.53.128/Picture/Qt/coordinate-system-instruction.png" alt="coordinate-system-instruction"></p>
<p>我们传给QPainter 的是逻辑坐标（也称为世界坐标），逻辑坐标可以通过变换矩阵转换成窗口坐标，窗口坐标通过 window-viewport 转换成物理坐标（也就是设备坐标）。</p>
<h4 id="绘制设备"><a href="#绘制设备" class="headerlink" title="绘制设备"></a>绘制设备</h4><p>绘图设备是继承QPainterDevice的类。QPaintDevice就是能够进行绘制的类，也就是说，QPainter可以在任何QPaintDevice的子类上进行绘制。现在，Qt 提供了若干这样的类：</p>
<p><img src="http://118.25.53.128/Picture/Qt/paint-device-qt5.png" alt="paint-device-qt5"></p>
<p>上面的是 Qt4/Qt5 的相关类图，只是在 Qt5 中，QGLPixelBuffer已经被废弃。本章我们关注的是QPixmap、QBitmap、QImage和QPicture这几个类。另外的部分，QWidget就是所有组件的父类，我们已经在前面的章节中使用过。QGLWidget和QGLFramebufferObject，顾名思义，就是关于 OpenGL 的相关类。在 Qt 中，我们可以方便地结合 OpenGL 进行绘制。由于这部分需要牵扯到 OpenGL 的相关内容，现在也不再深入。在我们选择的几个类中，大多与图像密切相关。</p>
<p>QPixmap专门为图像在屏幕上的显示做了优化；QBitmap是QPixmap的一个子类，它的色深限定为1，你可以使用QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap。QImage专门为图像的像素级访问做了优化。QPicture则可以记录和重现QPainter的各条命令。下面我们将分两部分介绍这四种绘图设备。</p>
<hr>
<p><code>QPixmap</code>继承了QPaintDevice，因此，你可以使用QPainter直接在上面绘制图形。</p>
<p>QPixmap也可以接受一个字符串作为一个文件的路径来显示这个文件，比如你想在程序之中打开 png、jpeg 之类的文件，就可以使用QPixmap。</p>
<p>使用QPainter::drawPixmap()函数可以把这个文件绘制到一个QLabel、QPushButton或者其他的设备上面。</p>
<p>正如前面所说的那样，QPixmap是针对屏幕进行特殊优化的，因此，它与实际的底层显示设备息息相关。注意，这里说的显示设备并不是硬件，而是操作系统提供的原生的绘图引擎。所以，在不同的操作系统平台下，QPixmap的显示可能会有所差别。</p>
<p>QPixmap提供了静态的grabWidget()和grabWindow()函数，用于将自身图像绘制到目标上。同时，在使用QPixmap时，你可以直接使用<strong>传值</strong>的形式，不需要传指针，因为QPixmap提供了“隐式数据共享”。关于这一点，我们会在以后的章节中详细描述。简单来说，就是一般对于大型数据（图像无疑就是这种“大型数据”），为性能起见，通常会采用传指针的方式，但是由于QPixmap内置了隐式数据共享，所以只要传递QPixmap。</p>
<p><code>QBitmap</code>继承自QPixmap，因此具有QPixmap的所有特性。不同之处在于，QBitmap的色深始终为 1，即黑和白。所以说，QBitmap实际上是只有黑白两色的图像数据。由于QBitmap色深小，因此只占用很少的存储空间，所以适合做光标文件和笔刷。（色深这个概念来自计算机图形学，是指用于表现颜色的二进制的位数。我们知道，计算机里面的数据都是使用二进制表示的。为了表示一种颜色，我们也会使用二进制。比如我们要表示 8 种颜色，需要用 3 个二进制位，这时我们就说色深是 3。因此，所谓色深为 1，也就是使用 1 个二进制位表示颜色。1 个位只有两种状态：0 和 1，因此它所表示的颜色就有两种，黑和白。）</p>
<p>下面我们来看同一个图像文件在QPixmap 和QBitmap 下的不同表现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PaintedWidget::paintEvent(QPaintEvent *)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">"qt-logo.png"</span>)</span></span>;</span><br><span class="line">    <span class="function">QBitmap <span class="title">bitmap</span><span class="params">(<span class="string">"qt-logo.png"</span>)</span></span>;</span><br><span class="line">    painter.drawPixmap(<span class="number">10</span>, <span class="number">10</span>, <span class="number">250</span>, <span class="number">125</span>, pixmap);</span><br><span class="line">    painter.drawPixmap(<span class="number">270</span>, <span class="number">10</span>, <span class="number">250</span>, <span class="number">125</span>, bitmap);</span><br><span class="line">    <span class="function">QPixmap <span class="title">whitePixmap</span><span class="params">(<span class="string">"qt-logo-white.png"</span>)</span></span>;</span><br><span class="line">    <span class="function">QBitmap <span class="title">whiteBitmap</span><span class="params">(<span class="string">"qt-logo-white.png"</span>)</span></span>;</span><br><span class="line">    painter.drawPixmap(<span class="number">10</span>, <span class="number">140</span>, <span class="number">250</span>, <span class="number">125</span>, whitePixmap);</span><br><span class="line">    painter.drawPixmap(<span class="number">270</span>, <span class="number">140</span>, <span class="number">250</span>, <span class="number">125</span>, whiteBitmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://118.25.53.128/Picture/Qt/qpixmap-qbitmap-demo.png" alt="qpixmap-qbitmap-demo"></p>
<p>这里我们给出了两张 png 图片。qt-logo.png 具有透明背景，qt-logo-white.png 具有白色背景。我们分别使用QPixmap和QBitmap来加载它们。注意看它们的区别：白色的背景在QBitmap中消失了，而透明色在QBitmap中转换成了黑色；其他颜色则是使用点的疏密程度来体现的。</p>
<hr>
<p><code>QPixmap</code>使用底层平台的绘制系统进行绘制，无法提供像素级别的操作，而<code>QImage</code>则是使用独立于硬件的绘制系统，因此提供了<strong>像素级别的操作</strong>，并且能够在不同系统之上提供一个一致的显示形式。</p>
<p><img src="http://118.25.53.128/Picture/Qt/qimage-32bit.png" alt="qimage-32bit"></p>
<p>QImage与QPixmap相比，最大的优势在于能够进行像素级别的操作。我们通过上面的示意图可以看到，我们声明一个 3 x 3 像素的QImage对象，然后利用setPixel()函数进行颜色的设置。你可以把QImage想象成一个 RGB 颜色的二维数组，记录了每一像素的颜色。</p>
<hr>
<p>最后一种<code>QPicture</code>是平台无关的，因此它可以使用在多种设备之上，比如 svg、pdf、ps、打印机或者屏幕。QPicture使用系统分辨率，并且可以调整QPainter来消除不同设备之间的显示差异。</p>
<p><strong>如果我们要记录</strong>下QPainter的命令，首先要使用QPainter::begin()函数，将QPicture实例作为参数传递进去，以便告诉系统开始记录，记录完毕后使用QPainter::end()命令终止。代码示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QPicture picture;</span><br><span class="line">QPainter painter;</span><br><span class="line">painter.begin(&amp;picture);             <span class="comment">// 在 picture 进行绘制</span></span><br><span class="line">painter.drawEllipse(<span class="number">10</span>, <span class="number">20</span>, <span class="number">80</span>, <span class="number">70</span>); <span class="comment">// 绘制一个椭圆</span></span><br><span class="line">painter.end();                       <span class="comment">// 绘制完成</span></span><br><span class="line">picture.save(<span class="string">"drawing.pic"</span>);         <span class="comment">// 保存 picture</span></span><br></pre></td></tr></table></figure>
<p>如果我们要重现命令，首先要使用 QPicture::load() 函数进行装载：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QPicture picture;</span><br><span class="line">picture.load(<span class="string">"drawing.pic"</span>);           <span class="comment">// 加载 picture</span></span><br><span class="line">QPainter painter;</span><br><span class="line">painter.begin(&amp;myImage);               <span class="comment">// 在 myImage 上开始绘制</span></span><br><span class="line">painter.drawPicture(<span class="number">0</span>, <span class="number">0</span>, picture);    <span class="comment">// 在 (0, 0) 点开始绘制 picture</span></span><br><span class="line">painter.end();                         <span class="comment">// 绘制完成</span></span><br></pre></td></tr></table></figure>
<p>我们也可以直接使用<code>QPicture::play()</code>进行绘制。这个函数接受一个<code>QPainter</code>对象，也就是进行绘制的画笔。</p>
<h4 id="Graphics-View-Framework"><a href="#Graphics-View-Framework" class="headerlink" title="Graphics View Framework"></a>Graphics View Framework</h4><p>Graphics View 提供了一种接口，用于管理大量自定义的 2D 图形元素，并与之进行交互；还提供了用于将这些元素进行可视化显示的观察组件，并支持缩放和旋转。我们通常所说的 Linux 的 KDE 桌面环境，就是建立在 Graphics View 基础之上的（尽管新版本的 KDE 有向 QML 迁移的趋势）。</p>
<p>Graphics View 框架包含了一套完整的事件体系，可以用于与场景中的元素进行双精度的交互。这些元素同样支持键盘事件、鼠标事件等。Graphics View 使用了 BSP 树（Binary Space Partitioning tree，这是一种被广泛应用于图形学方面的数据结构）来提供非常快速的元素发现，也正因为如此，才能够实现一种上百万数量级元素的实时显示机制。</p>
<p>Graphics View 是一个基于元素（item）的 MV 架构的框架。它可以分成三个部分：<strong>元素 item</strong>、<strong>场景 scene</strong> 、<strong>视图 view</strong>：</p>
<ul>
<li><code>QGraphicsScene</code>：能够管理元素的非 GUI 容器；</li>
<li><code>QGraphicsItem</code>：能够被添加到场景的元素；</li>
<li><code>QGraphicsView</code>：能够观察场景的可视化组件视图。</li>
</ul>
<p>基于元素的意思是，它的每一个组件都是一个独立的元素。这是与我们之前讲到过的<code>QPainter</code>状态机机制不同。使用<code>QPainter</code>绘图，大多是采用一种面向过程的描述方式：首先使用<code>drawLine()</code>画一条直线，然后使用<code>drawPolygon()</code>画一个多边形。</p>
<p>对于 Graphics View，首先创建一个场景（scene），然后创建一个直线对象和一个多边形对象，再使用场景的<code>add()</code>函数，将直线和多边形添加到场景中，最后通过视图进行观察，就可以看到了。乍看起来，后者似乎更加复杂，但是，如果你的图像中包含了成千上万的直线、多边形之类，管理这些对象要比管理<code>QPainter</code>的绘制语句容易得多。并且，<strong>这些图形对象也更加符合面向对象的设计要求</strong>：一个很复杂的图形可以很方便的复用。</p>
<p>MV 架构的意思是，Graphics View 提供一个 model 和一个 view（正如 MVC 架构，只不过 MV 架构少了 C 这么一个组件）。所谓模型（model）就是我们添加的种种对象；所谓视图（view）就是我们观察这些对象的视口。<strong>同一个模型可以由很多视图从不同的角度进行观察</strong>，这是很常见的需求。使用 QPainter 很难实现这一点，这需要很复杂的计算，而 Graphics View 可以很容易的实现。</p>
<p>Graphics View 提供了<code>QGraphicsScene</code>作为场景，即是允许我们添加图形的空间，相当于整个世界；<code>QGraphicsView</code>作为视口，也就是我们的观察窗口，相当于照相机的取景框，这个取景框可以覆盖整个场景，也可以是场景的一部分；<code>QGraphicsItem</code>作为图形元件，以便添加到场景中去，Qt 内置了很多图形，比如直线、多边形等，它们都是继承自<code>QGraphicsItem</code>。</p>
<p>下面我们通过一段代码看看 Graphics View 的使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QGraphicsScene scene;</span><br><span class="line">    scene.addLine(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">QGraphicsView <span class="title">view</span><span class="params">(&amp;scene)</span></span>;</span><br><span class="line">    view.setWindowTitle(<span class="string">"Graphics View"</span>);</span><br><span class="line">    view.resize(<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">    view.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很简单：首先创建一个场景，也就是QGraphicsScene 对象。然后我们使用addLine() 函数向场景中添加了一个直线，起始点和终点坐标分别是 (0, 0) 和 (150, 150)。通过这两步，我们已经有了场景和元素。之后，我们创建一个GraphicsView 对象，绑定到一个场景上。注意，QGraphicsScene 不是QWidget 的子类，因此该构造函数并不是调用的QGraphicsView(QWidget *parent) 。</p>
<p>我们看到，这个直线自动在视图居中显示。这并不需要我们进行任何额外的代码。如果不想这么做，我们可以给 scene 设置一下 sceneRect() 属性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QGraphicsScene scene;</span><br><span class="line">scene.setSceneRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">scene.addLine(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">QGraphicsView <span class="title">view</span><span class="params">(&amp;scene)</span></span>;</span><br><span class="line">view.setWindowTitle(<span class="string">"Graphics View"</span>);</span><br><span class="line"><span class="comment">// view.resize(500, 500);</span></span><br><span class="line">view.show();</span><br></pre></td></tr></table></figure>
<p>不仅如此，我们还去掉了<code>view.resize()</code>一行。<strong>QGraphicsScene 的sceneRect 属性供QGraphicsView 确定视图默认的滚动条区域</strong>，并且协助QGraphicsScene 管理元素索引。之所以去掉<code>view.resize()</code>一行，是因为我们让系统去决定视图的最小尺寸（如果不是过大，就是设置的300）。</p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/QT/">QT</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/QT/">QT</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-QT/QString" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/01/04/QT/QString/" class="article-date">
      <time datetime="2019-01-04T08:40:30.000Z" itemprop="datePublished">2019-01-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/04/QT/QString/">QString与char*的相互转换</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="QString-转换为-char"><a href="#QString-转换为-char" class="headerlink" title="QString 转换为 char *"></a>QString 转换为 char *</h3><p>将 QString 转 char <em>，需要用到 QByteArray 类，QByteArray 类的说明详见 Qt 帮助文档。<br>因为 char </em> 最后都有一个<code>&#39;\0&#39;</code>作为结束符，而采用 QString::toLatin1() 时会在字符串后面加上<code>&#39;\0&#39;</code>。</p>
<p>方法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QString  qstr;</span><br><span class="line"><span class="keyword">char</span>*  cstr;</span><br><span class="line">QByteArray ba = qstr.toLatin1(); <span class="comment">// must</span></span><br><span class="line">cstr = ba.data();</span><br></pre></td></tr></table></figure>
<h4 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码　"></a>中文乱码　</h4><p>以上方法当 QString 内含有中文时，转换为 char * 就是乱码，采用如下方法解决：</p>
<p><strong>方法1</strong></p>
<p>添加GBK编码支持：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTextCodec&gt;</span></span></span><br><span class="line">QTextCodec::setCodecForTr(QTextCodec::codecForName(<span class="string">"GBK"</span>));</span><br><span class="line">QTextCodec::setCodecForLocale(QTextCodec::codecForName(<span class="string">"GBK"</span>));</span><br></pre></td></tr></table></figure>
<p>然后将上面的第3行修改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QByteArray ba = str.toLocal8Bit();  <span class="comment">// toLocal8Bit 支持中文</span></span><br></pre></td></tr></table></figure>
<p><strong>方法2</strong></p>
<p>先将 QString 转为标准库中的 string 类型，然后将 string 转为 char *。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString  filename;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = filename.toStdString();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ch = str.c_str();</span><br></pre></td></tr></table></figure>
<h3 id="char-转换为-QString"><a href="#char-转换为-QString" class="headerlink" title="char * 转换为 QString"></a>char * 转换为 QString</h3><p>使用 QString 的构造函数进行转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString(const QLatin1String &amp;str);</span><br></pre></td></tr></table></figure>
<p>QLatin1String 的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QLatin1String(const char *str);</span><br></pre></td></tr></table></figure>
<p>因此用下面这个语句就可以将 char * ch 转换为 QString str 了，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = QString(QLatin1String(ch));</span><br></pre></td></tr></table></figure>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><strong>arg()</strong></p>
<p>QString 的 arg() 函数可以自动替换掉 QString 中出现的占位符。其占位符以 % 开始，后面是占位符的位置，例如 %1，%2 这种。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString(<span class="string">"[%1, %2]"</span>).arg(x, y);</span><br></pre></td></tr></table></figure>
<p><strong>sprintf()</strong></p>
<p>可以使用类似 C 风格的格式化函数 sprintf() 来构造 QString。</p>
<p><strong>QString::number(long n, int base = 10)</strong></p>
<p>将数字转化为QString</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/QT/">QT</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/QT/">QT</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Algorithm/排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/28/Algorithm/排序算法/" class="article-date">
      <time datetime="2018-12-28T14:19:14.000Z" itemprop="datePublished">2018-12-28</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/28/Algorithm/排序算法/">排序算法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="O-NlogN"><a href="#O-NlogN" class="headerlink" title="O(NlogN)"></a>O(NlogN)</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,t,temp;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    temp=a[left];</span><br><span class="line">    i=left;</span><br><span class="line">    j=right;</span><br><span class="line">    <span class="keyword">while</span>(i!=j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[j]&gt;=temp &amp;&amp; i&lt;j)</span><br><span class="line">            --j;</span><br><span class="line">        <span class="keyword">while</span>(a[i]&lt;=temp &amp;&amp; i&lt;j)</span><br><span class="line">            ++i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">            t=a[i];</span><br><span class="line">            a[i]=a[j];</span><br><span class="line">            a[j]=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[left]=a[i];</span><br><span class="line">    a[i]=temp;</span><br><span class="line"></span><br><span class="line">    quicksort(left, i<span class="number">-1</span>);</span><br><span class="line">    quicksort(i+<span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释版</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平均时间复杂度 O(NlogN)，最差O(N^2)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,t,temp;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    temp=a[left];	<span class="comment">//存基准数</span></span><br><span class="line">    i=left;</span><br><span class="line">    j=right;</span><br><span class="line">    <span class="keyword">while</span>(i!=j)&#123;</span><br><span class="line">        <span class="comment">//顺序很重要，先从右往左找，因为要最后停在比基准数小的地方(，然后和基准数交换)</span></span><br><span class="line">        <span class="comment">//找到比基准数小的</span></span><br><span class="line">        <span class="keyword">while</span>(a[j]&gt;=temp &amp;&amp; i&lt;j)</span><br><span class="line">            --j;</span><br><span class="line">        <span class="comment">//找到比基准数大的</span></span><br><span class="line">        <span class="keyword">while</span>(a[i]&lt;=temp &amp;&amp; i&lt;j)</span><br><span class="line">            ++i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果没有相遇时，交换位置</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">            t=a[i];</span><br><span class="line">            a[i]=a[j];</span><br><span class="line">            a[j]=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面三行代码交换 最左处的基准数 和 相遇位置(这个数比基准数小)</span></span><br><span class="line">    <span class="comment">//temp=a[left]; 存基准数时已经写了</span></span><br><span class="line">    a[left]=a[i];</span><br><span class="line">    a[i]=temp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此时基准数归位，基准数左边的都小于基准数右边的</span></span><br><span class="line">    quicksort(left, i<span class="number">-1</span>);	<span class="comment">//继续处理左边</span></span><br><span class="line">    quicksort(i+<span class="number">1</span>, right);	<span class="comment">//继续处理右边</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">quicksort(<span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行例子</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 6 1 2 7 9 3 4 5 10 8</span></span><br><span class="line"><span class="comment"> 3 1 2 5 4(6)9 7 10 8</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 2 1(3)5 4 6 9 7 10 8</span></span><br><span class="line"><span class="comment"> 1(2)3 5 4 6 9 7 10 8</span></span><br><span class="line"><span class="comment">(1)2 3 5 4 6 9 7 10 8</span></span><br><span class="line"><span class="comment"> 1 2 3 4(5)6 9 7 10 8</span></span><br><span class="line"><span class="comment"> 1 2 3(4)5 6 9 7 10 8</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 1 2 3 4 5 6 8 7 (9)10</span></span><br><span class="line"><span class="comment"> 1 2 3 4 5 6 7(8) 9 10</span></span><br><span class="line"><span class="comment"> 1 2 3 4 5 6(7)8  9 10</span></span><br><span class="line"><span class="comment"> 1 2 3 4 5 6 7 8  9(10)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>见另一篇讲解堆的</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>将两个有序数列合并为一个有序数列，参见另一篇C++algorithm里的 inplace_merge.</p>
<p>归并排序的效率是比较高的，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(N*logN)。</p>
<p>因为归并排序每次都是在相邻的数据中进行操作，所以归并排序在O(N*logN)的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。但是归并排序需要额外的空间分配。</p>
<h2 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>每一趟从待排序的数据元素中选择最小（或最大）的一个元素移动到首元素，直到所有元素排完为止，简单选择排序是不稳定排序。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n个数排序，只需进行n-1趟</span></span><br><span class="line"><span class="comment">// 一趟将一个最小的数冒泡到最后</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n<span class="number">-1</span>-i; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j]&lt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">            t=a[j];</span><br><span class="line">            a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">            a[j+<span class="number">1</span>]=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>直接插入排序基本思想是每一步将一个待排序的记录，从后向前冒泡，直到找到自己的位置，插入到前面已经排好序的有序序列中去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">	<span class="keyword">int</span> j = i;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(arr,j,j<span class="number">-1</span>);</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _RIter&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(_RIter st, _RIter ed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> delta = ed - st; delta; delta /= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; delta; i++)</span><br><span class="line">            insert_sort(st + i, ed, delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线性时间排序"><a href="#线性时间排序" class="headerlink" title="线性时间排序"></a>线性时间排序</h2><p>基于比较的排序算法是不能突破O(NlogN)的。简单证明如下：N个数有N!个可能的排列情况，也就是说基于比较的排序算法的判定树有N!个叶子结点，比较次数至少为log(N!)=O(NlogN)(斯特林公式)。</p>
<p>而<strong>非基于比较的排序</strong>，如计数排序，桶排序，和在此基础上的基数排序，则可以突破O(NlogN)时间下限。但要注意的是，非基于比较的排序算法的使用都是有条件限制的，例如元素的大小限制，相反，基于比较的排序则没有这种限制(在一定范围内)。</p>
<p>对于特定场合有着特殊的性质数据，非基于比较的排序算法则能够非常巧妙地解决。</p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p><strong>前提：元素的最小值不小于0，最大值不超过K</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设 A[1..n]是输入数组，B[1..n]存放排序的输出，C[0..k]提供临时存储空间，记录不大于每个值的元素的个数。。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">5</span>, k = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> i, A[n+<span class="number">1</span>]=&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;, B[n+<span class="number">1</span>], C[k+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;=k; ++i)</span><br><span class="line">		C[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">		++C[A[i]];</span><br><span class="line">	<span class="comment">//C[i] now contains the number of elements equal to i.</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=k; ++i)</span><br><span class="line">		C[i] += C[i<span class="number">-1</span>];</span><br><span class="line">	<span class="comment">//C[i]now contains the number of elements less than or equal to i.</span></span><br><span class="line">	<span class="keyword">for</span>(i=n; i&gt;<span class="number">0</span>; --i)&#123;</span><br><span class="line">		B[C[A[i]]] = A[i];</span><br><span class="line">		C[A[i]]--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; B[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>核心思想</strong></p>
<p>最后的循环把每个元素A[j]放到它在输出数组B中的正确位置上。</p>
<p>如果所有n个元素都是互异的，那么当第一次执行时，对每个A[j]值来说，C[A[j]]就是A[j]在输出数组中的最终正确的位置。这是因为共有C[A[j]]个元素小于等于A[j]。</p>
<p>但是元素可能并不都是互异的，所以，我们每将一个值A[j]放入数组B中一后，都要将C[A[j]]的值减1.这样，当遇到下一个值等于A[j]的输入元素时，该元素可以直接被放在输出数组A[j]的前一个位置上。</p>
<p>递减循环则是稳定排序，递增循环则为不稳定排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++ function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountingSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">NULL</span> || len &lt;= <span class="number">0</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *B = <span class="keyword">new</span> <span class="keyword">int</span>[len]();</span><br><span class="line">    <span class="keyword">int</span> *C = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>]();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        C[A[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">        C[i] += C[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        B[C[A[i]] - <span class="number">1</span>] = A[i];</span><br><span class="line">        C[A[i]]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        A[i] = B[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> [] C;</span><br><span class="line">    <span class="keyword">delete</span> [] B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：时间和空间都是 O(n + k)，n是输入数组长度，k是最大的数的大小。</p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p><strong>简单桶排序</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次循环在编号为a[i]的桶里加一</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">    ++book[a[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依次判断编号0~MAXNUM的桶(从小到大)</span></span><br><span class="line"><span class="comment">// 出现了几次就将桶的编号打印几次</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;MAXNUM; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;book[i]; ++j)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>一般桶排序</strong></p>
<p>每个桶存储一个区间内的数。元素的最小值不小于0，最大值不超过K。假设我们有M个桶，第i个桶Bucket[i]存储i*K/M至(i+1)*K/M之间的数，有如下桶排序的一般方法：</p>
<ol>
<li>扫描序列A，根据每个元素的值所属的区间，放入指定的桶中(顺序放置)。</li>
<li>对每个桶中的元素进行排序，什么排序算法都可以，例如快速排序。</li>
<li>依次收集每个桶中的元素，顺序放置到输出序列中。</li>
</ol>
<p><strong>分析</strong>：每个桶中的元素平均个数为N/M。如果对每个桶中的元素排序使用的算法是快速排序，每次排序的时间复杂度为<code>O(N/M*log(N/M))</code>。则总的时间复杂度为<code>O(N)+O(M)O(N/M*log(N/M))</code> = <code>O(N+ Nlog(N/M))</code> 。当M接近于N时，桶排序的时间复杂度就可以近似认为是O(N)的。即桶越多，时间效率就越高，而桶越多，空间却就越大。</p>
<p>桶中元素的顺序放入和顺序取出是有必要的，因为这样可以确定桶排序的稳定性，配合基数排序是很好用的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++ 元素属于[0,1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">float</span> value;</span><br><span class="line">	Node* next;</span><br><span class="line"></span><br><span class="line">	Node(<span class="keyword">float</span> v = <span class="number">0</span>) :value(v), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Destruct</span><span class="params">(Node *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		Destruct(p-&gt;next);</span><br><span class="line">		<span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">float</span> A[],  <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	Node **B = <span class="keyword">new</span> Node*[n];</span><br><span class="line">	<span class="built_in">memset</span>(B, <span class="number">0</span>, <span class="keyword">sizeof</span>(Node*)*n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> bi = n * A[i] ;</span><br><span class="line">		Node* q = <span class="keyword">new</span> Node(A[i]);</span><br><span class="line">		Node *p = B[bi];</span><br><span class="line">		<span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			B[bi] = q;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span> || p-&gt;value &gt; A[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (A[i] &lt; p-&gt;value) &#123;</span><br><span class="line">				B[bi] = q;</span><br><span class="line">				q-&gt;next = p;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				p-&gt;next = q;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> ( p-&gt;next != <span class="literal">NULL</span> &amp;&amp; A[i] &gt; p-&gt;next-&gt;value)</span><br><span class="line">				p = p-&gt;next;</span><br><span class="line">			q-&gt;next = p-&gt;next;</span><br><span class="line">			p-&gt;next = q;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		Node *p = B[i];</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			A[j++] = p-&gt;value;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		Destruct(B[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> []B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">float</span> A[<span class="number">6</span>]=&#123;<span class="number">0.1</span>,<span class="number">0.3</span>,<span class="number">0.4</span>,<span class="number">0.1</span>,<span class="number">0</span>,<span class="number">0.2</span>&#125;;</span><br><span class="line">	BucketSort(A, <span class="number">6</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i!=<span class="number">6</span>; ++i)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>　　下面说到我们的重头戏，<strong>基数排序(Radix Sort)</strong>。上述的基数排序和桶排序都只是在研究一个关键字的排序，现在我们来讨论有多个关键字的排序问题。</p>
<p>　　假设我们有一些二元组(a,b)，要对它们进行以a为首要关键字，b的次要关键字的排序。<strong>我们可以先把它们先按照首要关键字排序，分成首要关键字相同的若干堆。</strong>然后，<strong>再按照次要关键值分别对每一堆进行单独排序。最后再把这些堆串连到一起，使首要关键字较小的一堆排在上面。</strong>按这种方式的基数排序称为<strong>MSD(Most Significant Dight)</strong>排序。</p>
<p>　　第二种方式是从最低有效关键字开始排序，称为<strong>LSD(Least Significant Dight)</strong>排序。首先对所有的数据按照次要关键字排序，然后对所有的数据按照首要关键字排序。要注意的是，使用的排序算法必须是稳定的，否则就会取消前一次排序的结果。由于不需要分堆对每堆单独排序，<strong>LSD方法往往比MSD简单而开销小</strong>。下文介绍的方法全部是基于LSD的。先排序个位数，再十位。。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; mx)</span><br><span class="line">        mx = arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *output = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> i, count[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Store count of occurrences in count[]</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        count[(arr[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Change count[i] so that count[i] now contains actual position of</span></span><br><span class="line">    <span class="comment">//this digit in output[]</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Build the output array</span></span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        output[count[(arr[i] / <span class="built_in">exp</span>) % <span class="number">10</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        count[(arr[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Copy the output array to arr[], so that arr[] now </span></span><br><span class="line">    <span class="comment">//contains sorted numbers according to current digit</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        arr[i] = output[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> []output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Find the maximum number fo know number of digits</span></span><br><span class="line">    <span class="keyword">int</span> m = getMax(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Do counting sort for every digit. Note that instead of passing digit</span></span><br><span class="line">    <span class="comment">//number, exp is passed. exp is 10^i where i is current digit number</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">exp</span> = <span class="number">1</span>; m / <span class="built_in">exp</span> &gt; <span class="number">0</span>; <span class="built_in">exp</span> *= <span class="number">10</span>)</span><br><span class="line">        CountSort(arr, n, <span class="built_in">exp</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">170</span>, <span class="number">45</span>, <span class="number">90</span>, <span class="number">802</span>, <span class="number">24</span>, <span class="number">2</span>, <span class="number">66</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    RadixSort(arr, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>三种排序算法的比较：</strong></p>
<p>从整体上来说，计数排序，桶排序都是非基于比较的排序算法，而其时间复杂度依赖于数据的范围，桶排序还依赖于空间的开销和数据的分布。而基数排序是一种对多元组排序的有效方法，具体实现要用到计数排序或桶排序。</p>
<p>相对于快速排序、堆排序等基于比较的排序算法，计数排序、桶排序和基数排序限制较多，不如快速排序、堆排序等算法灵活性好。但反过来讲，这三种线性排序算法之所以能够达到线性时间，是因为充分利用了待排序数据的特性，如果生硬得使用快速排序、堆排序等算法，就相当于浪费了这些特性，因而达不到更高的效率。</p>
<p>在实际应用中，基数排序可以用于后缀数组的倍增算法，使时间复杂度从O(N<em>logN</em>logN)降到O(N*logN)。线性排序算法使用最重要的是，<strong>充分利用数据特殊的性质，以达到最佳效果</strong>。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Network/Tcp/TCP网络拥塞控制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/24/Network/Tcp/TCP网络拥塞控制/" class="article-date">
      <time datetime="2018-12-24T06:55:50.000Z" itemprop="datePublished">2018-12-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/24/Network/Tcp/TCP网络拥塞控制/">TCP网络拥塞控制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="网络拥塞控制的四种算法"><a href="#网络拥塞控制的四种算法" class="headerlink" title="网络拥塞控制的四种算法"></a>网络拥塞控制的四种算法</h3><p>cnwd - 拥塞窗口的大小（以字节为单位，这里以数据段的个数为单位方便计算），发送方让自己的发送窗口等于拥塞窗口。<br>RTT- 一个传输轮次经历的时间。</p>
<h4 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h4><p>最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。具体来说，当新建连接时，cwnd初始化为1个报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1倍。这样cwnd的值就随着网络往返时间RTT呈指数级增长.<br>这里设置了一个慢开始门限ssthresh。<br>cwnd &lt; ssthresh时,进行慢开始算法。<br>cwnd&gt;ssthresh时,进行拥塞避免算。<br>cwnd = ssthresh时,两者皆可。</p>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>每个轮次结束都让cwnd增加一个，而不是一倍，增加的更加缓慢。<br>不论是慢开始还是拥塞避免只要网络出现拥塞（没有按时到达）时，就把ssthresh的值置为出现拥塞时的拥塞窗口的一半，以及cwnd置为1，进行慢开始。 </p>
<h4 id="快重传和快恢复算法"><a href="#快重传和快恢复算法" class="headerlink" title="快重传和快恢复算法"></a>快重传和快恢复算法</h4><p>快重传算法要求接收方每收到一个失序的报文段后就立即进行重复确认。 </p>
<p>当接收方接收到了M4,却没有接收到M3，这时报文段已经失序，不能确认M4,根据快重传算法规定，返回一个M2重复确认提醒接收方M3没有接收到， 在接收到M5,M6后继续返回两个重复确认。快重传算法规定发送方一连接收到三个重复确认就立即重传对方尚未收到的报文段M3。<br>（还有一种快重传把cwnd增加到ssthresh+3MSS）.<br>快恢复算法与快重传算法配合使用。<br>一连收到三个重复确认信号后就把ssthresh减半，然后cwnd设置为ssthresh减半后的数值，执行拥塞避免算法。 </p>
<p>在采用快恢复算法时，慢开始算法只有在建立TCP连接时和网络超时才使用。 </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Unix/Programming/Makefile学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/15/Unix/Programming/Makefile学习/" class="article-date">
      <time datetime="2018-12-15T12:58:58.000Z" itemprop="datePublished">2018-12-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/15/Unix/Programming/Makefile学习/">Makefile学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>摘自陈皓博客<a href="https://blog.csdn.net/haoel/article/details/2886" target="_blank" rel="noopener">https://blog.csdn.net/haoel/article/details/2886</a></p>
<h3 id="文件依赖规则"><a href="#文件依赖规则" class="headerlink" title="文件依赖规则"></a>文件依赖规则</h3><ol>
<li>如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。    </li>
<li>如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。</li>
<li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</li>
</ol>
<p><strong>语法</strong></p>
<p>target … : prerequisites …   ;  command             </p>
<p>​    command</p>
<p>target就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label）。</p>
<p>prerequisites就是要生成那个target所需要的文件或是目标。</p>
<p>command也就是make需要执行的命令。（任意的Shell命令）</p>
<p>说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。</p>
<h3 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o /</span><br><span class="line">       insert.o search.o files.o utils.o</span><br><span class="line">        cc -o edit main.o kbd.o command.o display.o /</span><br><span class="line">                   insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">        cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">        cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">        cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">        cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">        cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">        cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">        cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">        cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">        rm edit main.o kbd.o command.o display.o /</span><br><span class="line">           insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>反斜杠（/）是换行符的意思。这样比较便于Makefile的易读。</p>
<p>把这个内容保存在文件为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下“make clean”就可以了。</p>
<p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。</p>
<p>clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p>
<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入文件名的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏可能会更好。</p>
<p>我们在makefile一开始就这样定义：</p>
<p>​     objects = main.o kbd.o command.o display.o /<br>​              insert.o search.o files.o utils.o</p>
<p>于是，我们就可以很方便地在我们的makefile中以“$(objects)”的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：</p>
<p>​    objects = main.o kbd.o command.o display.o /<br>​              insert.o search.o files.o utils.o</p>
<p>​    edit : $(objects)<br>​            cc -o edit $(objects)</p>
<p>于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。</p>
<h3 id="让make自动推导"><a href="#让make自动推导" class="headerlink" title="让make自动推导"></a>让make自动推导</h3><p>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o /</span><br><span class="line">          insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : $(objects)</span><br><span class="line">        cc -o edit $(objects)</span><br><span class="line"></span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">        rm edit $(objects)</span><br></pre></td></tr></table></figure>
<p>这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。</p>
<h3 id="另类风格的makefile"><a href="#另类风格的makefile" class="headerlink" title="另类风格的makefile"></a>另类风格的makefile</h3><p>即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o /</span><br><span class="line"></span><br><span class="line">          insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : $(objects)</span><br><span class="line"></span><br><span class="line">        cc -o edit $(objects)</span><br><span class="line"></span><br><span class="line">$(objects) : defs.h</span><br><span class="line"></span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line"></span><br><span class="line">display.o insert.o search.o files.o : buffer.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line"></span><br><span class="line">        rm edit $(objects)</span><br></pre></td></tr></table></figure>
<p>这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。</p>
<h3 id="amp-amp"><a href="#amp-amp" class="headerlink" title="@ &amp; - &amp;"></a>@ &amp; - &amp;</h3><p>如果<code>make</code>执行的命令前面加了@字符，则不显示命令本身而只显示它的结果。</p>
<p>通常<code>make</code>执行的命令如果出错（该命令的退出状态非0）就立刻终止，不再执行后续命令，但如果命令前面加了<code>-</code>号，即使这条命令出错，<code>make</code>也会继续执行后续命令。</p>
<p>通常<code>rm</code>命令和<code>mkdir</code>命令前面要加<code>-</code>号，因为<code>rm</code>要删除的文件可能不存在，<code>mkdir</code>要创建的目录可能已存在，这两个命令都有可能出错，但这种错误是应该忽略的。</p>
<p>Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“/#”。</p>
<h3 id="makefile的文件名"><a href="#makefile的文件名" class="headerlink" title="makefile的文件名"></a>makefile的文件名</h3><p>默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。</p>
<p>当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“-f”和“–file”参数。</p>
<h3 id="引用其它的Makefile"><a href="#引用其它的Makefile" class="headerlink" title="引用其它的Makefile"></a>引用其它的Makefile</h3><p>在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include &lt;filename&gt;</span><br><span class="line"></span><br><span class="line">#filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）</span><br></pre></td></tr></table></figure>
<p>在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和<code>&lt;filename&gt;</code>可以用一个或多个空格隔开。</p>
<p>make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p>
<p>​    1、如果make执行时，有“-I”或“–include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。<br>​    2、如果目录<code>&lt;prefix&gt;/include</code>（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。</p>
<p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。</p>
<h3 id="环境变量-MAKEFILES"><a href="#环境变量-MAKEFILES" class="headerlink" title="环境变量 MAKEFILES"></a>环境变量 MAKEFILES</h3><p>如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p>
<p>建议<strong>不要使用</strong>这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。 </p>
<h3 id="make工作方式"><a href="#make工作方式" class="headerlink" title="make工作方式"></a>make工作方式</h3><p>​    1、读入所有的Makefile。<br>​    2、读入被include的其它Makefile。<br>​    3、初始化文件中的变量。<br>​    4、推导隐晦规则，并分析所有规则。<br>​    5、为所有的目标文件创建依赖关系链。<br>​    6、根据依赖关系，决定哪些目标要重新生成。<br>​    7、执行生成命令。</p>
<p>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。</p>
<h3 id="使用通配符"><a href="#使用通配符" class="headerlink" title="使用通配符"></a>使用通配符</h3><p>make支持三各通配符：“*”，“?”和“[…]”。这是和Unix的B-Shell是相同的。</p>
<p>波浪号（“~”）字符在文件名中也有比较特殊的用途，表示当前用户的$HOME目录。</p>
<h3 id="自动文件搜寻"><a href="#自动文件搜寻" class="headerlink" title="自动文件搜寻"></a>自动文件搜寻</h3><p>Makefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。</p>
<p>​    VPATH = src:../headers</p>
<p>上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）</p>
<hr>
<p>另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：</p>
<p>​    1、<code>vpath &lt;pattern&gt; &lt;directories&gt;</code></p>
<p>​    为符合模式<code>&lt;pattern&gt;</code>的文件指定搜索目录<code>&lt;directories&gt;</code>。</p>
<p>​    2、<code>vpath &lt;pattern&gt;</code></p>
<p>​    清除符合模式<code>&lt;pattern&gt;</code>的文件的搜索目录。</p>
<p>​    3、vpath</p>
<p>​    清除所有已被设置好了的文件搜索目录。</p>
<p>vapth使用方法中的<code>&lt;pattern&gt;</code>需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。</p>
<p>可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的<code>&lt;pattern&gt;</code>，或是被重复了的<code>&lt;pattern&gt;</code>，那么，make会按照vpath语句的先后顺序来执行搜索。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vpath %.c foo:bar</span><br><span class="line">vpath %   blish</span><br></pre></td></tr></table></figure>
<p>上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。</p>
<h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。</p>
<p>​    .PHONY : clean</p>
<p>只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写：</p>
<p>​     .PHONY: clean<br>​    clean:<br>​            rm *.o temp</p>
<hr>
<p>我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：</p>
<p>​    all : prog1 prog2 prog3<br>​    .PHONY : all</p>
<p>​    prog1 : prog1.o utils.o<br>​            cc -o prog1 prog1.o utils.o</p>
<p>​    prog2 : prog2.o<br>​            cc -o prog2 prog2.o</p>
<p>​    prog3 : prog3.o sort.o utils.o<br>​            cc -o prog3 prog3.o sort.o utils.o</p>
<h3 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h3><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;targets ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;</span><br><span class="line">        &lt;commands&gt;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>​    targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。</p>
<p>​    target-parrtern是指明了targets的模式，也就是的目标集模式。</p>
<p>​    prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。</p>
<p>我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠“\”进行转义，来标明真实的“%”字符。</p>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"></span><br><span class="line">all: $(objects)</span><br><span class="line"></span><br><span class="line">$(objects): %.o: %.c</span><br><span class="line">        $(CC) -c $(CFLAGS) $&lt; -o $@</span><br></pre></td></tr></table></figure>
<p>上面的例子中，指明了我们的目标从<code>$object</code>中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量<code>$object</code>集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.c bar.c”。而命令中的“<code>$&lt;</code>”和“<code>$@</code>”则是自动化变量，“<code>$&lt;</code>”表示所有的依赖目标集（也就是“foo.c bar.c”），“<code>$@</code>”表示目标集（也就是“foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line">        $(CC) -c $(CFLAGS) foo.c -o foo.o</span><br><span class="line">bar.o : bar.c</span><br><span class="line">        $(CC) -c $(CFLAGS) bar.c -o bar.o</span><br></pre></td></tr></table></figure>
<p>“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">files = foo.elc bar.o lose.o</span><br><span class="line"></span><br><span class="line">$(filter %.o,$(files)): %.o: %.c</span><br><span class="line">        $(CC) -c $(CFLAGS) $&lt; -o $@</span><br><span class="line">$(filter %.elc,$(files)): %.elc: %.el</span><br><span class="line">        emacs -f batch-byte-compile $&lt;</span><br></pre></td></tr></table></figure></p>
<p><code>$(filter %.o,$(files))</code>表示调用Makefile的filter函数，过滤“<code>$filter</code>”集，只要其中模式为“%.o”的内容。</p>
<h3 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Makefile/">Makefile</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C_C++/C++Collection/C++STL" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/07/C_C++/C++Collection/C++STL/" class="article-date">
      <time datetime="2018-12-07T12:51:15.000Z" itemprop="datePublished">2018-12-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/07/C_C++/C++Collection/C++STL/">C++ STL</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="标准模板库"><a href="#标准模板库" class="headerlink" title="标准模板库"></a>标准模板库</h1><p>STL 提供了一组表示容器、迭代器、函数对象、算法的模板。</p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2018/12/07/C_C++/C++Collection/C++STL/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Algorithm/查找树" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/07/Algorithm/查找树/" class="article-date">
      <time datetime="2018-12-07T05:57:22.000Z" itemprop="datePublished">2018-12-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/07/Algorithm/查找树/">查找树</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2018/12/07/Algorithm/查找树/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Database/SQLserver/远程登入sqlserver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/06/Database/SQLserver/远程登入sqlserver/" class="article-date">
      <time datetime="2018-12-06T06:18:58.000Z" itemprop="datePublished">2018-12-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/Database/SQLserver/远程登入sqlserver/">远程登入 SQL server</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="https://jingyan.baidu.com/article/6c67b1d6ca06f02787bb1ed1.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/6c67b1d6ca06f02787bb1ed1.html</a></p>
<ol>
<li><p>登录sqlserver manager 后，右键选择“属性”。左侧选择“安全性”，选中右侧的“SQL Server 和 Windows 身份验证模式”以启用混合登录模式</p>
</li>
<li><p>选择“连接”，勾选“允许远程连接此服务器”，然后点“确定”</p>
</li>
<li>展开“安全性”，“登录名”选择一个服务器登入名，右键选择“属性”，左侧选择“常规”，右侧选择“SQL Server 身份验证”，并设置密码</li>
<li>打开sql server配置管理器，在左则选择sql server网络配置节点下的sqlexpress的协议，在右侧的TCP/IP默认是“否”，右键启用或者双击打开设置面板将其修改为“是”。</li>
<li>重启服务器</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/SQLserver/">SQLserver</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQLserver/">SQLserver</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Database/Mysql/mysql c api" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/04/Database/Mysql/mysql c api/" class="article-date">
      <time datetime="2018-12-04T14:18:57.000Z" itemprop="datePublished">2018-12-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/Database/Mysql/mysql c api/">mysql c&amp;c++ api</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="mac-os环境"><a href="#mac-os环境" class="headerlink" title="mac os环境"></a>mac os环境</h2><h3 id="Download-Connector-C"><a href="#Download-Connector-C" class="headerlink" title="Download Connector/C++"></a>Download Connector/C++</h3><p><a href="https://dev.mysql.com/downloads/connector/cpp/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/connector/cpp/</a></p>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;mysql/mysql.h&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Compiler-Arguments"><a href="#Compiler-Arguments" class="headerlink" title="Compiler Arguments"></a>Compiler Arguments</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp  `mysql_config --libs`</span><br><span class="line"><span class="comment">/*在unix环境中反引号 `` 和 $() 都是命令替换。</span></span><br><span class="line"><span class="comment">在本机(Mac)上直接输入 mysql_config --libs 产生的结果是: </span></span><br><span class="line"><span class="comment">-L/usr/local/Cellar/mysql/5.7.21/lib -lmysqlclient -lssl -lcrypto</span></span><br><span class="line"><span class="comment">所以等于是参数直接替换为后者，两者是相同效果。</span></span><br><span class="line"><span class="comment">同理 mysql_config --cflags</span></span><br><span class="line"><span class="comment">-I/usr/local/Cellar/mysql/5.7.21/include</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>注：18.9.30更新macOS Mojave 后，编译选项报错，所以我只用了 -lmysqlclient ，把 -lssl -lcrypto 删了，然后未发生错误。</p>
<p>Clion 只需要添加两句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -I/usr/local/Cellar/mysql/5.7.21/include&quot;)</span><br><span class="line"></span><br><span class="line">add_executable(Project01 main.c)</span><br><span class="line"></span><br><span class="line">target_link_libraries(Project01 -L/usr/local/Cellar/mysql/5.7.21/lib -lmysqlclient)</span><br></pre></td></tr></table></figure>
<h3 id="Use-in-Program"><a href="#Use-in-Program" class="headerlink" title="Use in Program"></a>Use in Program</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">//连接数据库，成功返回0</span><br><span class="line">int connectMysql(MYSQL * mysql)&#123;</span><br><span class="line">    int     ret = 0;</span><br><span class="line">    MYSQL   *con = NULL;</span><br><span class="line"></span><br><span class="line">    con = mysql_init(mysql);</span><br><span class="line">    if (con == NULL) &#123;</span><br><span class="line">        ret = mysql_errno(mysql);</span><br><span class="line">        printf(&quot;func mysql_init() err :%d\n&quot;, ret);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //连接mysql服务器</span><br><span class="line">    //MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd,</span><br><span class="line">    //const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag) ;</span><br><span class="line">    con = mysql_real_connect(mysql, MYSQLHOST, MYSQLUSR, MYSQLPAS, MYSQLDB, 0, NULL, 0 );</span><br><span class="line">    if (con == NULL) &#123;</span><br><span class="line">        ret = mysql_errno(mysql);</span><br><span class="line">        printf(&quot;func mysql_real_connect() err :%d\n&quot;, ret);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">#ifdef NOTDEFMYSQL</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;func mysql_real_connect() ok\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*插入名字和密码，成功则返回0*/</span><br><span class="line">int insertNamePass(MYSQL* mysql, const char* name, const char* pass)&#123;</span><br><span class="line">    char query[51 + MAXNAME + MAXPASS] = &quot;insert into users(username,password) values(\&quot;&quot;;</span><br><span class="line">    strncat(query, name, MAXNAME);</span><br><span class="line">    strcat(query, &quot;\&quot;,\&quot;&quot;);</span><br><span class="line">    strncat(query, pass, MAXPASS);</span><br><span class="line">    strcat(query, &quot;\&quot;)&quot;);</span><br><span class="line"></span><br><span class="line">    return mysql_real_query(mysql, query, (unsigned int)strlen(query));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*如果名字存在则返回0*/</span><br><span class="line">int hasName(MYSQL* mysql, const char * name)&#123;</span><br><span class="line">    char query[38 + MAXNAME] = &quot;SELECT 1 FROM users WHERE username=\&quot;&quot;;</span><br><span class="line">    strncat(query, name, MAXNAME);</span><br><span class="line">    strcat(query, &quot;\&quot;&quot;);</span><br><span class="line"></span><br><span class="line">    if (mysql_real_query(mysql, query, (unsigned int)strlen(query) ) )</span><br><span class="line">    &#123;</span><br><span class="line">        puts(&quot;MySQL query is error!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        MYSQL_RES *result = mysql_store_result(mysql);</span><br><span class="line">        if( mysql_num_rows(result) )&#123;</span><br><span class="line">            mysql_free_result(result);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//检测用户的密码是否匹配，匹配则返回0</span><br><span class="line">int passRight(MYSQL* mysql, const char * name, const char * pass)&#123;</span><br><span class="line">    char query[45 + MAXNAME] = &quot;select password from users where username=\&quot;&quot;;</span><br><span class="line">    strncat(query, name, MAXNAME);</span><br><span class="line">    strcat(query, &quot;\&quot;&quot;);</span><br><span class="line"></span><br><span class="line">    if (mysql_real_query(mysql, query, (unsigned int)strlen(query) ) )</span><br><span class="line">    &#123;</span><br><span class="line">        puts(&quot;MySQL query is error!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        MYSQL_RES *result = mysql_store_result(mysql);</span><br><span class="line">        MYSQL_ROW row = mysql_fetch_row(result);</span><br><span class="line">        if( !strncmp(row[0], pass, MAXPASS))&#123;</span><br><span class="line">            mysql_free_result(result);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        mysql_free_result(result);</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回用户分数,2 Bytes</span><br><span class="line">short getGrade(MYSQL* mysql, const char * name)&#123;</span><br><span class="line">    char query[42 + MAXNAME] = &quot;select grade from users where username=\&quot;&quot;;</span><br><span class="line">    strncat(query, name, MAXNAME);</span><br><span class="line">    strcat(query, &quot;\&quot;&quot;);</span><br><span class="line"></span><br><span class="line">    if (mysql_real_query(mysql, query, (unsigned int)strlen(query) ) )</span><br><span class="line">    &#123;</span><br><span class="line">        puts(&quot;MySQL query is error!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        MYSQL_RES *result = mysql_store_result(mysql);</span><br><span class="line">        MYSQL_ROW row = mysql_fetch_row(result);</span><br><span class="line">        short grade = (short)strtol(row[0], NULL, 10);</span><br><span class="line">        mysql_free_result(result);</span><br><span class="line">        return grade;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Mysql/">Mysql</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mysql/">Mysql</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2019 Skuaka
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 1;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>