<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="Skuaka">


    
    


<meta name="description" content="For you, a thousand times over.">
<meta name="keywords" content="skuaka">
<meta property="og:type" content="website">
<meta property="og:title" content="Skuaka">
<meta property="og:url" content="http://skuaka.cn/page/6/index.html">
<meta property="og:site_name" content="Skuaka">
<meta property="og:description" content="For you, a thousand times over.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Skuaka">
<meta name="twitter:description" content="For you, a thousand times over.">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Skuaka" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/avatar.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Skuaka</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Skuaka</a></h1>
        </hgroup>

        
        <p class="header-subtitle">For you, a thousand times over.</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">Home</a></li>
                        
                            <li><a href="/archives/">Archives</a></li>
                        
                            <li><a href="/tags/">Tags</a></li>
                        
                            <li><a href="/about/">about</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/unp/"><unp></unp></a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCIE/">CCIE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DDos/">DDos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DTD/">DTD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DoNotStarve/">DoNotStarve</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dreamweaver/">Dreamweaver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Game/">Game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Job/">Job</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kali/">Kali</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MetaProgram/">MetaProgram</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mp3/">Mp3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Op-System/">Op-System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Perl/">Perl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QT/">QT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Raspberrypi/">Raspberrypi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLserver/">SQLserver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Security/">Security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vultr/">Vultr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wifi/">Wifi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wireshark/">Wireshark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/base64/">base64</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcc-gdb/">gcc,gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/macOS/">macOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openSSL/">openSSL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postman/">postman</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/robotframework/">robotframework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssh/">ssh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/steamcmd/">steamcmd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sublime/">sublime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/travis/">travis</a></li></ul>
                    </div>
                </section>
                
                
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Skuaka</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Skuaka</a></h1>
            </hgroup>
            
            <p class="header-subtitle">For you, a thousand times over.</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">Home</a></li>
                
                    <li><a href="/archives/">Archives</a></li>
                
                    <li><a href="/tags/">Tags</a></li>
                
                    <li><a href="/about/">about</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" target="_blank" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me">
</nav>
      <div class="body-wrap">
  
    <article id="post-Database/Concept/数据库理论知识" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/25/Database/Concept/数据库理论知识/" class="article-date">
      <time datetime="2019-03-25T12:24:14.000Z" itemprop="datePublished">2019-03-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/25/Database/Concept/数据库理论知识/">数据库理论知识</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="数据库理论知识"><a href="#数据库理论知识" class="headerlink" title="数据库理论知识"></a>数据库理论知识</h2><p>以下来自：<a href="https://juejin.im/post/5b55b842f265da0f9e589e79#heading-1" target="_blank" rel="noopener">https://juejin.im/post/5b55b842f265da0f9e589e79#heading-1</a></p>
<h3 id="聚集和非聚集索引"><a href="#聚集和非聚集索引" class="headerlink" title="聚集和非聚集索引"></a>聚集和非聚集索引</h3><p>简单概括：</p>
<ul>
<li>聚集索引就是以<strong>主键</strong>创建的索引</li>
<li>非聚集索引就是以<strong>非主键</strong>创建的索引</li>
</ul>
<p>区别：</p>
<ul>
<li>聚集索引在叶子节点存储的是<strong>表中的数据</strong></li>
<li>非聚集索引在叶子节点存储的是<strong>主键和索引列</strong></li>
<li>使用非聚集索引查询出数据时，<strong>拿到叶子上的主键再去查到想要查找的数据</strong>。(拿到主键再查找这个过程叫做<strong>回表</strong>)</li>
</ul>
<p><strong>非聚集索引也叫做二级索引</strong>，不用纠结那么多名词，将其等价就行了~</p>
<p>非聚集索引在建立的时候也<strong>未必是单列</strong>的，可以多个列来创建索引。</p>
<ul>
<li>此时就涉及到了哪个列会走索引，哪个列不走索引的问题了(最左匹配原则–&gt;后面有说)</li>
<li><strong>创建多个单列(非聚集)索引的时候，会生成多个索引树</strong>(所以过多创建索引会占用磁盘空间)</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>在创建多列索引中也涉及到了一种特殊的索引–&gt;<strong>覆盖索引</strong></p>
<ul>
<li>我们前面知道了，如果不是聚集索引，叶子节点存储的是主键+列值</li>
<li>最终还是要“回表”，也就是要通过主键<strong>再</strong>查找一次。这样就会比较慢</li>
<li>覆盖索引就是把要<strong>查询出的列和索引对应</strong>，不做回表操作！</li>
</ul>
<h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p><strong>最左匹配原则</strong>：</p>
<ul>
<li>索引可以简单如一个列<code>(a)</code>，也可以复杂如多个列<code>(a, b, c, d)</code>，即<strong>联合索引</strong>。</li>
<li>如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否<strong>存在（相等）</strong>，遇到范围查询<code>(&gt;、&lt;、between、like</code>左匹配)等就<strong>不能进一步匹配</strong>了，后续退化为线性查找。</li>
<li>因此，<strong>列的排列顺序决定了可命中索引的列数</strong>。</li>
</ul>
<p>例子：</p>
<ul>
<li>如有索引<code>(a, b, c, d)</code>，查询条件<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，则会在每个节点依次命中a、b、c，无法命中d。(很简单：索引命中只能是<strong>相等</strong>的情况，不能是范围匹配)</li>
</ul>
<h3 id="自动优化顺序"><a href="#自动优化顺序" class="headerlink" title="=自动优化顺序"></a>=自动优化顺序</h3><p><strong>不需要考虑=、in等条件查询的顺序</strong>，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列。</p>
<p>例子：</p>
<p>如有索引<code>(a, b, c, d)</code>，查询条件<code>c &gt; 3 and b = 2 and a = 1 and d &lt; 4</code>与<code>a = 1 and c &gt; 3 and b = 2 and d &lt; 4</code>等顺序都是可以的，MySQL会自动优化为<code>a = 1 and b = 2 and c &gt; 3 and d &lt; 4</code>，依次命中a、b、c。</p>
<h3 id="索引种类"><a href="#索引种类" class="headerlink" title="索引种类"></a>索引种类</h3><p>这部分来自：<a href="https://www.cnblogs.com/sessionbest/articles/8689255.html" target="_blank" rel="noopener">https://www.cnblogs.com/sessionbest/articles/8689255.html</a></p>
<ol>
<li>按照索引列值的唯一性，索引可分为唯一索引和非唯一索引；</li>
<li>按照索引列的个数：单列索引和复合索引；</li>
<li>按照索引列的物理组织方式。</li>
</ol>
<p><strong>物理组织方式</strong>：</p>
<p>一、<strong>B树索引</strong></p>
<p>最常用的索引，各叶子节点中包括的数据有索引列的值和数据表中对应行的ROWID，简单的说，在B树索引中，是通过在索引中保存排过续的索引列值与相对应记录的ROWID来实现快速查询的目的。</p>
<p>可以保证无论用户要搜索哪个分支的叶子结点，都需要经过相同的索引层次，即都需要相同的I/O次数。</p>
<p>注1：索引是针对字段创建的，相同字段不能创建一个以上的索引；</p>
<p>注2：默认的索引是不唯一的，但是也可以加上unique，表示该索引的字段上没有重复值(定义unique约束时会自动创建)；</p>
<p>注3：创建主键时，默认在主键上创建了B树索引，因此不能再在主键上创建索引。</p>
<p>二、<strong>位图索引</strong></p>
<p>有些字段中使用B树索引的效率仍然不高，例如性别的字段中，只有“男、女”两个值，则即便使用了B树索引，在进行检索时也将返回接近一半的记录。</p>
<p>所以当字段的基数很低时，需要使用位图索引。(“低”的标准是取值数量 &lt; 行数*1%)</p>
<p><img src="http://118.25.53.128/Picture/Database/bitmap_index.jpg" alt="bitmap_index"></p>
<p>位图索引的逻辑结构如上图所示：索引中不再记录rowid和键值，而是将每个值作为一列，用0和1表示该行是否等于该键值(0表示否;1表示是)。其中位图索引的行顺序与原表的行顺序一致，可以在查询数据的过程中对应计算出行的原始物理位置。</p>
<p>注：位图索引不可能是唯一索引，也不能进行键值压缩。</p>
<p>三、<strong>反向键索引</strong></p>
<p>考虑这个情况：某一字段的值是1-1000顺序排列，建立B树索引后依旧递增，到后来该B数索引不断在后面增加分支，会形成不对称树。</p>
<p>反向键索引是<strong>一种特殊的B树索引</strong>，在存储构造中与B树索引完全相同，但是针对数值时，反向键索引会先反向每个键值的字节，然后对反向后的新数据进行索引。例如输入2008则转换为8002，这样当数值一次增加时，其反向键在大小中的分布仍然是比较平均的。</p>
<p>注：键的反转由系统自行完成。对于用户是透明的。</p>
<p>四、<strong>基于函数的索引</strong></p>
<p>有的时候，需要进行如下查询：<code>select * from t1 where to_char(date,&#39;yyyy&#39;)&gt;&#39;2007&#39;;</code></p>
<p>但是即便在date字段上建立了索引，还是不得不进行全表扫描。在这种情况下，可以使用基于函数的索引。</p>
<p>注：简单来说，基于函数的索引，就是将查询要用到的表达式作为索引项。</p>
<p>五、<strong>全局索引和局部索引</strong></p>
<p>这个索引貌似很复杂，其实很简单。总得来说一句话，就是无论怎么分区，都是为了方便管理。</p>
<p>具体索引和表的关系有三种：</p>
<p>1、局部分区索引：分区索引和分区表1对1</p>
<p>2、全局分区索引：分区索引和分区表N对N</p>
<p>3、全局非分区索引：非分区索引和分区表1对N</p>
<h3 id="热备份、冷备份"><a href="#热备份、冷备份" class="headerlink" title="热备份、冷备份"></a>热备份、冷备份</h3><p>来自：<a href="https://www.cnblogs.com/a12436109/p/3606135.html" target="_blank" rel="noopener">https://www.cnblogs.com/a12436109/p/3606135.html</a></p>
<p>线路<strong><em>倒换</em></strong>是指把互为备用的两条线路之一条传送的信号转移到另一条的过程或技术。</p>
<p>热备份是实时备份，发生倒换也不影响业务；冷备份则是周期性备份（如：定时每天凌晨开始备份），发生倒换时，备机的数据不是最新的。</p>
<p>简单解释下。<br>热备份就是2个完全一样的系统，包括硬盘，内存里的内容都一模一样，所不同的是主用与其他设备即时通信，它将根据移动用户的数据变化而变化，对于备份的设备则是实时与主用设备保持一致，一句话就是：主用随现网变，备用随主用变。而且是任何部分都要变。这就牵涉到一个问题，就是修改主用设备的数据时候必须同时修改备用，如果只修改一个就会出数据不一致的告警，甚至引起主备一直切换，直至他们重新同步。</p>
<p>冷备份也是2个完全一样的系统，但是备用处于休息状态，硬盘也是存系统文件，配置文件等，对于用户数据，现网运行情况只是做定时更新，内存根本就是停滞状态，只有在主用倒掉的时候，备用才会启用，用户数据也会恢复倒上次更新的情况（当然如果与主用的硬盘通信状态没断的时候还是会再与其同步最后一次），内存里会重新加载需要用的数据。、</p>
<p>打个比方就例如你需要看通过电视看场球赛，为了安全起见，你准备了2个一样的电视，热备份就是两个同时开开，同时放一个节目，只要你看的那个电视（主用）坏掉了，你扭头就能看另一个电视，而冷备份就是你就开了一台电视，如果主用电视坏了你还要开备用电视，或者还要选台选节目。</p>
<p>所以热备份不会影响业务，而冷备份会使业务暂时中断，只是时间不会太长。</p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Database/">Database</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Database/">Database</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Operating-System/Linux虚拟地址空间" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/24/Operating-System/Linux虚拟地址空间/" class="article-date">
      <time datetime="2019-03-24T08:31:27.000Z" itemprop="datePublished">2019-03-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/24/Operating-System/Linux虚拟地址空间/">Linux虚拟地址空间</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Linux虚拟地址空间"><a href="#Linux虚拟地址空间" class="headerlink" title="Linux虚拟地址空间"></a>Linux虚拟地址空间</h2><blockquote>
<p>整理自：<a href="http://www.cnblogs.com/clover-toeic/p/3754433.html" target="_blank" rel="noopener">http://www.cnblogs.com/clover-toeic/p/3754433.html</a></p>
<p>另一篇已经写了C程序内存结构，这篇是更详细的。</p>
</blockquote>
<p><strong>在多任务操作系统中</strong>，每个进程都运行在属于自己的内存沙盘中。这个沙盘就是<strong>虚拟地址空间(Virtual Address Space)</strong>，在32位模式下它是一个4GB的内存地址块。在Linux系统中, 内核进程和用户进程所占的虚拟内存比例是1:3，而Windows系统为2:2(通过设置Large-Address-Aware Executables标志也可为1:3)。这并不意味着内核使用那么多物理内存，仅表示它可支配这部分地址空间，根据需要将其映射到物理内存。</p>
<p><strong>虚拟地址通过页表(Page Table)映射到物理内存</strong>，页表由操作系统维护并被处理器引用。<strong>每个进程都拥有一套属于它自己的页表，因此对于每个进程而言都好像独享了整个虚拟地址空间。</strong></p>
<p><strong>内核空间在页表中拥有较高特权级，因此用户态程序试图访问这些页时会导致一个页错误</strong>(page fault)。</p>
<p><strong>在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存</strong>。内核代码和数据总是可寻址，随时准备处理中断和系统调用。<strong>与此相反，用户模式地址空间的映射随进程切换的发生而不断变化</strong>。</p>
<hr>
<p><strong>Linux进程在虚拟内存中的标准内存段布局</strong>如下图所示：</p>
<p><img src="http://118.25.53.128/Picture/Op/vitural_addr.jpg" alt="vitural_addr"></p>
<p>其中，用户地址空间中的蓝色条带对应于映射到物理内存的不同内存段，灰白区域表示未映射的部分。这些段只是简单的内存地址范围，与Intel处理器的段没有关系。</p>
<p>上图中<strong>Random stack offset等随机值意在防止恶意程序</strong>。Linux通过对栈、内存映射段、堆的起始地址加上随机偏移量来打乱布局，以免恶意程序通过计算访问栈、库函数等地址。execve(2)负责为进程代码段和数据段建立映射，真正将代码段和数据段的内容读入内存是由系统的缺页异常处理程序按需完成的。另外，execve(2)还会将BSS段清零。</p>
<p>在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并在内存中为这些段分配空间。栈也由操作系统分配和管理；堆由程序员自己管理，即显式地申请和释放空间。</p>
<p>BSS段、数据段和代码段是可执行程序编译时的分段，运行时还需要栈和堆。</p>
<hr>
<h3 id="mm-struct"><a href="#mm-struct" class="headerlink" title="mm_struct"></a>mm_struct</h3><p>内核使用内存描述符来表示进程的地址空间，该描述符表示着进程所有地址空间的信息。内存描述符由 mm_struct 结构体表示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span>           <span class="comment">/* 内存区域链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span>                  <span class="comment">/* VMA 形成的红黑树 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span>               <span class="comment">/* 所有 mm_struct 形成的链表 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> total_vm;                <span class="comment">/* 全部页面数目 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> locked_vm;               <span class="comment">/* 上锁的页面数据 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pinned_vm;               <span class="comment">/* Refcount permanently increased */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> shared_vm;               <span class="comment">/* 共享页面数目 Shared pages (files) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> exec_vm;                 <span class="comment">/* 可执行页面数目 VM_EXEC &amp; ~VM_WRITE */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm;                <span class="comment">/* 栈区页面数目 VM_GROWSUP/DOWN */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> def_flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data;    <span class="comment">/* 代码段、数据段 起始地址和结束地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack;                   <span class="comment">/* 栈区 的起始地址，堆区 起始地址和结束地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end;        <span class="comment">/* 命令行参数 和 环境变量的 起始地址和结束地址 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">    <span class="keyword">mm_context_t</span> context;                  <span class="comment">/* 体系结构特殊数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Must use atomic bitops to access the bits */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;                   <span class="comment">/* 状态标志位 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Coredumping and NUMA and HugePage 相关结构体 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://118.25.53.128/Picture/Op/mm_struct.png" alt="mm_struct"></p>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>线程是进程的执行单元，每个线程都运行在进程的上下文中，共享该进程虚拟地址空间里的：</p>
<ul>
<li><strong>代码段、数据段、堆、共享库、打开的文件</strong>。</li>
</ul>
<p>每个线程都有自己的线程上下文，包括：</p>
<ul>
<li><strong>线程 ID、栈、栈指针、PC、通用目的寄存器、条件码</strong>。</li>
</ul>
<p>各自独立的线程栈的内存模型并不整齐清楚，它们都保存在进程虚拟地址空间的栈区域中，通常被相应的线程独立访问，但<strong>并不对其他线程设防</strong>。</p>
<p><img src="http://118.25.53.128/Picture/Op/thread_model.png" alt="thread_model"></p>
<p><strong>线程栈</strong></p>
<p>从 Linux 内核的角度来说，其实它并没有线程的概念。Linux 把所有线程都当做进程来实现，它将线程和进程不加区分的统一到了 task_struct 中。<strong>线程仅仅被视为一个与其他进程共享某些资源的进程，而是否共享地址空间几乎是进程和 Linux 中所谓线程的唯一区别</strong>。线程创建的时候，加上了 CLONE_VM 标记，这样 线程的内存描述符 将直接指向 父进程的内存描述符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * current 是父进程而 tsk 在 fork() 执行期间是共享子进程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    atomic_inc(&amp;current-&gt;mm-&gt;mm_users);</span><br><span class="line">    tsk-&gt;mm = current-&gt;mm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然线程的地址空间和进程一样，但是对待其地址空间的 stack 还是有些区别的。对于 Linux 进程或者说主线程，其 stack 是在 fork 的时候生成的，实际上就是复制了父亲的 stack 空间地址，然后写时拷贝 (cow) 以及动态增长。然而对于主线程生成的子线程而言，其 stack 将不再是这样的了，而是事先固定下来的，使用 mmap 系统调用，它不带有 VM_STACK_FLAGS 标记。<strong>线程栈不能动态增长，一旦用尽就没了，这是和生成进程的 fork 不同的地方</strong>。</p>
<p><strong>线程的栈在哪？</strong></p>
<p>Stack space for a new thread is created by the parent thread with <code>mmap(MAP_ANONYMOUS|MAP_STACK)</code>. So they’re in the “memory map segment”. It can end up anywhere that a large <code>malloc()</code> could go. (glibc <code>malloc(3)</code> uses <code>mmap(MAP_ANONYMOUS)</code> for large allocations.)</p>
<hr>
<h3 id="各个分段的含义"><a href="#各个分段的含义" class="headerlink" title="各个分段的含义"></a>各个分段的含义</h3><ul>
<li><p><strong>内核空间</strong></p>
<p>内核总是驻留在内存中，是操作系统的一部分。内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。</p>
</li>
<li><p><strong>栈</strong>(stack)</p>
<p>栈又称堆栈，由编译器自动分配释放，行为类似数据结构中的栈(先进后出)。堆栈主要有三个用途：</p>
<ul>
<li>为函数内部声明的非静态局部变量(C语言中称“自动变量”)提供存储空间。</li>
<li>记录函数调用过程相关的维护性信息，称为栈帧(Stack Frame)或过程活动记录(Procedure Activation Record)。它包括函数返回地址，不适合装入寄存器的函数参数及一些寄存器值的保存。除递归调用外，堆栈并非必需。因为编译时可获知局部变量，参数和返回地址所需空间，并将其分配于BSS段。</li>
<li>临时存储区，用于暂存长算术表达式部分计算结果或alloca()函数分配的栈内内存。</li>
</ul>
<p>持续地重用栈空间有助于使活跃的栈内存保持在CPU缓存中，从而加速访问。<strong>进程中的每个线程都有属于自己的栈。</strong>向栈中不断压入数据时，若超出其容量就会耗尽栈对应的内存区域，从而触发一个页错误。此时若栈的大小低于堆栈最大值RLIMIT_STACK(通常是8M)，则<strong>栈会动态增长</strong>，程序继续运行。<strong>映射的栈区扩展到所需大小后，不再收缩。</strong></p>
<p>Linux中<code>ulimit -s</code>命令可查看和设置堆栈最大值，当程序使用的堆栈超过该值时, 发生栈溢出(Stack Overflow)，程序收到一个段错误(Segmentation Fault)。注意，调高堆栈容量可能会增加内存开销和启动时间。</p>
<p>堆栈既可向下增长(向内存低地址)也可向上增长, 这依赖于具体的实现。本文所述堆栈向下增长。</p>
<p>堆栈的大小在运行时由内核动态调整。</p>
</li>
<li><p><strong>内存映射段(mmap)</strong></p>
<p>此处，内核<strong>将硬盘文件的内容直接映射到内存</strong>, 任何应用程序都可通过<strong>Linux的mmap()</strong>系统调用或Windows的CreateFileMapping()/MapViewOfFile()请求这种映射。<strong>内存映射是一种方便高效的文件I/O方式， 因而被用于装载动态共享库</strong>。用户也可创建匿名内存映射，该映射没有对应的文件, 可用于存放程序数据。<strong>在 Linux中，若通过malloc()请求一大块内存，C运行库将创建一个匿名内存映射，而不使用堆内存。”大块” 意味着比阈值 MMAP_THRESHOLD还大，缺省为128KB，可通过mallopt()调整。</strong></p>
<p>（该区域用于映射用到的动态链接库。在Linux 2.4版本中，若可执行文件依赖共享库，则系统会为这些动态库在从0x40000000开始的地址分配相应空间，并在程序装载时将其载入到该空间。在Linux 2.6内核中，共享库的起始地址被往上移动至更靠近栈区的位置。）</p>
<p>（从进程地址空间的布局可以看到，在有共享库的情况下，留给堆的可用空间还有两处：一处是从.bss段到0x40000000，约不到1GB的空间；另一处是从共享库到栈之间的空间，约不到2GB。这两块空间大小取决于栈、共享库的大小和数量。这样来看，是否应用程序可申请的最大堆空间只有2GB？事实上，这与Linux内核版本有关。在上面给出的进程地址空间经典布局图中，共享库的装载地址为0x40000000，这实际上是Linux kernel 2.6版本之前的情况了，在2.6版本里，共享库的装载地址已经被挪到靠近栈的位置，即位于0xBFxxxxxx附近，因此，此时的堆范围就不会被共享库分割成2个“碎片”，故kernel 2.6的32位Linux系统中，malloc申请的最大内存理论值在2.9GB左右。）</p>
</li>
<li><p><strong>堆</strong>(heap)</p>
<p>堆用于存放进程运行时动态分配的内存段，可动态扩张或缩减。<strong>堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问</strong>。当进程调用malloc(C)/new(C++)等函数分配内存时，新分配的内存动态添加到堆上(扩张)；当调用free(C)/delete(C++)等函数释放内存时，被释放的内存从堆中剔除(缩减) 。</p>
<p>分配的堆内存是经过字节对齐的空间，以适合原子操作。堆管理器通过链表管理每个申请的内存，由于堆申请和释放是无序的，最终会产生内存碎片。堆内存一般由应用程序分配释放，回收的内存可供重新使用。若程序员不释放，程序结束时操作系统可能会自动回收。</p>
<p>堆的末端由break指针标识，当堆管理器需要更多内存时，可通过系统调用brk()和sbrk()来移动break指针以扩张堆，一般由系统自动调用。</p>
</li>
<li><p>【扩展阅读】<strong>栈和堆的区别</strong></p>
<ul>
<li>①<strong>管理方式</strong>：栈由编译器自动管理；堆由程序员控制，使用方便，但易产生内存泄露。</li>
<li>②<strong>生长方向</strong>：栈向低地址扩展(即”向下生长”)，是连续的内存区域；堆向高地址扩展(即”向上生长”)，是不连续的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。</li>
<li>③<strong>空间大小</strong>：栈顶地址和栈的最大容量由系统预先规定(通常默认2M或10M)；堆的大小则受限于计算机系统中有效的虚拟内存，32位Linux系统中堆内存可达2.9G空间。</li>
<li>④<strong>存储内容</strong>：栈在函数调用时，首先压入主调函数中下条指令(函数调用语句的下条可执行语句)的地址，然后是函数实参，然后是被调函数的局部变量。本次调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的指令地址，程序由该点继续运行下条可执行语句。堆通常在头部用一个字节存放其大小，堆用于存储生存期与函数调用无关的数据，具体内容由程序员安排。</li>
<li>⑤<strong>分配方式</strong>：栈可静态分配或动态分配。静态分配由编译器完成，如局部变量的分配。动态分配由alloca函数在栈上申请空间，用完后自动释放。堆只能动态分配且手工释放。</li>
<li>⑥<strong>分配效率</strong>：栈由计算机底层提供支持：分配专门的寄存器存放栈地址，压栈出栈由专门的指令执行，因此效率较高。堆由函数库提供，机制复杂，效率比栈低得多。Windows系统中VirtualAlloc可直接在进程地址空间中分配一块内存，快速且灵活。</li>
<li>⑦<strong>分配后系统响应</strong>：只要栈剩余空间大于所申请空间，系统将为程序提供内存，否则报告异常提示栈溢出。     操作系统为堆维护一个记录空闲内存地址的链表。当系统收到程序的内存分配申请时，会遍历该链表寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点空间分配给程序。若无足够大小的空间(可能由于内存碎片太多)，有可能调用系统功能去增加程序数据段的内存空间，以便有机会分到足够大小的内存，然后进行返回。，大多数系统会在该内存空间首地址处记录本次分配的内存大小，供后续的释放函数(如free/delete)正确释放本内存空间。     此外，由于找到的堆结点大小不一定正好等于申请的大小，系统会自动将多余的部分重新放入空闲链表中。</li>
<li>⑧<strong>碎片问题</strong>：栈不会存在碎片问题，因为栈是先进后出的队列，内存块弹出栈之前，在其上面的后进的栈内容已弹出。而频繁申请释放操作会造成堆内存空间的不连续，从而造成大量碎片，使程序效率降低。     可见，堆容易造成内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和内核态切换，内存申请的代价更为昂贵。所以栈在程序中应用最广泛，函数调用也利用栈来完成，调用过程中的参数、返回地址、栈基指针和局部变量等都采用栈的方式存放。所以，建议尽量使用栈，仅在分配大量或大块内存空间时使用堆。</li>
</ul>
</li>
<li><p><strong>BSS段</strong>(Block Started by Symbol)</p>
<p>BSS段中通常存放程序中以下符号：</p>
<ul>
<li>未初始化的全局变量和静态局部变量</li>
<li>初始值为0的全局变量和静态局部变量(依赖于编译器实现)</li>
<li>未定义且初值不为0的符号(该初值即common block的大小)</li>
</ul>
<p>C语言中，未显式初始化的静态分配变量被初始化为0(算术类型)或空指针(指针类型)。由于程序加载时，BSS会被操作系统清零，所以未赋初值或初值为0的全局变量都在BSS中。BSS段仅为未初始化的静态分配变量预留位置，在目标文件中并不占据空间，这样可<strong>减少目标文件体积</strong>。但程序运行时需为变量分配内存空间，故目标文件必须记录所有未初始化的静态分配变量大小总和(通过start_bss和end_bss地址写入机器代码)。当加载器(loader)加载程序时，将为BSS段分配的内存初始化为0。在嵌入式软件中，进入main()函数之前BSS段被C运行时系统映射到初始化为全零的内存(效率较高)。</p>
<p>注意，尽管均放置于BSS段，但初值为0的全局变量是强符号，而未初始化的全局变量是弱符号。若其他地方已定义同名的强符号(初值可能非0)，则弱符号与之链接时不会引起重定义错误，但运行时的初值可能并非期望值(会被强符号覆盖)。因此，定义全局变量时，若只有本文件使用，则尽量使用static关键字修饰；否则需要<strong>为全局变量定义赋初值(哪怕0值)，保证该变量为强符号，以便链接时发现变量名冲突</strong>，而不是被未知值覆盖。</p>
</li>
<li><p><strong>数据段</strong>(Data)</p>
<p>数据段通常用于存放程序中已初始化且初值不为0的全局变量和静态局部变量。数据段属于静态内存分配(静态存储区)，可读可写。</p>
<p>数据段保存在目标文件中(在嵌入式系统里一般固化在镜像文件中)，其内容由程序初始化。例如，对于全局变量int gVar = 10，必须在目标文件数据段中保存10这个数据，然后在程序加载时复制到相应的内存。</p>
</li>
<li><p>【扩展阅读】<strong>数据段与BSS段的区别</strong></p>
<ul>
<li><p>BSS段不占用物理文件尺寸，但占用内存空间；数据段占用物理文件，也占用内存空间。</p>
<p>对于大型数组如int ar0[10000] = {1, 2, 3, …}和int ar1[10000]，ar1放在BSS段，只记录共有10000*4个字节需要初始化为0，而不是像ar0那样记录每个数据1、2、3…，此时BSS为目标文件所节省的磁盘空间相当可观。</p>
</li>
<li><p>当程序读取数据段的数据时，系统会出发缺页故障，从而分配相应的物理内存；当程序读取BSS段的数据时，内核会将其转到一个全零页面，不会发生缺页故障，也不会为其分配相应的物理内存。</p>
</li>
</ul>
</li>
<li><p><strong>代码段</strong>(text)</p>
<p>代码段也称正文段或文本段，通常用于存放程序执行代码(即CPU执行的机器指令)。一般C语言执行语句都编译成机器代码保存在代码段。通常代码段是可共享的，因此频繁执行的程序只需要在内存中拥有一份拷贝即可。代码段通常属于只读，以防止其他程序意外地修改其指令(对该段的写操作将导致段错误)。某些架构也允许代码段为可写，即允许修改程序。</p>
<p>代码段指令根据程序设计流程依次执行，对于顺序指令，只会执行一次(每个进程)；若有反复，则需使用跳转指令；若进行递归，则需要借助栈来实现。</p>
<p>代码段指令中包括操作码和操作对象(或对象地址引用)。若操作对象是立即数(具体数值)，将直接包含在代码中；若是局部数据，将在栈区分配空间，然后引用该数据地址；若位于BSS段和数据段，同样引用该数据地址。</p>
<p>代码段最容易受优化措施影响。</p>
</li>
<li><p><strong>保留区</strong></p>
<p><strong>位于虚拟地址空间的最低部分</strong>，未赋予物理地址。任何对它的引用都是非法的，<strong>用于捕捉使用空指针和小整型值指针引用内存的异常情况</strong>。</p>
<p>它并不是一个单一的内存区域，而是对地址空间中受到操作系统保护而禁止用户进程访问的地址区域的总称。大多数操作系统中，极小的地址通常都是不允许访问的，如NULL。<strong>C语言将无效指针赋值为0也是出于这种考虑</strong>，因为0地址上正常情况下不会存放有效的可访问数据。</p>
</li>
</ul>
<hr>
<h3 id="分段的好处"><a href="#分段的好处" class="headerlink" title="分段的好处"></a>分段的好处</h3><p>进程运行过程中，代码指令根据流程依次执行，只需访问一次(当然跳转和递归可能使代码执行多次)；而数据(数据段和BSS段)通常需要访问多次，因此单独开辟空间以方便访问和节约空间。具体解释如下：</p>
<p>当程序被装载后，数据和指令分别映射到两个虚存区域。数据区对于进程而言可读写，而指令区对于进程只读。两区的权限可分别设置为可读写和只读。以防止程序指令被有意或无意地改写。</p>
<p>现代CPU具有极为强大的缓存(Cache)体系，程序必须尽量提高缓存命中率。<strong>指令区和数据区的分离有利于提高程序的局部性</strong>。现代CPU一般数据缓存和指令缓存分离，故程序的指令和数据分开存放有利于<strong>提高CPU缓存命中率。</strong></p>
<p>当系统中运行多个该程序的副本时，其指令相同，故内存中只须保存一份该程序的指令部分。若系统中运行数百进程，通过共享指令将节省大量空间(尤其对于有动态链接的系统)。其他只读数据如程序里的图标、图片、文本等资源也可共享。而每个副本进程的数据区域不同，它们是进程私有的。</p>
<p>此外，临时数据及需要再次使用的代码在运行时放入栈区中，生命周期短。全局数据和静态数据可能在整个程序执行过程中都需要访问，因此单独存储管理。堆区由用户自由分配，以便管理。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Op-System/">Op-System</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Op-System/">Op-System</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C-C++/C++Collection/C++ref" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/23/C-C++/C++Collection/C++ref/" class="article-date">
      <time datetime="2019-03-23T10:28:23.000Z" itemprop="datePublished">2019-03-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/23/C-C++/C++Collection/C++ref/">C++ref</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="C-ref"><a href="#C-ref" class="headerlink" title="C++ ref"></a>C++ ref</h2><p>像thread类 和 bind函数的参数只能按值传递（内部decay，移除了引用），如果想传递引用，那么就需要 <code>std::ref</code>，const引用则用<code>cref</code>。</p>
<p>ref的返回类型为<code>std::reference_wrapper</code>，其实这个模板类保存了传入参数的地址，然后定义了左值引用的类型转化函数，所以把它赋值给一个引用就可以让这个引用获得对象内保存的地址，看起来就和真正的引用一样了。</p>
<p>官方实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">reference_wrapper</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// types</span></span><br><span class="line">  <span class="keyword">typedef</span> T type;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// construct/copy/destroy</span></span><br><span class="line">  reference_wrapper(T&amp; ref) <span class="keyword">noexcept</span> : _ptr(<span class="built_in">std</span>::addressof(ref)) &#123;&#125;</span><br><span class="line">  reference_wrapper(T&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  reference_wrapper(<span class="keyword">const</span> reference_wrapper&amp;) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// assignment</span></span><br><span class="line">  reference_wrapper&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> reference_wrapper&amp; x) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// access</span></span><br><span class="line">  <span class="keyword">operator</span> T&amp; () <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">  <span class="function">T&amp; <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span>... <span class="title">ArgTypes</span> &gt;</span></span><br><span class="line"><span class="class">  <span class="title">std</span>:</span>:<span class="keyword">invoke_result_t</span>&lt;T&amp;, ArgTypes...&gt;</span><br><span class="line">    <span class="keyword">operator</span>() ( ArgTypes&amp;&amp;... args ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::invoke(get(), <span class="built_in">std</span>::forward&lt;ArgTypes&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T* _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// deduction guides</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">reference_wrapper</span>(<span class="title">reference_wrapper</span>&lt;T&gt;) -&gt; <span class="title">reference_wrapper</span>&lt;T&gt;;</span></span><br></pre></td></tr></table></figure>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Network/Tcp/ICMP" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/22/Network/Tcp/ICMP/" class="article-date">
      <time datetime="2019-03-22T14:49:12.000Z" itemprop="datePublished">2019-03-22</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/22/Network/Tcp/ICMP/">ICMP</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p><strong>互联网控制消息协议</strong>（英语：<strong>I</strong>nternet <strong>C</strong>ontrol <strong>M</strong>essage <strong>P</strong>rotocol，缩写：<strong>ICMP</strong>）是互联网协议族的核心协议之一。它用于网际协议（IP）中发送控制消息，提供可能发生在通信环境中的各种问题反馈。通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。</p>
<p>ICMP依靠IP來完成它的任务，它是IP的主要部分。它与传输协议（如TCP和UDP）显著不同：它一般不用于在两点间传输数据。它通常不由网络程序直接使用，除了ping和traceroute这两个特別的例子。</p>
<h3 id="报头"><a href="#报头" class="headerlink" title="报头"></a>报头</h3><p>ICMP报头从IP报头的第160位开始（IP首部20字节）（除非使用了IP报头的可选部分）。</p>
<p><img src="Picture/ICMP_header.jpg" alt="ICMP_header"></p>
<ul>
<li><strong>Type</strong> - ICMP的類型,标识生成的错误报文；</li>
<li><strong>Code</strong> - 進一步劃分ICMP的類型,该字段用来查找产生错误的原因.；例如，ICMP的目標不可達類型可以把這個位設為1至15等來表示不同的意思。</li>
<li><strong>Checksum</strong> - 校验码部分,這個字段包含有從ICMP報頭和數據部分計算得來的，用於檢查錯誤的數據，其中此校验码字段的值視為0。</li>
<li><strong>ID</strong> - 這個字段包含了ID值，在Echo Reply類型的消息中要返回這個字段。</li>
<li><strong>Sequence</strong> - 這個字段包含一個序號，同樣要在Echo Reply類型的消息中要返回這個字段。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Network/Tcp/IP头_TCP头_UDP头" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/22/Network/Tcp/IP头_TCP头_UDP头/" class="article-date">
      <time datetime="2019-03-22T14:49:12.000Z" itemprop="datePublished">2019-03-22</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/22/Network/Tcp/IP头_TCP头_UDP头/">IP头_TCP头_UDP头</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>源自：<a href="https://www.cnblogs.com/shenpengyan/p/5912567.html" target="_blank" rel="noopener">https://www.cnblogs.com/shenpengyan/p/5912567.html</a></p>
<h3 id="报文封装整体结构"><a href="#报文封装整体结构" class="headerlink" title="报文封装整体结构"></a>报文封装整体结构</h3><p><img src="http://118.25.53.128/Picture/Tcp/o_封装结构.jpg" alt="o_封装结构"></p>
<h3 id="mac帧头定义"><a href="#mac帧头定义" class="headerlink" title="mac帧头定义"></a>mac帧头定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数据帧定义，头14个字节，尾4个字节*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MAC_FRAME_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span> m_cDstMacAddress[<span class="number">6</span>];    <span class="comment">//目的mac地址</span></span><br><span class="line">   <span class="keyword">char</span> m_cSrcMacAddress[<span class="number">6</span>];    <span class="comment">//源mac地址</span></span><br><span class="line">	 <span class="keyword">short</span> m_cType;       　　　　　<span class="comment">//上一层协议类型，如0x0800代表上一层是IP协议，0x0806为arp</span></span><br><span class="line">&#125;__attribute__((packed))MAC_FRAME_HEADER,*PMAC_FRAME_HEADER;</span><br></pre></td></tr></table></figure>
<h3 id="ip头部定义"><a href="#ip头部定义" class="headerlink" title="ip头部定义"></a>ip头部定义</h3><p><img src="http://118.25.53.128/Picture/Tcp/o_ip_header.jpg" alt="o_ip头部2"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IP头定义，共20个字节*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IP_HEADER</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">char</span> m_cVersionAndHeaderLen;					<span class="comment">//版本信息(前4位)，头长度(后4位)</span></span><br><span class="line"> <span class="keyword">char</span> m_cTypeOfService;								<span class="comment">// 服务类型8位</span></span><br><span class="line"> <span class="keyword">short</span> m_sTotalLenOfPacket;						<span class="comment">//数据包长度</span></span><br><span class="line"> <span class="keyword">short</span> m_sPacketID;										<span class="comment">//数据包标识</span></span><br><span class="line"> <span class="keyword">short</span> m_sSliceinfo;									<span class="comment">//分片使用</span></span><br><span class="line"> <span class="keyword">char</span> m_cTTL;													<span class="comment">//存活时间</span></span><br><span class="line"> <span class="keyword">char</span> m_cTypeOfProtocol;							<span class="comment">//协议类型</span></span><br><span class="line"> <span class="keyword">short</span> m_sCheckSum;      　　　　　　 	<span class="comment">//校验和</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> m_uiSourIp;							<span class="comment">//源ip</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> m_uiDestIp;							<span class="comment">//目的ip</span></span><br><span class="line">&#125; __attribute__((packed))IP_HEADER, *PIP_HEADER ;</span><br></pre></td></tr></table></figure>
<ul>
<li>版本（Version）字段：占4比特。用来表明IP协议实现的版本号，当前一般为IPv4，即0100。</li>
<li>报头长度（Internet Header Length，IHL）字段：占4比特。是头部占32比特的数字，包括可选项。普通IP数据报（没有任何选项），该字段的值是5，即160比特=20字节。此字段最大值为60字节。</li>
<li>服务类型（Type of Service ，TOS）字段：占8比特。其中前3比特为优先权子字段（Precedence，现已被忽略）。第8比特保留未用。<strong><em>第4至第7比特分别代表延迟、吞吐量、可靠性和花费</em></strong>。当它们取值为1时分别代表要求最小时延、最大吞吐量、最高可靠性和最小费用。这4比特的服务类型中只能置其中1比特为1。可以全为0，若全为0则表示一般服务。服务类型字段声明了数据报被网络系统传输时可以被怎样处理。例如：TELNET协议可能要求有最小的延迟，FTP协议（数据）可能要求有最大吞吐量，SNMP协议可能要求有最高可靠性，NNTP（Network News Transfer Protocol，网络新闻传输协议）可能要求最小费用，而ICMP协议可能无特殊要求（4比特全为0）。实际上，大部分主机会忽略这个字段，但一些动态路由协议如OSPF（Open Shortest Path First Protocol）、IS-IS（Intermediate System to Intermediate System Protocol）可以根据这些字段的值进行路由决策。</li>
<li>总长度字段：占16比特。指明整个数据报的长度（以字节为单位）。最大长度为65535字节。</li>
<li><strong>标志字段：占16比特。用来唯一地标识主机发送的每一份数据报。通常每发一份报文，它的值会加1。</strong></li>
<li>标志位字段：占3比特。标志一份数据报<strong>是否要求分段</strong>。</li>
<li>段偏移字段：占13比特。如果一份数据报要求分段的话，此字段指明该段偏移距原始数据报开始的位置。</li>
<li>生存期（TTL：Time to Live）字段：占8比特。用来设置数据报最多可以经过的路由器数。由发送数据的源主机设置，通常为32、64、128等。每经过一个路由器，其值减1，直到0时该数据报被丢弃。</li>
<li>协议字段：占8比特。指明IP层所封装的上层协议类型，如ICMP（1）、IGMP（2） 、TCP（6）、UDP（17）等。</li>
<li>头部校验和字段：占16比特。内容是根据IP头部计算得到的校验和码。计算方法是：对头部中每个16比特进行二进制反码求和。（和ICMP、IGMP、TCP、UDP不同，IP不对头部后的数据进行校验）。</li>
<li>源IP地址、目标IP地址字段：各占32比特。用来标明发送IP数据报文的源主机地址和接收IP报文的目标主机地址。</li>
<li>可选项字段：占32比特。用来定义一些任选项：如记录路径、时间戳等。这些选项很少被使用，同时并不是所有主机和路由器都支持这些选项。可选项字段的长度必须是32比特的整数倍，如果不足，必须填充0以达到此长度要求。</li>
</ul>
<h3 id="tcp头部定义"><a href="#tcp头部定义" class="headerlink" title="tcp头部定义"></a>tcp头部定义</h3><p><img src="http://118.25.53.128/Picture/Tcp/o_tcp_header.jpg" alt="o_tcp头部2"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*TCP头定义，共20个字节*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TCP_HEADER</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">short</span> m_sSourPort;										<span class="comment">// 源端口号16bit</span></span><br><span class="line"> <span class="keyword">short</span> m_sDestPort;										<span class="comment">// 目的端口号16bit</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> m_uiSequNum;						<span class="comment">// 序列号32bit</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> m_uiAcknowledgeNum;			<span class="comment">// 确认号32bit</span></span><br><span class="line"> <span class="keyword">short</span> m_sHeaderLenAndFlag;						<span class="comment">// 前4位：TCP头长度；中6位：保留；后6位：标志位</span></span><br><span class="line"> <span class="keyword">short</span> m_sWindowSize;									<span class="comment">// 窗口大小16bit</span></span><br><span class="line"> <span class="keyword">short</span> m_sCheckSum;										<span class="comment">// 检验和16bit</span></span><br><span class="line"> <span class="keyword">short</span> m_surgentPointer;							<span class="comment">// 紧急数据偏移量16bit</span></span><br><span class="line">&#125;__attribute__((packed))TCP_HEADER, *PTCP_HEADER;</span><br><span class="line"><span class="comment">/*TCP头中的选项定义</span></span><br><span class="line"><span class="comment">kind(8bit)+Length(8bit，整个选项的长度，包含前两部分)+内容(如果有的话)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">KIND = </span></span><br><span class="line"><span class="comment">  1表示 无操作NOP，无后面的部分</span></span><br><span class="line"><span class="comment">  2表示 maximum segment 后面的LENGTH就是maximum segment选项的长度（以byte为单位，1+1+内容部分长度）</span></span><br><span class="line"><span class="comment">  3表示 windows scale 后面的LENGTH就是 windows scale选项的长度（以byte为单位，1+1+内容部分长度）</span></span><br><span class="line"><span class="comment">  4表示 SACK permitted，LENGTH为2，没有内容部分</span></span><br><span class="line"><span class="comment">  5表示 这是一个SACK包，LENGTH为2，没有内容部分</span></span><br><span class="line"><span class="comment">  8表示 时间戳，LENGTH为10，含8个字节的时间戳</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>源、目标端口号字段：占16比特。TCP协议通过使用”端口”来标识源端和目标端的应用进程。端口号可以使用0到65535之间的任何数字。在收到服务请求时，操作系统动态地为客户端的应用程序分配端口号。在服务器端，每种服务在”众所周知的端口”（Well-Know Port）为用户提供服务。</p>
</li>
<li><p>顺序号字段：占32比特。用来标识从TCP源端向TCP目标端发送的数据字节流，当前所携带的数据的第一个字节的顺序号。</p>
<p>（如：本次连接共要发送1000个字节，已发出了100个字节，现在发送下一个报文，假设每个报文携带的数据为100字节，则这个报文的头结构中的序号是100【注：从0开始编号】）</p>
</li>
<li><p><strong>确认号字段：占32比特。只有ACK标志为1时，确认号字段才有效。它包含源端期望收到目标端的下一个数据字节的序号。</strong></p>
<p>（如上例中那个报文已被正确接收，则接收端会发送一个ACK=1且确认序号=200的应答报文给发送方。）</p>
</li>
<li><p>头部长度字段：占4比特。给出头部占32比特的数目。没有任何选项字段的TCP头部长度为20字节；最多可以有60字节的TCP头部。</p>
</li>
<li><p>标志位字段（U、A、P、R、S、F）：占6比特。各比特的含义如下：</p>
<ul>
<li><p>URG：紧急指针（urgent pointer）有效。</p>
</li>
<li><p>ACK：确认序号有效。</p>
</li>
<li><p>PSH：接收方应该尽快将这个报文段交给应用层。</p>
</li>
<li><p>RST：重建连接。</p>
</li>
<li><p>SYN：发起一个连接。</p>
</li>
<li><p>FIN：释放一个连接。</p>
</li>
</ul>
</li>
<li><p><strong>窗口大小字段：占16比特。此字段用来进行流量控制。单位为字节数，这个值是本机期望一次接收的字节数。</strong></p>
</li>
<li><p>TCP校验和字段：占16比特。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。</p>
</li>
<li><p><strong>紧急指针字段：占16比特。它是一个偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。</strong></p>
</li>
<li><p>选项字段：占32比特。可能包括”窗口扩大因子”、”时间戳”等选项。</p>
</li>
</ul>
<h3 id="udp头部定义"><a href="#udp头部定义" class="headerlink" title="udp头部定义"></a>udp头部定义</h3><p><img src="http://118.25.53.128/Picture/Tcp/o_udp_header.jpg" alt="o_udp头部"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*UDP头定义，共8个字节*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UDP_HEADER</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> m_usSourPort;					<span class="comment">// 源端口号16bit</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> m_usDestPort;					<span class="comment">// 目的端口号16bit</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> m_usLength;						<span class="comment">// 数据包长度16bit</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> m_usCheckSum;					<span class="comment">// 校验和16bit</span></span><br><span class="line">&#125;__attribute__((packed))UDP_HEADER, *PUDP_HEADER;</span><br></pre></td></tr></table></figure>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C-C++/C++Collection/C++线程池" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/22/C-C++/C++Collection/C++线程池/" class="article-date">
      <time datetime="2019-03-22T05:05:39.000Z" itemprop="datePublished">2019-03-22</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/22/C-C++/C++Collection/C++线程池/">C++线程池</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="C-线程池原理（转）"><a href="#C-线程池原理（转）" class="headerlink" title="C++线程池原理（转）"></a>C++线程池原理（转）</h2><h3 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h3><p>目前的大多数网络服务器都具有一个共同点，就是单位时间内必须处理数目巨大的连接请求，但处理时间却相对较短。 </p>
<p>传统多线程方案中我们采用的服务器模型则是一旦接受到请求之后，即创建一个新的线程，由该线程执行任务。任务执行完毕后，线程退出，这就是是“即时创建，即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数极其频繁，那么服务器将处于不停的创建线程，销毁线程的状态。</p>
<p>我们将传统方案中的线程执行过程分为三个过程：T1、T2、T3。</p>
<ol>
<li>T1：线程创建时间</li>
<li>T2：线程执行时间，包括线程的同步等时间</li>
<li>T3：线程销毁时间</li>
</ol>
<p>那么我们可以看出，线程本身的开销所占的比例为(T1+T3) / (T1+T2+T3)。如果线程执行的时间很短的话，这比开销可能占到20%-50%左右。</p>
<p>除此之外，线程池能够减少创建的线程个数。通常线程池所允许的并发线程是有上界的，如果同时需要并发的线程数超过上界，那么一部分线程将会等待。而传统方案中，如果同时请求数目为2000，那么最坏情况下，系统可能需要产生2000个线程。</p>
<p>因此线程池的出现正是着眼于减少线程池本身带来的开销。线程池采用预创建的技术，在应用程序启动之后，将立即创建一定数量的线程(N1)，放入空闲队列中。这些线程都是处于阻塞（Suspended）状态，不消耗CPU，但占用较小的内存空间。当任务到来后，缓冲池选择一个空闲线程，把任务传入此线程中运行。当N1个线程都在处理任务后，缓冲池自动创建一定数量的新线程，用于处理更多的任务。在任务执行完毕后线程也不退出，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程都一直处于暂停状态，线程池自动销毁一部分线程，回收系统资源。</p>
<p>基于这种预创建技术，线程池将线程创建和销毁本身所带来的开销分摊到了各个具体的任务上，执行次数越多，每个任务所分担到的线程本身开销则越小，不过我们另外可能需要考虑进去线程之间同步所带来的开销</p>
<h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><p>事实上，线程池并不是万能的。它有其特定的使用场合。</p>
<p>线程池致力于减少线程本身的开销对应用所产生的影响，这是有前提的，前提就是线程本身开销与线程执行任务相比不可忽略。如果线程本身的开销相对于线程任务执行开销而言是可以忽略不计的，那么此时线程池所带来的好处是不明显的，比如对于FTP服务器以及Telnet服务器，通常传送文件的时间较长，开销较大，那么此时，我们采用线程池未必是理想的方法，我们可以选择“即时创建，即时销毁”的策略。 </p>
<p>总之线程池通常适合下面的几个场合： </p>
<ol>
<li>单位时间内<strong>处理任务频繁而且任务处理时间短</strong>。</li>
<li><strong>对实时性要求较高</strong>。如果接受到任务后在创建线程，可能满足不了实时要求，因此必须采用线程池进行预创建。 </li>
<li>必须<strong>经常面对高突发性事件</strong>，如果采取传统方法，会不停地大量产生线程，销毁线程。此时采用动态线程池可以避免这种情况的发生。</li>
</ol>
<h3 id="线程池框架"><a href="#线程池框架" class="headerlink" title="线程池框架"></a>线程池框架</h3><p>一般线程池都必须具备下面几个组成部分：</p>
<ul>
<li>线程池管理器：用于创建并管理线程池</li>
<li>工作线程：线程池中实际执行的线程</li>
<li>任务接口：尽管线程池大多数情况下是用来支持网络服务器，但是我们将线程执行的任务抽象出来，形成任务接口，从而使得线程池与具体的任务无关。</li>
<li>任务队列：线程池的概念具体到实现则可能是队列，链表之类的数据结构，其中保存执行线程。</li>
</ul>
<hr>
<p>我们实现的通用线程池框架由五个重要部分组成CThreadManage，CThreadPool，CThread，CJob，</p>
<ul>
<li><p>CWorkerThread，除此之外框架中还包括线程同步使用的类CThreadMutex和CCondition。 </p>
</li>
<li><p>CJob是所有的任务的基类，其提供一个接口Run，所有的任务类都必须从该类继承，同时实现Run方法。该方法中实现具体的任务逻辑。 </p>
</li>
<li><p>CThread是Linux中线程的包装，其封装了Linux线程最经常使用的属性和方法，它也是一个抽象类，是所有线程类的基类，具有一个接口Run。 </p>
</li>
<li><p>CWorkerThread是实际被调度和执行的线程类，其从CThread继承而来，实现了CThread中的Run方法。 </p>
</li>
<li><p>CThreadPool是线程池类，其负责保存线程，释放线程以及调度线程。 </p>
</li>
<li><p>CThreadManage是线程池与用户的直接接口，其屏蔽了内部的具体实现。 </p>
</li>
<li><p>CThreadMutex用于线程之间的互斥。 </p>
</li>
<li><p>CCondition则是条件变量的封装，用于线程之间的同步。 </p>
</li>
</ul>
<p>线程池的时序很简单。CThreadManage直接跟客户端打交道，其接受需要创建的线程初始个数，并接受客户端提交的任务。这儿的任务是具体的非抽象的任务。CThreadManage的内部实际上调用的都是CThreadPool的相关操作。CThreadPool创建具体的线程，并把客户端提交的任务分发给CWorkerThread，CWorkerThread实际执行具体的任务。</p>
<h3 id="组件实现"><a href="#组件实现" class="headerlink" title="组件实现"></a>组件实现</h3><h4 id="CThreadManage"><a href="#CThreadManage" class="headerlink" title="CThreadManage"></a>CThreadManage</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CThreadManage</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    CThreadPool*    m_Pool; </span><br><span class="line">    <span class="keyword">int</span>          m_NumOfThread; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetParallelNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    CThreadManage();</span><br><span class="line">    CThreadManage(<span class="keyword">int</span> num);</span><br><span class="line">    <span class="keyword">virtual</span> ~CThreadManage();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">Run</span><span class="params">(CJob* job,<span class="keyword">void</span>* jobdata)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">TerminateAll</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中：m_Pool指向实际的线程池。m_NumOfThread是初始创建时候允许创建的并发的线程个数。另外Run和TerminateAll方法只是简单的调用CThreadPool的一些相关方法。具体实现如下: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CThreadManage::CThreadManage()&#123; </span><br><span class="line">    m_NumOfThread = <span class="number">10</span>; </span><br><span class="line">    m_Pool = <span class="keyword">new</span> CThreadPool(m_NumOfThread); </span><br><span class="line">&#125; </span><br><span class="line">CThreadManage::CThreadManage(<span class="keyword">int</span> num)&#123; </span><br><span class="line">    m_NumOfThread = num; </span><br><span class="line">    m_Pool = <span class="keyword">new</span> CThreadPool(m_NumOfThread); </span><br><span class="line">&#125; </span><br><span class="line">CThreadManage::~CThreadManage()&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != m_Pool)</span><br><span class="line">    <span class="keyword">delete</span> m_Pool;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CThreadManage::SetParallelNum(<span class="keyword">int</span> num)&#123; </span><br><span class="line">    m_NumOfThread = num; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CThreadManage::Run(CJob* job,<span class="keyword">void</span>* jobdata)&#123; </span><br><span class="line">    m_Pool-&gt;Run(job,jobdata); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CThreadManage::TerminateAll(<span class="keyword">void</span>)&#123; </span><br><span class="line">    m_Pool-&gt;TerminateAll(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CThread"><a href="#CThread" class="headerlink" title="CThread"></a>CThread</h4><p>CThread 类实现了对Linux中线程操作的封装，它是所有线程的基类，也是一个抽象类，提供了一个抽象接口Run，所有的CThread都必须实现该Run方法。CThread的定义如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CThread</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span>          m_ErrCode; </span><br><span class="line">    Semaphore    m_ThreadSemaphore;  <span class="comment">//the inner semaphore, which is used to realize </span></span><br><span class="line">    <span class="keyword">unsigned</span>     <span class="keyword">long</span> m_ThreadID;   </span><br><span class="line">    <span class="keyword">bool</span>         m_Detach;       <span class="comment">//The thread is detached </span></span><br><span class="line">    <span class="keyword">bool</span>         m_CreateSuspended;  <span class="comment">//if suspend after creating </span></span><br><span class="line">    <span class="keyword">char</span>*        m_ThreadName; </span><br><span class="line">    ThreadState m_ThreadState;      <span class="comment">//the state of the thread </span></span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetErrcode</span><span class="params">(<span class="keyword">int</span> errcode)</span></span>&#123;m_ErrCode = errcode;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">ThreadFunction</span><span class="params">(<span class="keyword">void</span>*)</span></span>; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CThread(); </span><br><span class="line">    CThread(<span class="keyword">bool</span> createsuspended,<span class="keyword">bool</span> detach); </span><br><span class="line">    <span class="keyword">virtual</span> ~CThread(); </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">(<span class="keyword">void</span>)</span> </span>= <span class="number">0</span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetThreadState</span><span class="params">(ThreadState state)</span></span>&#123;m_ThreadState = state;&#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">Terminate</span><span class="params">(<span class="keyword">void</span>)</span></span>;    <span class="comment">//Terminate the threa </span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">Start</span><span class="params">(<span class="keyword">void</span>)</span></span>;        <span class="comment">//Start to execute the thread </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">Exit</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">Wakeup</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">   </span><br><span class="line">    <span class="function">ThreadState  <span class="title">GetThreadState</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_ThreadState;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">GetLastError</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_ErrCode;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetThreadName</span><span class="params">(<span class="keyword">char</span>* thrname)</span></span>&#123;<span class="built_in">strcpy</span>(m_ThreadName,thrname);&#125; </span><br><span class="line">    <span class="function"><span class="keyword">char</span>*    <span class="title">GetThreadName</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_ThreadName;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">GetThreadID</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_ThreadID;&#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">SetPriority</span><span class="params">(<span class="keyword">int</span> priority)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">GetPriority</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">GetConcurrency</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetConcurrency</span><span class="params">(<span class="keyword">int</span> num)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">Detach</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">Join</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">Yield</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">Self</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>线程的状态可以分为四种，空闲、忙碌、挂起、终止(包括正常退出和非正常退出)。由于目前Linux线程库不支持挂起操作，因此，我们的此处的挂起操作类似于暂停。如果线程创建后不想立即执行任务，那么我们可以将其“暂停”，如果需要运行，则唤醒。有一点必须注意的是，一旦线程开始执行任务，将不能被挂起，其将一直执行任务至完毕。<br>线程类的相关操作均十分简单。线程的执行入口是从Start()函数开始，其将调用函数ThreadFunction，ThreadFunction再调用实际的Run函数，执行实际的任务。 </p>
<h4 id="CThreadPool"><a href="#CThreadPool" class="headerlink" title="CThreadPool"></a>CThreadPool</h4><p>CThreadPool是线程的承载容器，一般可以将其实现为堆栈、单向队列或者双向队列。在我们的系统中我们使用STL Vector对线程进行保存。CThreadPool的实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CThreadPool</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CWorkerThread</span>;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_MaxNum;   <span class="comment">//the max thread num that can create at the same time </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_AvailLow; <span class="comment">//The min num of idle thread that shoule kept </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_AvailHigh;    <span class="comment">//The max num of idle thread that kept at the same time </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_AvailNum; <span class="comment">//the normal thread num of idle num; </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_InitNum;  <span class="comment">//Normal thread num; </span></span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">    <span class="function">CWorkerThread* <span class="title">GetIdleThread</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">AppendToIdleList</span><span class="params">(CWorkerThread* jobthread)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">MoveToBusyList</span><span class="params">(CWorkerThread* idlethread)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">MoveToIdleList</span><span class="params">(CWorkerThread* busythread)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">DeleteIdleThread</span><span class="params">(<span class="keyword">int</span> num)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">CreateIdleThread</span><span class="params">(<span class="keyword">int</span> num)</span></span>; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CThreadMutex m_BusyMutex;    <span class="comment">//when visit busy list,use m_BusyMutex to lock and unlock </span></span><br><span class="line">    CThreadMutex m_IdleMutex;    <span class="comment">//when visit idle list,use m_IdleMutex to lock and unlock </span></span><br><span class="line">    CThreadMutex m_JobMutex; <span class="comment">//when visit job list,use m_JobMutex to lock and unlock </span></span><br><span class="line">    CThreadMutex m_VarMutex; </span><br><span class="line"></span><br><span class="line">    CCondition       m_BusyCond; <span class="comment">//m_BusyCond is used to sync busy thread list </span></span><br><span class="line">    CCondition       m_IdleCond; <span class="comment">//m_IdleCond is used to sync idle thread list </span></span><br><span class="line">    CCondition       m_IdleJobCond;  <span class="comment">//m_JobCond is used to sync job list </span></span><br><span class="line">    CCondition       m_MaxNumCond; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;CWorkerThread*&gt;   m_ThreadList; </span><br><span class="line">    <span class="built_in">vector</span>&lt;CWorkerThread*&gt;   m_BusyList;     <span class="comment">//Thread List </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;CWorkerThread*&gt;   m_IdleList; <span class="comment">//Idle List </span></span><br><span class="line"></span><br><span class="line">    CThreadPool(); </span><br><span class="line">    CThreadPool(<span class="keyword">int</span> initnum); </span><br><span class="line">    <span class="keyword">virtual</span> ~CThreadPool(); </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">SetMaxNum</span><span class="params">(<span class="keyword">int</span> maxnum)</span></span>&#123;m_MaxNum = maxnum;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetMaxNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_MaxNum;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">SetAvailLowNum</span><span class="params">(<span class="keyword">int</span> minnum)</span></span>&#123;m_AvailLow = minnum;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetAvailLowNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_AvailLow;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">SetAvailHighNum</span><span class="params">(<span class="keyword">int</span> highnum)</span></span>&#123;m_AvailHigh = highnum;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetAvailHighNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_AvailHigh;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetActualAvailNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_AvailNum;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetAllNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_ThreadList.size();&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetBusyNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_BusyList.size();&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">SetInitNum</span><span class="params">(<span class="keyword">int</span> initnum)</span></span>&#123;m_InitNum = initnum;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetInitNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_InitNum;&#125; </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">TerminateAll</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">Run</span><span class="params">(CJob* job,<span class="keyword">void</span>* jobdata)</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line">CThreadPool::CThreadPool() </span><br><span class="line">&#123; </span><br><span class="line">    m_MaxNum = <span class="number">50</span>; </span><br><span class="line">    m_AvailLow = <span class="number">5</span>; </span><br><span class="line">    m_InitNum=m_AvailNum = <span class="number">10</span> ;  </span><br><span class="line">    m_AvailHigh = <span class="number">20</span>; </span><br><span class="line"></span><br><span class="line">    m_BusyList.clear(); </span><br><span class="line">    m_IdleList.clear(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m_InitNum;i++)&#123; </span><br><span class="line">    CWorkerThread* thr = <span class="keyword">new</span> CWorkerThread(); </span><br><span class="line">    thr-&gt;SetThreadPool(<span class="keyword">this</span>); </span><br><span class="line">    AppendToIdleList(thr); </span><br><span class="line">    thr-&gt;Start(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">CThreadPool::CThreadPool(<span class="keyword">int</span> initnum) </span><br><span class="line">&#123; </span><br><span class="line">    assert(initnum&gt;<span class="number">0</span> &amp;&amp; initnum&lt;=<span class="number">30</span>); </span><br><span class="line">    m_MaxNum   = <span class="number">30</span>; </span><br><span class="line">    m_AvailLow = initnum<span class="number">-10</span>&gt;<span class="number">0</span>?initnum<span class="number">-10</span>:<span class="number">3</span>; </span><br><span class="line">    m_InitNum=m_AvailNum = initnum ;  </span><br><span class="line">    m_AvailHigh = initnum+<span class="number">10</span>; </span><br><span class="line"></span><br><span class="line">    m_BusyList.clear(); </span><br><span class="line">    m_IdleList.clear(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m_InitNum;i++)&#123; </span><br><span class="line">    CWorkerThread* thr = <span class="keyword">new</span> CWorkerThread(); </span><br><span class="line">    AppendToIdleList(thr); </span><br><span class="line">    thr-&gt;SetThreadPool(<span class="keyword">this</span>); </span><br><span class="line">    thr-&gt;Start();       <span class="comment">//begin the thread,the thread wait for job </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">CThreadPool::~CThreadPool() </span><br><span class="line">&#123; </span><br><span class="line">   TerminateAll(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CThreadPool::TerminateAll() </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; m_ThreadList.size();i++) &#123; </span><br><span class="line">    CWorkerThread* thr = m_ThreadList[i]; </span><br><span class="line">    thr-&gt;Join(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">CWorkerThread* CThreadPool::GetIdleThread(<span class="keyword">void</span>) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">while</span>(m_IdleList.size() ==<span class="number">0</span> ) </span><br><span class="line">    m_IdleCond.Wait(); </span><br><span class="line">   </span><br><span class="line">    m_IdleMutex.Lock(); </span><br><span class="line">    <span class="keyword">if</span>(m_IdleList.size() &gt; <span class="number">0</span> ) </span><br><span class="line">    &#123; </span><br><span class="line">    CWorkerThread* thr = (CWorkerThread*)m_IdleList.front(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Get Idle thread %dn"</span>,thr-&gt;GetThreadID()); </span><br><span class="line">    m_IdleMutex.Unlock(); </span><br><span class="line">    <span class="keyword">return</span> thr; </span><br><span class="line">    &#125; </span><br><span class="line">    m_IdleMutex.Unlock(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//add an idle thread to idle list </span></span><br><span class="line"><span class="keyword">void</span> CThreadPool::AppendToIdleList(CWorkerThread* jobthread) </span><br><span class="line">&#123; </span><br><span class="line">    m_IdleMutex.Lock(); </span><br><span class="line">    m_IdleList.push_back(jobthread); </span><br><span class="line">    m_ThreadList.push_back(jobthread); </span><br><span class="line">    m_IdleMutex.Unlock(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//move and idle thread to busy thread </span></span><br><span class="line"><span class="keyword">void</span> CThreadPool::MoveToBusyList(CWorkerThread* idlethread) </span><br><span class="line">&#123; </span><br><span class="line">    m_BusyMutex.Lock(); </span><br><span class="line">    m_BusyList.push_back(idlethread); </span><br><span class="line">    m_AvailNum--; </span><br><span class="line">    m_BusyMutex.Unlock(); </span><br><span class="line">  </span><br><span class="line">    m_IdleMutex.Lock(); </span><br><span class="line">    <span class="built_in">vector</span>&lt;CWorkerThread*&gt;::iterator pos; </span><br><span class="line">    pos = find(m_IdleList.begin(),m_IdleList.end(),idlethread); </span><br><span class="line">    <span class="keyword">if</span>(pos !=m_IdleList.end()) </span><br><span class="line">    m_IdleList.erase(pos); </span><br><span class="line">    m_IdleMutex.Unlock(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CThreadPool::MoveToIdleList(CWorkerThread* busythread) </span><br><span class="line">&#123; </span><br><span class="line">    m_IdleMutex.Lock(); </span><br><span class="line">    m_IdleList.push_back(busythread); </span><br><span class="line">    m_AvailNum++; </span><br><span class="line">    m_IdleMutex.Unlock(); </span><br><span class="line"></span><br><span class="line">    m_BusyMutex.Lock(); </span><br><span class="line">    <span class="built_in">vector</span>&lt;CWorkerThread*&gt;::iterator pos; </span><br><span class="line">    pos = find(m_BusyList.begin(),m_BusyList.end(),busythread); </span><br><span class="line">    <span class="keyword">if</span>(pos!=m_BusyList.end()) </span><br><span class="line">    m_BusyList.erase(pos); </span><br><span class="line">    m_BusyMutex.Unlock(); </span><br><span class="line"></span><br><span class="line">    m_IdleCond.Signal(); </span><br><span class="line">    m_MaxNumCond.Signal(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//create num idle thread and put them to idlelist </span></span><br><span class="line"><span class="keyword">void</span> CThreadPool::CreateIdleThread(<span class="keyword">int</span> num) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123; </span><br><span class="line">    CWorkerThread* thr = <span class="keyword">new</span> CWorkerThread(); </span><br><span class="line">    thr-&gt;SetThreadPool(<span class="keyword">this</span>); </span><br><span class="line">    AppendToIdleList(thr); </span><br><span class="line">    m_VarMutex.Lock(); </span><br><span class="line">    m_AvailNum++; </span><br><span class="line">    m_VarMutex.Unlock(); </span><br><span class="line">    thr-&gt;Start();       <span class="comment">//begin the thread,the thread wait for job </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CThreadPool::DeleteIdleThread(<span class="keyword">int</span> num) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter into CThreadPool::DeleteIdleThreadn"</span>); </span><br><span class="line">    m_IdleMutex.Lock(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Delete Num is %dn"</span>,num); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123; </span><br><span class="line">    CWorkerThread* thr; </span><br><span class="line">    <span class="keyword">if</span>(m_IdleList.size() &gt; <span class="number">0</span> )&#123; </span><br><span class="line">            thr = (CWorkerThread*)m_IdleList.front(); </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Get Idle thread %dn"</span>,thr-&gt;GetThreadID()); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;CWorkerThread*&gt;::iterator pos; </span><br><span class="line">    pos = find(m_IdleList.begin(),m_IdleList.end(),thr); </span><br><span class="line">    <span class="keyword">if</span>(pos!=m_IdleList.end()) </span><br><span class="line">        m_IdleList.erase(pos); </span><br><span class="line">    m_AvailNum--; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The idle thread available num:%d n"</span>,m_AvailNum); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The idlelist              num:%d n"</span>,m_IdleList.size()); </span><br><span class="line">    &#125; </span><br><span class="line">    m_IdleMutex.Unlock(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CThreadPool::Run(CJob* job,<span class="keyword">void</span>* jobdata) </span><br><span class="line">&#123; </span><br><span class="line">    assert(job!=<span class="literal">NULL</span>); </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//if the busy thread num adds to m_MaxNum,so we should wait </span></span><br><span class="line">    <span class="keyword">if</span>(GetBusyNum() == m_MaxNum) </span><br><span class="line">        m_MaxNumCond.Wait(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m_IdleList.size()&lt;m_AvailLow) </span><br><span class="line">    &#123; </span><br><span class="line">    <span class="keyword">if</span>(GetAllNum()+m_InitNum-m_IdleList.size() &lt; m_MaxNum ) </span><br><span class="line">        CreateIdleThread(m_InitNum-m_IdleList.size()); </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        CreateIdleThread(m_MaxNum-GetAllNum()); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    CWorkerThread*  idlethr = GetIdleThread(); </span><br><span class="line">    <span class="keyword">if</span>(idlethr !=<span class="literal">NULL</span>) </span><br><span class="line">    &#123; </span><br><span class="line">    idlethr-&gt;m_WorkMutex.Lock(); </span><br><span class="line">    MoveToBusyList(idlethr); </span><br><span class="line">    idlethr-&gt;SetThreadPool(<span class="keyword">this</span>); </span><br><span class="line">    job-&gt;SetWorkThread(idlethr); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Job is set to thread %d n"</span>,idlethr-&gt;GetThreadID()); </span><br><span class="line">    idlethr-&gt;SetJob(job,jobdata); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在CThreadPool中存在两个链表，一个是空闲链表，一个是忙碌链表。Idle链表中存放所有的空闲进程，当线程执行任务时候，其状态变为忙碌状态，同时从空闲链表中删除，并移至忙碌链表中。在CThreadPool的构造函数中，我们将执行下面的代码: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m_InitNum;i++) </span><br><span class="line">&#123; </span><br><span class="line">    CWorkerThread* thr = <span class="keyword">new</span> CWorkerThread(); </span><br><span class="line">    AppendToIdleList(thr); </span><br><span class="line">    thr-&gt;SetThreadPool(<span class="keyword">this</span>); </span><br><span class="line">    thr-&gt;Start();       <span class="comment">//begin the thread,the thread wait for job </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该代码中，我们将创建m_InitNum个线程，创建之后即调用AppendToIdleList放入Idle链表中，由于目前没有任务分发给这些线程，因此线程执行Start后将自己挂起。<br>事实上，线程池中容纳的线程数目并不是一成不变的，其会根据执行负载进行自动伸缩。为此在CThreadPool中设定四个变量：<br>m_InitNum：处世创建时线程池中的线程的个数。<br>m_MaxNum:当前线程池中所允许并发存在的线程的最大数目。<br>m_AvailLow:当前线程池中所允许存在的空闲线程的最小数目，如果空闲数目低于该值，表明负载可能过重，此时有必要增加空闲线程池的数目。实现中我们总是将线程调整为m_InitNum个。<br>m_AvailHigh：当前线程池中所允许的空闲的线程的最大数目，如果空闲数目高于该值，表明当前负载可能较轻，此时将删除多余的空闲线程，删除后调整数也为m_InitNum个。<br>m_AvailNum：目前线程池中实际存在的线程的个数，其值介于m_AvailHigh和m_AvailLow之间。如果线程的个数始终维持在m_AvailLow和m_AvailHigh之间，则线程既不需要创建，也不需要删除，保持平衡状态。因此如何设定m_AvailLow和m_AvailHigh的值，使得线程池最大可能的保持平衡态，是线程池设计必须考虑的问题。<br>线程池在接受到新的任务之后，线程池首先要检查是否有足够的空闲池可用。检查分为三个步骤：<br>      (1)检查当前处于忙碌状态的线程是否达到了设定的最大值m_MaxNum，如果达到了，表明目前没有空闲线程可用，而且也不能创建新的线程，因此必须等待直到有线程执行完毕返回到空闲队列中。<br>      (2)如果当前的空闲线程数目小于我们设定的最小的空闲数目m_AvailLow，则我们必须创建新的线程，默认情况下，创建后的线程数目应该为m_InitNum，因此创建的线程数目应该为( 当前空闲线程数与m_InitNum);但是有一种特殊情况必须考虑，就是现有的线程总数加上创建后的线程数可能超过m_MaxNum，因此我们必须对线程的创建区别对待。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(GetAllNum()+m_InitNum-m_IdleList.size() &lt; m_MaxNum ) </span><br><span class="line">         CreateIdleThread(m_InitNum-m_IdleList.size()); </span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">         CreateIdleThread(m_MaxNum-GetAllNum());</span><br></pre></td></tr></table></figure>
<p>如果创建后总数不超过m_MaxNum，则创建后的线程为m_InitNum；如果超过了，则只创建( m_MaxNum-当前线程总数 )个。<br>      (3)调用GetIdleThread方法查找空闲线程。如果当前没有空闲线程，则挂起；否则将任务指派给该线程，同时将其移入忙碌队列。<br>当线程执行完毕后，其会调用MoveToIdleList方法移入空闲链表中，其中还调用m_IdleCond.Signal()方法，唤醒GetIdleThread()中可能阻塞的线程。 </p>
<h4 id="CWorkerThread"><a href="#CWorkerThread" class="headerlink" title="CWorkerThread"></a>CWorkerThread</h4><p>CWorkerThread是CThread的派生类，是事实上的工作线程。在CThreadPool的构造函数中，我们创建了一定数量的CWorkerThread。一旦这些线程创建完毕，我们将调用Start()启动该线程。Start方法最终会调用Run方法。Run方法是个无限循环的过程。在没有接受到实际的任务的时候，m_Job为NULL，此时线程将调用Wait方法进行等待，从而处于挂起状态。一旦线程池将具体的任务分发给该线程，其将被唤醒，从而通知线程从挂起的地方继续执行。CWorkerThread的完整定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CWorkerThread</span>:</span><span class="keyword">public</span> CThread </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    CThreadPool*  m_ThreadPool; </span><br><span class="line">    CJob*    m_Job; </span><br><span class="line">    <span class="keyword">void</span>*    m_JobData; </span><br><span class="line">   </span><br><span class="line">    CThreadMutex m_VarMutex; </span><br><span class="line">    <span class="keyword">bool</span>      m_IsEnd; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CCondition   m_JobCond; </span><br><span class="line">    CThreadMutex m_WorkMutex; </span><br><span class="line">    CWorkerThread(); </span><br><span class="line">    <span class="keyword">virtual</span> ~CWorkerThread(); </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">SetJob</span><span class="params">(CJob* job,<span class="keyword">void</span>* jobdata)</span></span>; </span><br><span class="line">    <span class="function">CJob*   <span class="title">GetJob</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_Job;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">SetThreadPool</span><span class="params">(CThreadPool* thrpool)</span></span>; </span><br><span class="line">    <span class="function">CThreadPool* <span class="title">GetThreadPool</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_ThreadPool;&#125; </span><br><span class="line">&#125;; </span><br><span class="line">CWorkerThread::CWorkerThread() </span><br><span class="line">&#123; </span><br><span class="line">    m_Job = <span class="literal">NULL</span>; </span><br><span class="line">    m_JobData = <span class="literal">NULL</span>; </span><br><span class="line">    m_ThreadPool = <span class="literal">NULL</span>; </span><br><span class="line">    m_IsEnd = <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line">CWorkerThread::~CWorkerThread() </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != m_Job) </span><br><span class="line">    <span class="keyword">delete</span> m_Job; </span><br><span class="line">    <span class="keyword">if</span>(m_ThreadPool != <span class="literal">NULL</span>) </span><br><span class="line">    <span class="keyword">delete</span> m_ThreadPool; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CWorkerThread::Run() </span><br><span class="line">&#123; </span><br><span class="line">    SetThreadState(THREAD_RUNNING); </span><br><span class="line">    <span class="keyword">for</span>(;;) </span><br><span class="line">    &#123; </span><br><span class="line">    <span class="keyword">while</span>(m_Job == <span class="literal">NULL</span>) </span><br><span class="line">        m_JobCond.Wait(); </span><br><span class="line"></span><br><span class="line">    m_Job-&gt;Run(m_JobData); </span><br><span class="line">    m_Job-&gt;SetWorkThread(<span class="literal">NULL</span>); </span><br><span class="line">    m_Job = <span class="literal">NULL</span>; </span><br><span class="line">    m_ThreadPool-&gt;MoveToIdleList(<span class="keyword">this</span>); </span><br><span class="line">    <span class="keyword">if</span>(m_ThreadPool-&gt;m_IdleList.size() &gt; m_ThreadPool-&gt;GetAvailHighNum()) </span><br><span class="line">    &#123; </span><br><span class="line">m_ThreadPool-&gt;DeleteIdleThread(m_ThreadPool-&gt;m_IdleList.size()-m_T </span><br><span class="line">hreadPool-&gt;GetInitNum()); </span><br><span class="line">    &#125; </span><br><span class="line">    m_WorkMutex.Unlock(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CWorkerThread::SetJob(CJob* job,<span class="keyword">void</span>* jobdata) </span><br><span class="line">&#123; </span><br><span class="line">    m_VarMutex.Lock(); </span><br><span class="line">    m_Job = job; </span><br><span class="line">    m_JobData = jobdata; </span><br><span class="line">    job-&gt;SetWorkThread(<span class="keyword">this</span>); </span><br><span class="line">    m_VarMutex.Unlock(); </span><br><span class="line">    m_JobCond.Signal(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CWorkerThread::SetThreadPool(CThreadPool* thrpool) </span><br><span class="line">&#123; </span><br><span class="line">    m_VarMutex.Lock(); </span><br><span class="line">    m_ThreadPool = thrpool; </span><br><span class="line">    m_VarMutex.Unlock(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当线程执行任务之前首先必须判断空闲线程的数目是否低于m_AvailLow，如果低于，则必须创建足够的空闲线程，使其数目达到m_InitNum个，然后将调用MoveToBusyList()移出空闲队列，移入忙碌队列。当任务执行完毕后，其又调用MoveToIdleList()移出忙碌队列，移入空闲队列，等待新的任务。<br>      除了Run方法之外，CWorkerThread中另外一个重要的方法就是SetJob，该方法将实际的任务赋值给线程。当没有任何执行任务即m_Job为NULL的时候，线程将调用m_JobCond.Wait进行等待。一旦Job被赋值给线程，其将调用m_JobCond.Signal方法唤醒该线程。由于m_JobCond属于线程内部的变量，每个线程都维持一个m_JobCond，只有得到任务的线程才被唤醒，没有得到任务的将继续等待。无论一个线程何时被唤醒，其都将从等待的地方继续执行m_Job-&gt;Run(m_JobData)，这是线程执行实际任务的地方。<br>      在线程执行给定Job期间，我们必须防止另外一个Job又赋给该线程，因此在赋值之前，通过m_VarMutex进行锁定， Job执行期间，其于的Job将不能关联到该线程；任务执行完毕，我们调用m_VarMutex.Unlock()进行解锁，此时，线程又可以接受新的执行任务。<br>在线程执行任务结束后返回空闲队列前，我们还需要判断当前空闲队列中的线程是否高于m_AvailHigh个。如果超过m_AvailHigh，则必须从其中删除(m_ThreadPool-&gt;m_IdleList.size()-m_ThreadPool-&gt;GetInitNum())个线程，使线程数目保持在m_InitNum个。 </p>
<h4 id="CJob"><a href="#CJob" class="headerlink" title="CJob"></a>CJob</h4><p>CJob类相对简单，其封装了任务的基本的属性和方法，其中最重要的是Run方法，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CJob</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span>      m_JobNo;        <span class="comment">//The num was assigned to the job </span></span><br><span class="line">    <span class="keyword">char</span>*    m_JobName;      <span class="comment">//The job name </span></span><br><span class="line">    CThread  *m_pWorkThread;     <span class="comment">//The thread associated with the job </span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CJob( <span class="keyword">void</span> ); </span><br><span class="line">    <span class="keyword">virtual</span> ~CJob(); </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">GetJobNo</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_JobNo; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetJobNo</span><span class="params">(<span class="keyword">int</span> jobno)</span></span>&#123; m_JobNo = jobno;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">char</span>*    <span class="title">GetJobName</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_JobName; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetJobName</span><span class="params">(<span class="keyword">char</span>* jobname)</span></span>; </span><br><span class="line">    <span class="function">CThread *<span class="title">GetWorkThread</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="keyword">return</span> m_pWorkThread; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetWorkThread</span> <span class="params">( CThread *pWorkThread )</span></span>&#123; </span><br><span class="line">        m_pWorkThread = pWorkThread; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Run</span> <span class="params">( <span class="keyword">void</span> *ptr )</span> </span>= <span class="number">0</span>; </span><br><span class="line">&#125;; </span><br><span class="line">CJob::CJob(<span class="keyword">void</span>) </span><br><span class="line">:m_pWorkThread(<span class="literal">NULL</span>) </span><br><span class="line">,m_JobNo(<span class="number">0</span>) </span><br><span class="line">,m_JobName(<span class="literal">NULL</span>) </span><br><span class="line">&#123; </span><br><span class="line">&#125; </span><br><span class="line">CJob::~CJob()&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != m_JobName) </span><br><span class="line">    <span class="built_in">free</span>(m_JobName); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CJob::SetJobName(<span class="keyword">char</span>* jobname) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> !=m_JobName)    &#123; </span><br><span class="line">        <span class="built_in">free</span>(m_JobName); </span><br><span class="line">        m_JobName = <span class="literal">NULL</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> !=jobname)    &#123; </span><br><span class="line">        m_JobName = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(jobname)+<span class="number">1</span>); </span><br><span class="line">        <span class="built_in">strcpy</span>(m_JobName,jobname); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池使用示例"><a href="#线程池使用示例" class="headerlink" title="线程池使用示例"></a>线程池使用示例</h3><p>至此我们给出了一个简单的与具体任务无关的线程池框架。使用该框架非常的简单，我们所需要的做的就是派生CJob类，将需要完成的任务实现在Run方法中。然后将该Job交由CThreadManage去执行。下面我们给出一个简单的示例程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CXJob</span>:</span><span class="keyword">public</span> CJob </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CXJob()&#123;i=<span class="number">0</span>;&#125; </span><br><span class="line">    ~CXJob()&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(<span class="keyword">void</span>* jobdata)</span>    </span>&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The Job comes from CXJOB\n"</span>); </span><br><span class="line">        sleep(<span class="number">2</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CYJob</span>:</span><span class="keyword">public</span> CJob </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CYJob()&#123;i=<span class="number">0</span>;&#125; </span><br><span class="line">    ~CYJob()&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(<span class="keyword">void</span>* jobdata)</span>    </span>&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The Job comes from CYJob\n"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">main() </span><br><span class="line">&#123; </span><br><span class="line">    CThreadManage* manage = <span class="keyword">new</span> CThreadManage(<span class="number">10</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++) </span><br><span class="line">    &#123; </span><br><span class="line">        CXJob*   job = <span class="keyword">new</span> CXJob(); </span><br><span class="line">        manage-&gt;Run(job,<span class="literal">NULL</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    sleep(<span class="number">2</span>); </span><br><span class="line">    CYJob* job = <span class="keyword">new</span> CYJob(); </span><br><span class="line">    manage-&gt;Run(job,<span class="literal">NULL</span>); </span><br><span class="line">    manage-&gt;TerminateAll(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CXJob和CYJob都是从Job类继承而来，其都实现了Run接口。CXJob只是简单的打印一句”The Job comes from CXJob”，CYJob也只打印”The Job comes from CYJob”，然后均休眠2秒钟。在主程序中我们初始创建10个工作线程。然后分别执行40次CXJob和一次CYJob。</p>
<h2 id="C-11线程池"><a href="#C-11线程池" class="headerlink" title="C++11线程池"></a>C++11线程池</h2><p>100行代码，源自 <a href="https://github.com/progschj/ThreadPool" target="_blank" rel="noopener">GitHub</a> .这个线程池的任务要用future获取返回值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadPool.h c++11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ThreadPool(<span class="keyword">size_t</span>);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">auto</span> <span class="title">enqueue</span>(<span class="title">F</span>&amp;&amp; <span class="title">f</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>)</span></span><br><span class="line"><span class="class">        -&gt; <span class="title">std</span>:</span>:future&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;F(Args...)&gt;::type&gt;;</span><br><span class="line">    ~ThreadPool();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// need to keep track of threads so we can join them</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::thread &gt; workers;</span><br><span class="line">    <span class="comment">// the task queue</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt; <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; &gt; tasks;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// synchronization</span></span><br><span class="line">    <span class="built_in">std</span>::mutex queue_mutex;</span><br><span class="line">    <span class="built_in">std</span>::condition_variable condition;</span><br><span class="line">    <span class="keyword">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the constructor just launches some amount of workers</span></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::ThreadPool(<span class="keyword">size_t</span> threads)</span><br><span class="line">    :   stop(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i&lt;threads;++i)</span><br><span class="line">        workers.emplace_back(</span><br><span class="line">            [<span class="keyword">this</span>]</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(;;)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; task;</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">                        <span class="keyword">this</span>-&gt;condition.wait(lock,</span><br><span class="line">                            [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.empty(); &#125;);</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.empty())</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        task = <span class="built_in">std</span>::move(<span class="keyword">this</span>-&gt;tasks.front());</span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks.pop();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    task();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add new work item to the pool</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">auto</span> <span class="title">ThreadPool</span>:</span>:enqueue(F&amp;&amp; f, Args&amp;&amp;... args) </span><br><span class="line">    -&gt; <span class="built_in">std</span>::future&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;F(Args...)&gt;::type&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> return_type = <span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;F(Args...)&gt;::type;</span><br><span class="line">    <span class="comment">//return_type是函数返回值，return_type()就可以作为packaged_task的模板参数</span></span><br><span class="line">    </span><br><span class="line">		<span class="comment">//packaged_task可以用bind构造，比如：packaged_task task(bind(f,1));</span></span><br><span class="line">		<span class="comment">//make_shared将函数参数构造为模板类型，并指向构造后的对象。</span></span><br><span class="line">		<span class="comment">//使用shared_ptr的原因是下面lambda表达式将这个task指针传入了tasks队列的Function对象，值传递引用计数+1，等任务被执行后，task才被析构。</span></span><br><span class="line">    <span class="keyword">auto</span> task = <span class="built_in">std</span>::make_shared&lt; <span class="built_in">std</span>::packaged_task&lt;return_type()&gt; &gt;(</span><br><span class="line">            <span class="built_in">std</span>::bind(<span class="built_in">std</span>::forward&lt;F&gt;(f), <span class="built_in">std</span>::forward&lt;Args&gt;(args)...)</span><br><span class="line">        );</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::future&lt;return_type&gt; res = task-&gt;get_future();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(queue_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don't allow enqueueing after stopping the pool</span></span><br><span class="line">        <span class="keyword">if</span>(stop)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"enqueue on stopped ThreadPool"</span>);</span><br><span class="line"></span><br><span class="line">        tasks.emplace([task]()&#123; (*task)(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    condition.notify_one();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the destructor joins all threads</span></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::~ThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(queue_mutex);</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    condition.notify_all();</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::thread &amp;worker: workers)</span><br><span class="line">        worker.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ThreadPool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; &gt; results;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        results.emplace_back(</span><br><span class="line">            pool.enqueue([i] &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"world "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> i*i;</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;&amp; result: results)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C-C++/C++Collection/C++algorithm" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/20/C-C++/C++Collection/C++algorithm/" class="article-date">
      <time datetime="2019-03-20T07:51:15.000Z" itemprop="datePublished">2019-03-20</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/20/C-C++/C++Collection/C++algorithm/">c++algorithm</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="c-算法库"><a href="#c-算法库" class="headerlink" title="c++算法库"></a>c++算法库</h1><h2 id="不修改元素的序列操作"><a href="#不修改元素的序列操作" class="headerlink" title="不修改元素的序列操作"></a>不修改元素的序列操作</h2><p>序列操作的前两个参数都是指向序列首尾的迭代器。</p>
<table>
<thead>
<tr>
<th>all_of(C++11)<br>any_of(C++11)<br>none_of(C++11)</th>
<th>checks if a predicate is true for all, any or none <br>of the elements in a range</th>
</tr>
</thead>
<tbody>
<tr>
<td>for_each</td>
<td>applies a function to a range of elements</td>
</tr>
<tr>
<td>for_each_n(C++17)</td>
<td>applies a function object <strong><em>to the first n elements</em></strong> of a sequence</td>
</tr>
<tr>
<td>count<br>count_if</td>
<td>returns the number of elements satisfying specific criteria</td>
</tr>
<tr>
<td>mismatch</td>
<td>finds the first position where two ranges differ</td>
</tr>
<tr>
<td>find<br>find_if<br>find_if_not(C++11)</td>
<td>finds the first element satisfying specific criteria</td>
</tr>
<tr>
<td>find_end</td>
<td>finds the last sequence of elements in a certain range</td>
</tr>
<tr>
<td>find_first_of</td>
<td>searches for any one of a set of elements<br>在第一个范围内找存在于第二个范围内的任何一个数。</td>
</tr>
<tr>
<td>adjacent_find</td>
<td>finds the first two adjacent items that are equal <br>(or satisfy a given predicate)</td>
</tr>
<tr>
<td>search</td>
<td>searches for a range of elements<br>find是找一个数，search是找一个序列。</td>
</tr>
<tr>
<td>search_n</td>
<td>searches a range for a number of consecutive copies of an element</td>
</tr>
</tbody>
</table>
<h2 id="会修改元素的序列操作"><a href="#会修改元素的序列操作" class="headerlink" title="会修改元素的序列操作"></a>会修改元素的序列操作</h2><table>
<thead>
<tr>
<th>copy<br>copy_if(C++11)</th>
<th>copies a range of elements to a new location</th>
</tr>
</thead>
<tbody>
<tr>
<td>copy_n(C++11)</td>
<td>copies a number of elements to a new location</td>
</tr>
<tr>
<td>copy_backward</td>
<td>copies a range of elements in backwards order</td>
</tr>
<tr>
<td>move(C++11)</td>
<td>moves a range of elements to a new location</td>
</tr>
<tr>
<td>move_backward(C++11)</td>
<td>moves a range of elements to a new location in backwards order</td>
</tr>
<tr>
<td>fill</td>
<td>copy-assigns the given value to every element in a range</td>
</tr>
<tr>
<td>fill_n</td>
<td>copy-assigns the given value to N elements in a range</td>
</tr>
<tr>
<td>transform</td>
<td>applies a function to a range of elements</td>
</tr>
<tr>
<td>generate</td>
<td>assigns the results of successive function calls to every element in a range</td>
</tr>
<tr>
<td>generate_n</td>
<td>assigns the results of successive function calls to N elements in a range</td>
</tr>
<tr>
<td>remove<br>remove_if</td>
<td>removes elements satisfying specific criteria</td>
</tr>
<tr>
<td>remove_copy<br>remove_copy_if</td>
<td>copies a range of elements omitting those that satisfy specific criteria</td>
</tr>
<tr>
<td>replace<br>replace_if</td>
<td>replaces all values satisfying specific criteria with another value</td>
</tr>
<tr>
<td>replace_copy<br>replace_copy_if</td>
<td>copies a range, replacing elements satisfying specific criteria with another value</td>
</tr>
<tr>
<td>swap</td>
<td>swaps the values of two objects</td>
</tr>
<tr>
<td>swap_ranges</td>
<td>swaps two ranges of elements</td>
</tr>
<tr>
<td>iter_swap</td>
<td>swaps the elements pointed to by two iterators</td>
</tr>
<tr>
<td>reverse</td>
<td>reverses the order of elements in a range</td>
</tr>
<tr>
<td>reverse_copy</td>
<td>creates a copy of a range that is reversed</td>
</tr>
<tr>
<td>rotate</td>
<td>rotates the order of elements in a range</td>
</tr>
<tr>
<td>rotate_copy</td>
<td>copies and rotate a range of elements</td>
</tr>
<tr>
<td>shift_left(C++20)<br>shift_right(C++20)</td>
<td>shifts elements in a range</td>
</tr>
<tr>
<td>random_shuffle<br>(until C++17)<br>shuffle(C++11)</td>
<td>randomly re-orders elements in a range</td>
</tr>
<tr>
<td>sample(C++17)</td>
<td>selects n random elements from a sequence</td>
</tr>
<tr>
<td>unique</td>
<td>removes consecutive duplicate elements in a range</td>
</tr>
<tr>
<td>unique_copy</td>
<td>creates a copy of some range of elements that contains no consecutive duplicates</td>
</tr>
</tbody>
</table>
<h2 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h2><table>
<thead>
<tr>
<th>is_partitioned(C++11)</th>
<th>determines if the range is partitioned by the given predicate</th>
</tr>
</thead>
<tbody>
<tr>
<td>partition</td>
<td>divides a range of elements into two groups,<br><strong>returns</strong> iterator to the first element of the second group.</td>
</tr>
<tr>
<td>partition_copy(C++11)</td>
<td>copies a range dividing the elements into two groups</td>
</tr>
<tr>
<td>stable_partition</td>
<td>divides elements into two groups while preserving their relative order</td>
</tr>
<tr>
<td>partition_point(C++11)</td>
<td>locates the partition point of a partitioned range</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">std</span>::partition(v.begin(), v.end(), [](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;&#125;);</span><br><span class="line"><span class="built_in">std</span>::copy(<span class="built_in">std</span>::begin(v), it, <span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" * "</span>;</span><br><span class="line"><span class="built_in">std</span>::copy(it,<span class="built_in">std</span>::end(v), <span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>基于排序的算法，基本上都可以增加一个参数，即比较函数。</p>
<p>需要随机访问迭代器。</p>
<table>
<thead>
<tr>
<th>is_sorted(C++11)</th>
<th>checks whether a range is sorted into ascending order</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_sorted_until(C++11)</td>
<td>finds the largest sorted subrange</td>
</tr>
<tr>
<td>sort</td>
<td>sorts a range into ascending order</td>
</tr>
<tr>
<td>partial_sort</td>
<td>sorts the first N elements of a range</td>
</tr>
<tr>
<td>partial_sort_copy</td>
<td>copies and partially sorts a range of elements</td>
</tr>
<tr>
<td>stable_sort</td>
<td>(稳定排序)sorts a range of elements while preserving order between equal elements</td>
</tr>
<tr>
<td>nth_element</td>
<td>partially sorts the given range making sure that it is partitioned by the given element</td>
</tr>
</tbody>
</table>
<p><strong>partial_sort:</strong></p>
<p>partial_sort(first, middle, last);</p>
<p>其实就是类似<em>用堆找第K大数</em>的方法，先 <code>make_heap(first, middle)</code>，然后不断比较替换堆顶，最后<code>sort_heap(first, heap);</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找出[first,last)中6个最小的元素，并且排序在[first,middle)，其余部分无序</span></span><br><span class="line">partial_sort(v.begin(), v.begin()+<span class="number">6</span>, v.end());</span><br></pre></td></tr></table></figure>
<p><strong>nth_element:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nth_element</span><span class="params">( RandomIt first, RandomIt nth, RandomIt last )</span></span>;</span><br></pre></td></tr></table></figure>
<p>排序后a[n]就是数列中第n+1大的数（下标从0開始计数），a[start,n)中的数肯定不大于a[n,end]中的数。但是a[start,n), a[n,end]内的大小顺序还不一定。<strong>并不返回值。</strong></p>
<p><strong>partial_sort_copy:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">partial_sort_copy( InputIt first, InputIt last, RandomIt d_first, RandomIt d_last );</span><br></pre></td></tr></table></figure>
<p>将排序后的内容复制到新的地方。输入输出迭代器范围的一大一小会产生不同效果，见如下例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v0&#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"> </span><br><span class="line">    it = <span class="built_in">std</span>::partial_sort_copy(v0.begin(), v0.end(), v1.begin(), v1.end());</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Writing to the smaller vector in ascending order gives: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a : v1) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">if</span>(it == v1.end())</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The return value is the end iterator\n"</span>;</span><br><span class="line"> </span><br><span class="line">    it = <span class="built_in">std</span>::partial_sort_copy(v0.begin(), v0.end(), v2.begin(), v2.end(), </span><br><span class="line">                                <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Writing to the larger vector in descending order gives: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a : v2) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> &lt;&lt; <span class="string">"The return value is the iterator to "</span> &lt;&lt; *it &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Writing to the smaller vector in ascending order gives: 1 2 3</span><br><span class="line">The return value is the end iterator</span><br><span class="line">Writing to the larger vector in descending order gives: 5 4 3 2 1 15 16</span><br><span class="line">The return value is the iterator to 15</span><br></pre></td></tr></table></figure>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><strong>前提是已经排序。</strong></p>
<table>
<thead>
<tr>
<th>binary_search</th>
<th>determines if an element exists in a certain range</th>
</tr>
</thead>
<tbody>
<tr>
<td>lower_bound</td>
<td>returns an iterator to the first element <strong><em>not less</em></strong> than the given value</td>
</tr>
<tr>
<td>upper_bound</td>
<td>returns an iterator to the first element <strong><em>greater</em></strong> than a certain value</td>
</tr>
<tr>
<td>equal_range</td>
<td>returns range of elements matching a specific key</td>
</tr>
</tbody>
</table>
<p><strong>equal_range:</strong></p>
<p>试图在已排序的[first,last)中寻找value，它返回一对迭代器i和j，其中i是在不破坏次序的前提下，value可插入的第一个位置（亦即lower_bound），j则是在不破坏次序的前提下，value可插入的最后一个位置（亦即upper_bound），因此，[i,j)内的每个元素都等同于value，而且[i,j)是[first,last)之中符合此一性质的最大子区间。</p>
<h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><table>
<thead>
<tr>
<th>merge</th>
<th>merges two sorted ranges</th>
</tr>
</thead>
<tbody>
<tr>
<td>inplace_merge</td>
<td>merges two ordered ranges in-place</td>
</tr>
</tbody>
</table>
<p><strong>inplace_merge:</strong></p>
<p>Merges two consecutive sorted ranges <code>[first, middle)</code> and <code>[middle, last)</code> into one sorted range <code>[first, last)</code></p>
<p>用inplace_merge<strong>实现归并排序</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">merge_sort</span>(<span class="title">Iter</span> <span class="title">first</span>, <span class="title">Iter</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (last - first &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Iter middle = first + (last - first) / <span class="number">2</span>;</span><br><span class="line">        merge_sort(first, middle);</span><br><span class="line">        merge_sort(middle, last);</span><br><span class="line">        <span class="built_in">std</span>::inplace_merge(first, middle, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">8</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    merge_sort(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n : v) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><table>
<thead>
<tr>
<th>includes</th>
<th>returns true if one set is a subset of another</th>
</tr>
</thead>
<tbody>
<tr>
<td>set_difference</td>
<td>computes the difference between two sets</td>
</tr>
<tr>
<td>set_intersection</td>
<td>computes the intersection of two sets</td>
</tr>
<tr>
<td>set_symmetric_difference</td>
<td>computes the symmetric difference between two sets</td>
</tr>
<tr>
<td>set_union</td>
<td>computes the union of two sets</td>
</tr>
</tbody>
</table>
<p><strong>set_开头的函数</strong>的第五个参数是一个输出迭代器，可以用输出容器的插入迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s1&#123;<span class="string">"3"</span>,<span class="string">"2"</span>,<span class="string">"1"</span>&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s2&#123;<span class="string">"2"</span>&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s3;</span><br><span class="line">	</span><br><span class="line">set_difference(s1.begin(), s1.end(), s2.begin(), s2.end(), </span><br><span class="line">               insert_iterator&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt;(s3,s3.begin()));</span><br><span class="line">copy(s3.begin(),s3.end(),ostream_iterator&lt;<span class="built_in">string</span>, <span class="keyword">char</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));</span><br><span class="line"><span class="comment">//output: 1 3</span></span><br></pre></td></tr></table></figure>
<p><strong>set_symmetric_difference:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>  &#125;;</span><br><span class="line">&#123;  <span class="number">2</span>,    <span class="number">5</span>,    <span class="number">7</span>&#125;;</span><br><span class="line"><span class="comment">//set_symmetric_difference</span></span><br><span class="line">&#123;<span class="number">1</span>,  <span class="number">3</span>,<span class="number">4</span>,  <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>排序算法基本默认都是递增的，而堆排序如果要递增排序的话，则是建立最大堆，这就是我理解的默认是建立最大堆而不是最小堆的原因。</p>
<table>
<thead>
<tr>
<th>is_heap(C++11)</th>
<th>checks if the given range is a max heap</th>
</tr>
</thead>
<tbody>
<tr>
<td>is_heap_until(C++11)</td>
<td>finds the largest subrange that is a max heap</td>
</tr>
<tr>
<td>make_heap</td>
<td>creates a max heap out of a range of elements</td>
</tr>
<tr>
<td>push_heap</td>
<td>inserts the element at the position <code>last-1</code> into the <em>max heap</em></td>
</tr>
<tr>
<td>pop_heap</td>
<td>swaps <code>first</code> and  <code>last-1</code> and makes the subrange <code>[first, last-1)</code> into a <em>max heap</em>.</td>
</tr>
<tr>
<td>sort_heap</td>
<td>turns a max heap into a range of elements sorted in ascending order</td>
</tr>
</tbody>
</table>
<p>example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v &#123; <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span> &#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"initially      : "</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::make_heap(v.begin(), v.end());</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after make_heap: "</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::pop_heap(v.begin(), v.end());</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after pop_heap : "</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">std</span>::push_heap(v.begin(), v.end());</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after push_heap: "</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">std</span>::sort_heap(v.begin(), v.end());</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after sort_heap: "</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : v) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initially      : 3 1 4 1 5 9 </span><br><span class="line">after make_heap: 9 5 4 1 1 3 </span><br><span class="line">after pop_heap : 5 3 4 1 1 9 </span><br><span class="line">after push_heap: 9 3 5 1 1 4 </span><br><span class="line">after sort_heap: 1 1 3 4 5 9</span><br></pre></td></tr></table></figure>
<h2 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h2><table>
<thead>
<tr>
<th>max</th>
<th>returns the greater of the given values</th>
</tr>
</thead>
<tbody>
<tr>
<td>max_element</td>
<td>returns the largest element in a range</td>
</tr>
<tr>
<td>min</td>
<td>returns the smaller of the given values</td>
</tr>
<tr>
<td>min_element</td>
<td>returns the smallest element in a range</td>
</tr>
</tbody>
</table>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><table>
<thead>
<tr>
<th>equal</th>
<th>determines if two sets of elements are the same</th>
</tr>
</thead>
<tbody>
<tr>
<td>lexicographical_compare</td>
<td>returns true if one range is lexicographically less than another</td>
</tr>
</tbody>
</table>
<h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><table>
<thead>
<tr>
<th>is_permutation(C++11)</th>
<th>determines if a sequence is a permutation of another sequence</th>
</tr>
</thead>
<tbody>
<tr>
<td>next_permutation</td>
<td>generates the next greater lexicographic permutation of a range of elements</td>
</tr>
<tr>
<td>prev_permutation</td>
<td>generates the next smaller lexicographic permutation of a range of elements</td>
</tr>
</tbody>
</table>
<p><strong>next_permutation:</strong></p>
<p>Transforms the range <code>[first, last)</code> into the next permutation from the set of all permutations that are lexicographically ordered with respect to <code>operator&lt;</code> or <code>comp</code>. Returns true if such permutation exists, otherwise transforms the range into the first permutation (as if by <code>std::sort(first, last)</code>) and returns false.</p>
<p><strong>prev_permutation</strong>类似，都是反过来。</p>
<p>example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3,5,4,1,2 is a permutation of 1,2,3,4,5? "</span></span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::boolalpha</span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::is_permutation(v1.begin(), v1.end(), v2.begin()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3,5,4,1,1 is a permutation of 1,2,3,4,5? "</span></span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::boolalpha</span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::is_permutation(v1.begin(), v1.end(), v3.begin()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span> is a permutation of <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>? <span class="literal">true</span></span><br><span class="line"><span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span> is a permutation of <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>? <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Network/Unp/unp笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/17/Network/Unp/unp笔记/" class="article-date">
      <time datetime="2019-03-17T07:01:56.000Z" itemprop="datePublished">2019-03-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/17/Network/Unp/unp笔记/">《unp》笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="《unp》笔记"><a href="#《unp》笔记" class="headerlink" title="《unp》笔记"></a>《unp》笔记</h2><p>以前读的《Unix网络编程》，最近整理一下概念性的知识点。</p>
<h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p><img src="http://118.25.53.128/Picture/Unp/unp01.jpg" alt="unp01"></p>
<p>TCP和UDP之间留有空隙，表明网络应用是可以直接绕过传输层使用IPv4或IPv6的。这就是所谓的原始套接字。</p>
<p>本书所讲的套接字编程是从顶上三层进入传输层的接口。</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="TCP特性"><a href="#TCP特性" class="headerlink" title="TCP特性"></a>TCP特性</h4><ul>
<li><p>TCP含有用于动态估算客户和服务器之间的<strong>RTT</strong>的算法，以便知道它等待一个确认需要多少时间。</p>
<ul>
<li>RTT-(round-trip time) 往返时间。RTT在一个局域网上大约是几毫秒，广域网则可能数秒。</li>
</ul>
</li>
<li><p>TCP通过给其中每个字节关联一个<strong>序列号</strong>对所发送的数据进行排序。</p>
<p>接收端可以按顺序重排或丢弃重复。</p>
</li>
<li><p>TCP提供<strong>流量控制</strong></p>
<p>TCP总是告知对端在任何时刻它一次能够从对端接收多少字节的数据，这称为<strong>窗口通告</strong>。</p>
</li>
<li><p>TCP是<strong>全双工</strong>的。</p>
</li>
</ul>
<h4 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h4><p><img src="http://118.25.53.128/Picture/Unp/unp02.jpg" alt="unp02"></p>
<ol>
<li><p>服务器必须准备好接受外来的连接。这称为<strong>被动打开</strong>。</p>
<p>通常需要socket、bind、listen。</p>
</li>
<li><p>客户端通过调用connect发起<strong>主动打开</strong>。</p>
<p>客户端发送一个SYN(同步)分节，它告诉服务器客户将在连接中发送的数据的<strong>初始序列号</strong>。</p>
<p>通常SYN分节不携带数据，其所在IP数据报只含有一个IP首部、一个TCP首部、可能有的TCP选项。</p>
</li>
<li><p>服务器确认(ACK)客户端的SYN，同时自己也发送一个SYN分节。</p>
</li>
<li><p>客户端确认(ACK)服务器的SYN。</p>
</li>
</ol>
<hr>
<p><strong>PS：</strong>ACK中的确认号是发送这个ACK的一端所期待的下一个序列号。</p>
<p>​    因为SYN分节占据一个字节的序列号空间，所以每一个SYN的ACK中的确认号就是该SYN的初始序列号加1.</p>
<p>​    类似地，每一个FIN的ACK也这样。</p>
<h4 id="TCP选项"><a href="#TCP选项" class="headerlink" title="TCP选项"></a>TCP选项</h4><p>每一个SYN可以含有多个TCP选项。</p>
<ul>
<li><strong>MSS选项</strong>。通告对端它的最大分节大小(maximum segment size)，也就是在本次连接的每个TCP分节中愿意接受的最大数据量。</li>
<li><strong>窗口规模选项</strong>。TCP连接任何一端能够通告对端的最大窗口大小是65535(2^16 -1)，因为在TCP首部中相应的字段占16位。但是当今因特网上有时需要更大的窗口以获得更大的吞吐量。这个新选项指定TCP首部中的通告窗口必须扩大的位数(0~14)。因此所提供的最大窗口接近1GB(<code>65535*2^14</code>)</li>
<li><strong>时间戳选项</strong>。作为网络编程人员无需考虑。</li>
</ul>
<h4 id="TCP连接终止"><a href="#TCP连接终止" class="headerlink" title="TCP连接终止"></a>TCP连接终止</h4><p><img src="http://118.25.53.128/Picture/Unp/unp03.jpg" alt="unp03"></p>
<ol>
<li><strong>主动关闭</strong>。调用close，于是发送一个FIN分节表示数据发送完毕。</li>
<li><strong>被动关闭</strong>。客户端的FIN由TCP确认，它的接收也作为一个文件结束符(EOF，end-of-file)传递给接收端应用进程。</li>
<li>一段时间后，接收到EOF的应用进程将调用close关闭它的套接字，这导致它的TCP也发送一个FIN。</li>
<li>确认服务器的FIN。</li>
</ol>
<hr>
<p>每个方向都需要一个FIN和一个ACK。<strong>通常</strong>终止一个连接需要4个分节。但是：</p>
<ul>
<li>某些情况下步骤1的FIN随数据一起发送；</li>
<li>步骤2和步骤3发送的分节可能被合并成一个分节。</li>
</ul>
<h4 id="TCP连接的分组交换"><a href="#TCP连接的分组交换" class="headerlink" title="TCP连接的分组交换"></a>TCP连接的分组交换</h4><p><img src="http://118.25.53.128/Picture/Unp/unp04.jpg" alt="unp04"></p>
<ul>
<li>服务器对客户请求的ACK是伴随其数据应答发送的，这种做法称为捎带，它通常在服务器处理请求并应答的时间少于200ms时发生的，如果服务器耗时更长，那么我们将看到先是确认后是应答。</li>
</ul>
<h5 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h5><p>该状态持续2MSL时间。</p>
<p><strong>MSL</strong>是Maximum Segment Lifetime英文的缩写，中文可以译为“<strong>报文最大生存时间</strong>”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。</p>
<p>区别于<strong>TTL</strong>：tcp报文（segment）是ip数据报（datagram）的数据部分，而ip头中有一个<strong>TTL</strong>域(time to live)，这个生存时间是由源主机设置初始值，存储了一个ip数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。</p>
<p><strong>为什么要等待2MSL时间？</strong></p>
<ol>
<li><p>可靠地实现TCP全双工连接的终止</p>
<p>主要目的是怕最后一个ACK包对方没收到，那么对方在超时后(1MSL)将重发FIN包，主动关闭端接收到(1MSL)重发的FIN包后可以再发一个ACK应答包。</p>
</li>
<li><p>允许老的重复分节在网络中消逝</p>
<p>我们假设在关闭一个连接，过一段时间后在相同的IP和端口之间建立另一个连接，后一个连接称为前一个连接的<strong>化身</strong>。通过设置2MSL的TIME_WAIT状态，我们就可以确保每次成功建立一个TCP连接时，来自该连接先前化身的老的重复分组都已在网络中消失了。</p>
<p>这个规则存在一个例外：如果到达的SYN的序列号大于前一化身的结束序列号，源自Berkeley的实现将给当前处于TIME_WAIT状态的连接启动新的化身。</p>
</li>
<li><p>在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。</p>
</li>
</ol>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><h4 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h4><p>客户在调用函数connect之前不必非得调用bind函数。如果需要，内核会确定源IP地址，并选择一个临时端口。</p>
<p>如果是TCP套接字，调用connect将激发三路握手，仅在成功或者出错时返回，返回错误有三种情况：</p>
<ol>
<li><p>若<strong>客户没有收到SYN分节的响应</strong>，则返回<code>ETIMEDOUT</code>错误。</p>
<p>一般的实现无响应等待6s后再发送一个，若仍无响应则等24s发送一个。若等了75s仍未响应，则返回本错误。</p>
</li>
<li><p>若<strong>客户的SYN响应是RST</strong>，则表明服务器在指定端口没有进程在等待连接(也许服务器根本没运行)。</p>
<p>这是一种<em>硬错误</em>，马上返回<code>ECONNREFUSED</code>错误。</p>
</li>
<li><p>若客户发出的SYN在某个路由器上引发了”目的地不可达”ICMP错误，则认为是一种<em>软错误</em>，并按照第一种情况继续发送。若等了75s仍未响应，则把保存的消息(ICMP错误)作为<code>EHOSTUNREACH</code>或<code>ENETUNREACH</code>错误返回给进程。</p>
<p>对于第三种，以下两种情况也是可能的：</p>
<ul>
<li>按照本地系统的转发表，根本没有到达远程系统的路径</li>
<li>connect调用根本不等待就返回</li>
</ul>
</li>
</ol>
<p><strong>注意：如果connect()失败</strong>，必须close该套接字，不可对它再次调用connect。</p>
<h5 id="产生RST的三个条件"><a href="#产生RST的三个条件" class="headerlink" title="产生RST的三个条件"></a>产生RST的三个条件</h5><ol>
<li>目的地为某端口的SYN到达，但是该端口上没有正在监听的服务器。</li>
<li>TCP想取消某个连接。</li>
<li>TCP收到一个根本不存在的连接上的分节。</li>
</ol>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p>bind把一个本地协议地址赋予一个套接字，对于TCP则是IP和端口号的组合。</p>
<p>对于TCP，可以都指定、也可以只指定一个、也可以都不指定。</p>
<ul>
<li>端口号赋0可以让内核选择端口，使用通配地址(INADDR_ANY，也就是0)可以让内核选择地址。</li>
<li>一般服务器要定端口，不定ip；客户端都不需要定。</li>
</ul>
<p>从bind返回的常见错误就是<code>EADDRINUSE</code> 地址已使用。</p>
<h4 id="listen"><a href="#listen" class="headerlink" title="listen()"></a>listen()</h4><p>listen仅由TCP服务器调用，它做两件事：</p>
<ol>
<li>当socket()创建一个套接字时，它被假设为一个主动套接字，listen()把一个未连接的套接字转化为一个被动套接字。</li>
<li>本函数的第二个参数<em>规定</em>了内核应该为相应套接字排队的最大连接个数。</li>
</ol>
<p>内核为任何一个给定的监听套接字维护两个队列：</p>
<ul>
<li>未完成连接队列：SYN已收到，正在完成三路握手。SYN_RECD状态。</li>
<li>已完成连接队列：已经完成三路握手。ESTABLISHED状态。</li>
</ul>
<p><img src="Picture/unp05.jpg" alt="unp05"></p>
<p><img src="Picture/unp06.jpg" alt="unp06"></p>
<p>如果三路握手完成，该项就从未完成队列移动到已完成队列队尾。当进程调用accept()时，已完成队列的队头将返回给进程；或者该队列为空，那么进程睡眠等待唤醒。</p>
<p>当一个客户SYN到达时，如果队列是满的，那么TCP就忽略该分节，而不发送RST。因为这么做是暂时的，客户会重发SYN分节。</p>
<h4 id="accept"><a href="#accept" class="headerlink" title="accept()"></a>accept()</h4><p>如果accept成功，那么其返回值是内核生成的全新的描述符（<em>已连接套接字</em>，区别于<em>监听套接字</em>），代表与所返回客户的TCP连接。</p>
<h3 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h3><h4 id="SO-KEEPALIVE"><a href="#SO-KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h4><p>设置后，如果两小时内在该套接字的任一方向上都没有数据交换，TCP 就会自动给对端发送一个<strong>保持存活探测分节</strong>(keep-alive probe)。这是一个对端必须响应的 TCP 分节，它会导致以下三种情况之一：</p>
<ol>
<li><p>ACK。</p>
</li>
<li><p>RST，返回 <code>ECONNRESET</code> 错误。</p>
</li>
<li><p>没有任何响应，隔一段时间再发送几次，还没有响应则放弃，返回 <code>ETIMEOUT</code> 错误。</p>
<p>然而如果套接字收到一个 ICMP 错误作为某个探测分节的响应，则返回相应的错误。</p>
</li>
</ol>
<h4 id="SO-LINGER"><a href="#SO-LINGER" class="headerlink" title="SO_LINGER"></a>SO_LINGER</h4><p>可以改变close的行为。</p>
<p>本选项要求在用户进程与内核间传递如下结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> l_onoff;	<span class="comment">// 0 = off, nonzero = on</span></span><br><span class="line">  <span class="keyword">int</span> l_linger;	<span class="comment">// linger time, seconds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>如果 <code>l_onoff</code> 为 0，即关闭本选项，TCP 默认设置生效，close 立即返回。</p>
</li>
<li><p>如果 <code>l_onoff</code> 非 0，</p>
<ul>
<li><p><code>l_linger</code> 为 0，TCP 将丢弃套接字发送缓冲区的数据，并发送一个 RST 给对端，没有四次挥手。</p>
</li>
<li><p><code>l_linger</code> 非 0，如果在套接字发送缓冲区仍有数据，那么进程将睡眠，直到：(a)所有数据都发送完且被确认，(b) <code>l_linger</code> 延滞时间到。</p>
<p>如果是因为延滞时间到，那么返回 <code>EWOULDBLOCK</code> 错误。</p>
</li>
</ul>
<p>如果套接字设置了<strong><em>非阻塞</em></strong>，那么它将不等待 <code>close</code> 完成，即使延滞时间非 0 也是如此。</p>
</li>
</ol>
<p><strong>总结来说，当关闭客户端时，可以在以下3个不同的时机返回：</strong></p>
<ol>
<li><code>close</code> 立即返回。</li>
<li><code>close</code> 一直拖延直到接收了对于客户端 FIN 的 ACK 才返回。</li>
<li>后跟一个 read 调用的 写关闭<code>shutdown</code> 一直等到接收了对端的 FIN 才返回。</li>
</ol>
<h4 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h4><p>默认情况下 Nagle 算法是开启的，本选项可以关闭此算法。</p>
<h5 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h5><p><strong><em>目的</em></strong>：减少广域网(WAN)上小分组的数目。</p>
<p><strong><em>内容</em></strong>：如果某个给定连接上有待确认数据，那么原本应该作为用户写操作响应的在该连接上立即发送相应小分组的行为就不会发生，直到现有数据被确认为止。</p>
<p>这里”小”分组的定义就是小于 MSS 的任何分组，TCP 总是尽可能地发送最大大小的分组。</p>
<h5 id="ACK-延滞算法"><a href="#ACK-延滞算法" class="headerlink" title="ACK 延滞算法"></a>ACK 延滞算法</h5><p>Nagle 算法通常与 ACK 延滞算法联合使用。</p>
<p><strong><em>内容</em></strong>：TCP 在接收到数据后不立即发送 ACK，而是等待一小段时间才发送 ACK。TCP 期待在这一小段时间内自身有数据要发送回对端，被延滞的 ACK 就可以由这些数据捎带，从而省掉一个 TCP 分节。</p>
<h5 id="不适合的情况"><a href="#不适合的情况" class="headerlink" title="不适合的情况"></a>不适合的情况</h5><ul>
<li><p>在快速的<strong><em>局域网</em></strong>上，我们通常不会注意到 Nagle 算法对客户进程的影响，然而在<strong><em>广域网</em></strong>上，小分组所需的确认时间可能长达一秒，本来就有的延迟被 Nagle 算法进一步放大。</p>
</li>
<li><p>对于服务器不在相反方向产生数据以便携带 ACK 的情况，客户可能察觉到明显的延迟。</p>
</li>
<li><p>客户以若干小片数据向服务器发送单个逻辑请求，比如发送一个 4 字节的请求类型后跟 396 字节的请求数据。</p>
<p>如果客户先执行 4 字节的 write 调用，再执行 396 字节的 write 调用，那么第二个写操作的数据将一直等到服务器的 TCP 确认了第一个写操作的 4 字节数据后才由客户的 TCP 发送出去。</p>
<p>如果服务器需要接收到 400 字节才进行操作，此时服务器的 TCP 将延滞该 4 字节的 ACK。</p>
<p>有<strong><em>三种办法修正</em></strong>这类程序：</p>
<ol>
<li>使用 writev 而不是调用两次 write，（首选方法）。</li>
<li>把两次数据复制到单个缓冲区，然后对该缓冲区调用一次 write。</li>
<li>设置 TCP_NODELAY 套接字选项。但是这最不可取，有损网络。</li>
</ol>
</li>
</ul>
<h3 id="Socket-Errno"><a href="#Socket-Errno" class="headerlink" title="Socket Errno"></a>Socket Errno</h3><p><a href="https://blog.csdn.net/huangwei858/article/details/47723613" target="_blank" rel="noopener">https://blog.csdn.net/huangwei858/article/details/47723613</a></p>
<p><a href="https://blog.csdn.net/u010629326/article/details/76021420" target="_blank" rel="noopener">https://blog.csdn.net/u010629326/article/details/76021420</a></p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unp/"><unp></unp></a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Algorithm/逆元" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/14/Algorithm/逆元/" class="article-date">
      <time datetime="2019-03-14T12:31:21.000Z" itemprop="datePublished">2019-03-14</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/14/Algorithm/逆元/">逆元</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="逆元（inv）"><a href="#逆元（inv）" class="headerlink" title="逆元（inv）"></a>逆元（inv）</h3><h4 id="什么是逆元"><a href="#什么是逆元" class="headerlink" title="什么是逆元"></a>什么是逆元</h4><p>当求解公式：(a/b)%m 时，因b可能会过大，会出现爆精度的情况，所以需变除法为乘法：</p>
<p>设c是b的逆元，则有<code>b*c≡1(mod m)</code>；</p>
<p>则<code>(a/b)%m = (a/b)*1%m = (a/b)*b*c%m = a*c(mod m)</code>;</p>
<p>即a/b的模等于a*c的模；</p>
<h4 id="求逆元的方法"><a href="#求逆元的方法" class="headerlink" title="求逆元的方法"></a>求逆元的方法</h4><h5 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h5><p>当p为质数时候，<code>a^(p-1)≡1(mod p)</code></p>
<p>所以 <code>a^(p-2)</code> 是 a 的逆元</p>
<p>复杂度O(logn)。</p>
<p>例子 p=1000000007</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000009</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">quickpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">    a %= mod;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ret = (ret * a) % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">inv</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> quickpow(a, mod - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="阶乘的逆元"><a href="#阶乘的逆元" class="headerlink" title="阶乘的逆元"></a>阶乘的逆元</h4><p>记数字 x 的逆元为f(x)</p>
<p>因为 <code>n! = (n-1)! * n</code></p>
<p>所以 <code>f(n!) = f( (n-1)! * n) = f( (n-1)! ) * f(n)</code></p>
<p>所以 <code>f( (n-1)! ) = f(n!) * n</code>  (逆元的逆元就是他自身)</p>
<p>这样子我们就可以用后项推出前面的项了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阶乘</span></span><br><span class="line">fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++)</span><br><span class="line">    fac[i] = (fac[i<span class="number">-1</span>]*i)%MOD;</span><br><span class="line"><span class="comment">//逆元</span></span><br><span class="line">inv[MAXN<span class="number">-1</span>] = quickpow(fac[MAXN<span class="number">-1</span>], MOD<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = MAXN<span class="number">-2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    inv[i] = (inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>))%MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C-C++/C++Collection/C++线程库" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/14/C-C++/C++Collection/C++线程库/" class="article-date">
      <time datetime="2019-03-14T07:35:04.000Z" itemprop="datePublished">2019-03-14</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/14/C-C++/C++Collection/C++线程库/">C++线程库</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="C-11线程库"><a href="#C-11线程库" class="headerlink" title="C++11线程库"></a>C++11线程库</h1><p>线程相关库整体上分为几大块：线程类，锁类（以及锁的管理类），条件变量类，future类</p>
<p>锁有互斥锁、定时锁、递归锁、读写锁。</p>
<p>本篇学习自官方文档，所以中英穿插。</p>
<h2 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h2><h3 id="thread类-C-11"><a href="#thread类-C-11" class="headerlink" title="thread类(C++11)"></a>thread类(C++11)</h3><p>Defined in header <code>&lt;thread&gt;</code></p>
<p>No two <code>std::thread</code> objects may represent the same thread of execution; <code>std::thread</code> is not <em>CopyConstructible</em> or <em>CopyAssignable</em>, although it is <em>MoveConstructible</em> and <em>MoveAssignable</em>.</p>
<h4 id="thread-id类"><a href="#thread-id类" class="headerlink" title="thread::id类"></a>thread::id类</h4><p>The class <code>thread::id</code> is a lightweight, trivially copyable class that serves as a unique identifier of <code>std::thread</code> objects.</p>
<p>只定义了 比较运算符 和 输出用的&lt;&lt;运算符。线程用<code>get_id()</code>可获取。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(foo)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::thread::id t1_id = t1.get_id();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"t1's id: "</span> &lt;&lt; t1_id &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">t1.join();</span><br></pre></td></tr></table></figure>
<h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates new thread object which does not represent a thread.</span></span><br><span class="line">thread() <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Move constructor</span></span><br><span class="line">thread( thread&amp;&amp; other ) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//constructor 3</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Function</span>, <span class="title">class</span>... <span class="title">Args</span> &gt; </span></span><br><span class="line"><span class="class"><span class="title">explicit</span> <span class="title">thread</span>( <span class="title">Function</span>&amp;&amp; <span class="title">f</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//The copy constructor is deleted; threads are not copyable. </span></span><br><span class="line">thread(<span class="keyword">const</span> thread&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
<p><strong>//constructor 3</strong></p>
<p>Creates new <code>std::thread</code> object and associates it with a thread of execution. The new thread of execution starts executing </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::invoke(decay_copy(<span class="built_in">std</span>::forward&lt;Function&gt;(f)), </span><br><span class="line">            decay_copy(<span class="built_in">std</span>::forward&lt;Args&gt;(args))...);</span><br></pre></td></tr></table></figure>
<p>where <code>decay_copy</code> is defined as </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="keyword">decay_t</span>&lt;T&gt; decay_copy(T&amp;&amp; v) &#123; <span class="keyword">return</span> <span class="built_in">std</span>::forward&lt;T&gt;(v); &#125;</span><br></pre></td></tr></table></figure>
<p>注意，假如是按值传递对象参数，那么传递给thread的参数时第一次拷贝，decay_copy时候再拷贝一次，接下来如果线程函数的参数是引用，则不再拷贝，如果线程函数的参数是值，那么再拷贝一次。</p>
<p>所以一共会进行2次或3次的拷贝。</p>
<p>如果想传递引用，只能用<code>std::ref</code>。</p>
<p><strong>example</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> &amp;n)</span></span>&#123;&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::thread t1; <span class="comment">// t1 is not a thread</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(f1, n + <span class="number">1</span>)</span></span>; <span class="comment">// pass by value</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t3</span><span class="params">(f2, <span class="built_in">std</span>::ref(n))</span></span>; <span class="comment">// pass by reference</span></span><br></pre></td></tr></table></figure>
<h4 id="Observers"><a href="#Observers" class="headerlink" title="Observers"></a>Observers</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">joinable</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">std</span>::thread::<span class="function">id <span class="title">get_id</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Returns the implementation defined underlying thread handle.</span></span><br><span class="line"><span class="function">native_handle_type <span class="title">native_handle</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//Returns the number of concurrent threads supported by the implementation. The value should be considered only a hint.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">hardware_concurrency</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>PS:</strong></p>
<p><strong>线程ID</strong>: 唯一标识线程</p>
<p><strong>线程句柄</strong>: 基本上，所有操作线程的windowsAPI均使用线程句柄。每多一个句柄，线程对象就多一个引用计数，当引用计数为0时，线程对象将被系统回收。<em>一个线程对象可以有很多个句柄指向它</em>。</p>
<h4 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Blocks the current thread until the thread identified by *this finishes its execution.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Separates the thread of execution from the thread object, allowing execution to continue independently. Any allocated resources will be freed once the thread exits.</span></span><br><span class="line"><span class="comment">//join()函数在那个thread对象上不能再被调用，因为它已经不再和一个执行的线程相关联。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//swaps two thread objects</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">( thread&amp; other )</span></span>;</span><br></pre></td></tr></table></figure>
<p>去销毁一个仍然可以“joinable”的C++线程对象会被认为是一种错误。为了销毁一个C++线程对象，要么join()函数被调用（并结束），要么detach()函数被调用。<strong>如果一个C++线程对象当销毁时仍然可以被join，异常会被抛出。</strong></p>
<p><strong>在<code>std::thread</code>的析构函数中，<code>std::terminate</code>会被调用如果线程没有join或者detach。!!!</strong></p>
<hr>
<p>当一个程序终止时（比如main返回），剩下的在后台的detached线程执行不会再等待；相反它们的执行会被挂起并且它们的本地线程对象会被销毁。</p>
<p>关键地，这意味着这些线程的栈不是完好无损的，因此一些析构函数不会被执行。所以：</p>
<ul>
<li><p>请使用 join</p>
</li>
<li><p>除非你需要更灵活并且想要独立地提供一种同步机制来等待线程完成，在这种情况下你应该使用detach</p>
</li>
</ul>
<h3 id="this-thread"><a href="#this-thread" class="headerlink" title="this_thread::"></a>this_thread::</h3><p>Defined in namespace <code>std::this_thread</code></p>
<table>
<thead>
<tr>
<th>yield()</th>
<th>suggests that the implementation reschedule execution of threads</th>
</tr>
</thead>
<tbody>
<tr>
<td>get_id()</td>
<td>returns the thread id of the current thread</td>
</tr>
<tr>
<td>sleep_for()</td>
<td>stops the execution of the current thread for a specified time duration</td>
</tr>
<tr>
<td>sleep_until()</td>
<td>stops the execution of the current thread until a specified time point</td>
</tr>
</tbody>
</table>
<p><strong>yield()：</strong></p>
<p>对具体实现（<strong>译注</strong>：具体实现指的是操作系统的调度器）提出一个提醒以重新规划线程的执行，即让其他线程先运行。</p>
<p>该方法的具体行为取决于实现，尤其是正在使用的操作系统调度器的机制以及系统的状态。比如，一个先进先出的实时调度器（Linux中的SCHED_FIFO）将会使当前线程暂停，并将其置于同优先级线程队列的末尾（如果同优先级线程队列里没有其他线程，yield就没有效果了。）</p>
<p><strong>sleep_for()：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::this_thread::sleep_for;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono_literals;</span><br><span class="line">sleep_for(<span class="number">2</span>s);</span><br></pre></td></tr></table></figure>
<h3 id="thread-local"><a href="#thread-local" class="headerlink" title="thread_local"></a>thread_local</h3><ul>
<li>The storage for the object is allocated when the thread begins and deallocated when the thread ends. </li>
<li>Each thread has its own instance of the object. </li>
<li><code>thread_local</code> can appear together with <code>static</code> or <code>extern</code> to adjust linkage.</li>
</ul>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><strong>多线程下的volatile</strong>   </p>
<p>当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。</p>
<p>如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。</p>
<p>volatile的意思是<strong>让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值</strong>。</p>
<h2 id="Mutual-exclusion"><a href="#Mutual-exclusion" class="headerlink" title="Mutual exclusion"></a>Mutual exclusion</h2><p>有互斥锁、定时锁、递归锁、读写锁。</p>
<h3 id="lt-mutex-gt"><a href="#lt-mutex-gt" class="headerlink" title="&lt;mutex&gt;"></a><code>&lt;mutex&gt;</code></h3><p>Defined in header <code>&lt;mutex&gt;</code></p>
<p>Mutual exclusion algorithms prevent multiple threads from simultaneously accessing shared resources. This prevents data races and provides support for synchronization between threads.</p>
<h4 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mutex m;	<span class="comment">//construct</span></span><br><span class="line">m.lock();	<span class="comment">//locks the mutex, blocks if the mutex is not available</span></span><br><span class="line">m.unlock();	<span class="comment">//unlock</span></span><br><span class="line">m.try_lock();	<span class="comment">//tries to lock the mutex, returns true if the lock was acquired successfully, otherwise false.</span></span><br></pre></td></tr></table></figure>
<p><strong>Notes</strong></p>
<ul>
<li><p>mutex is not copy-assignable </p>
</li>
<li><p>If <code>lock()</code> is called by a thread that already owns the <code>mutex</code>, the behavior is undefined.</p>
</li>
<li><p><code>std::mutex</code> is usually not accessed directly: std::unique_lock, std::lock_guard, or std::scoped_lock (since C++17) manage locking in a more exception-safe manner.</p>
</li>
</ul>
<h4 id="timed-mutex"><a href="#timed-mutex" class="headerlink" title="timed_mutex"></a>timed_mutex</h4><p>多了两个方法：<code>try_lock_for</code> 和 <code>try_lock_until</code>，介绍一下前者，后者类似。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Rep</span>, <span class="title">class</span> <span class="title">Period</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">try_lock_for</span>( <span class="title">const</span> <span class="title">std</span>:</span>:chrono::duration&lt;Rep,Period&gt;&amp; timeout_duration );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Tries to lock the mutex. Blocks until specified <code>timeout_duration</code> has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false. </p>
</li>
<li><p>If <code>timeout_duration</code> is less or equal <code>timeout_duration.zero()</code>, the function behaves like try_lock().</p>
</li>
</ul>
<h4 id="recursive-mutex"><a href="#recursive-mutex" class="headerlink" title="recursive_mutex"></a>recursive_mutex</h4><p>比起 mutex，没有新增成员方法。</p>
<p><strong>递归锁</strong>：同一个线程可以多次获得该资源锁，别的线程必须等该线程释放所有次数的锁才可以获得。</p>
<p><strong>递归锁的作用</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">recursive_mutex mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    mutex.lock();  </span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    mutex.unlock();  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mutex.lock();</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    foo();</span><br><span class="line">    mutex.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foo函数和bar函数都获取了同一个锁，而bar函数又会调用foo函数。如果MutexLock锁是个非递归锁，则这个程序会立即死锁。因此在为一段程序加锁时要格外小心，否则很容易因为这种调用关系而造成死锁。 </p>
<p><strong>但不建议使用</strong></p>
<p>递归锁用起来固然简单，但往往会隐藏某些代码问题。因此在能使用非递归锁的情况下，应该尽量使用非递归锁，因为死锁相对来说，更容易通过调试发现。程序设计如果有问题，应该暴露的越早越好。</p>
<h4 id="recursive-timed-mutex"><a href="#recursive-timed-mutex" class="headerlink" title="recursive_timed_mutex"></a>recursive_timed_mutex</h4><p>顾名思义，无需解释。</p>
<h3 id="lt-shared-mutex-gt"><a href="#lt-shared-mutex-gt" class="headerlink" title="&lt;shared_mutex&gt;"></a><code>&lt;shared_mutex&gt;</code></h3><p>即读写锁</p>
<h4 id="shared-mutex"><a href="#shared-mutex" class="headerlink" title="shared_mutex"></a>shared_mutex</h4><p>In contrast to other mutex types which facilitate exclusive access, a shared_mutex has two levels of access:</p>
<ul>
<li><p><em>shared</em> - several threads can share ownership of the same mutex.</p>
</li>
<li><p><em>exclusive</em> - only one thread can own the mutex.</p>
</li>
</ul>
<p>Shared mutexes are usually used in situations when multiple readers can access the same resource at the same time without causing data races, but only one writer can do so.</p>
<p>分为写锁定和读锁定：</p>
<ul>
<li><p>Exclusive locking</p>
<p><code>lock()</code>、<code>try_lock()</code>、<code>unlock()</code></p>
</li>
<li><p>Shared locking</p>
<p><code>lock_shared()</code>、<code>try_lock_shared()</code>、<code>unlock_shared()</code></p>
</li>
</ul>
<h4 id="shared-timed-mutex"><a href="#shared-timed-mutex" class="headerlink" title="shared_timed_mutex"></a>shared_timed_mutex</h4><p>类似的，加了四个方法：</p>
<p><code>try_lock_for()</code>、<code>try_lock_until()</code></p>
<p><code>try_lock_shared_for()</code>、<code>try_lock_shared_until()</code></p>
<h3 id="management"><a href="#management" class="headerlink" title="management"></a>management</h3><p>Defined in header <code>&lt;mutex&gt;</code></p>
<p>这些管理对象只有构造函数和析构函数。</p>
<p>构造时传入mutex对象，并且试图调用静态方法<code>lock()</code>（有重载），当管理对象离开它的作用域时会被析构，析构时会调用静态方法<code>unlock()</code>。</p>
<h4 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h4><p>最基本的。构造函数只能接受一个mutex。</p>
<h4 id="scoped-lock-C-17"><a href="#scoped-lock-C-17" class="headerlink" title="scoped_lock(C++17)"></a>scoped_lock(C++17)</h4><p>deadlock-avoiding RAII wrapper for multiple mutexes.</p>
<p>据stackoverflow上所说，<code>boost::mutex::scoped_lock</code> is a typedef for <code>boost::unique_lock&lt;boost::mutex&gt;</code>。</p>
<p>其实就是实现RAII语义的包装类，没什么特点。</p>
<p><em>和 lock_guard 比，它的构造函数使用了可变参数模板，可以接受多个mutex。</em></p>
<h4 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h4><h4 id="shared-lock"><a href="#shared-lock" class="headerlink" title="shared_lock"></a>shared_lock</h4><p>这两个一起讲，因为它们的<em>方法名</em>都一样，比起上面两个管理器：</p>
<ul>
<li><p>多了<code>swap()</code> 和 <code>release()</code>，（参考智能指针）所以<em>可以移动所有权</em>。（注意，移动的时候mutex仍然是锁住的）。</p>
</li>
<li><p>拥有 <code>timed_mutex</code> 所拥有的所有方法名。</p>
</li>
<li><p>多了两个observer：</p>
<p><code>mutex()</code> 返回指向关联的 mutex 的指针。</p>
<p><code>owns_lock()</code> 返回bool值，表明是否拥有锁住的 mutex。</p>
<p>该类同时还有个bool的类型转化函数，就是调用的 <code>owns_lock()</code>。</p>
</li>
</ul>
<hr>
<p>它们俩的<strong>区别</strong>，简单的说就是读写锁的读写操作：</p>
<p>shared_lock是read lock。被锁后仍允许其他线程执行同样被shared_lock的代码。这是一般做读操作时的需要。</p>
<p>unique_lock是write lock。被锁后不允许其他线程执行被shared_lock或unique_lock的代码。在写操作时，一般用这个，可以同时限制unique_lock的写和share_lock的读。</p>
<hr>
<h4 id="tag-type"><a href="#tag-type" class="headerlink" title="tag type"></a>tag type</h4><p><code>unique_lock</code> 和 <code>shared_lock</code> 的构造函数可以有第二个参数，即标签类型，代表不同的含义：</p>
<table>
<thead>
<tr>
<th><strong>Type</strong></th>
<th><strong>Effect(s)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>defer_lock_t</td>
<td>do not acquire ownership of the mutex</td>
</tr>
<tr>
<td>try_to_lock_t</td>
<td>try to acquire ownership of the mutex without blocking</td>
</tr>
<tr>
<td>adopt_lock_t</td>
<td>assume the calling thread already has ownership of the mutex</td>
</tr>
</tbody>
</table>
<h3 id="call-once"><a href="#call-once" class="headerlink" title="call_once()"></a>call_once()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Callable</span>, <span class="title">class</span>... <span class="title">Args</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">call_once</span>( <span class="title">std</span>:</span>:once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args );</span><br></pre></td></tr></table></figure>
<p>Executes the <em>Callable</em> object <code>f</code> exactly once, even if called concurrently, from several threads.</p>
<p><code>std::once_flag</code> is neither copyable nor movable.</p>
<p> call_once保证函数 <code>f</code>只被执行一次，如果有多个线程同时执行函数<code>f</code>调用，则只有一个活动线程(active call)会执行函数，其他的线程在这个线程执行返回之前会处于”passive execution”(被动执行状态)——不会直接返回，直到活动线程对fn调用结束才返回。对于所有调用函数fn的并发线程，数据可见性都是同步的(一致的)。</p>
<p>如果活动线程在执行 <code>f</code> 时抛出异常，则会从处于”passive execution”状态的线程中挑一个线程成为活动线程继续执行 <code>f</code>，依此类推。一旦活动线程返回，所有”passive execution”状态的线程也返回,不会成为活动线程。(实际上once_flag相当于一个锁，使用它的线程都会在上面等待，只有一个线程允许执行。如果该线程抛出异常，那么从等待中的线程中选择一个，重复上面的流程)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::once_flag flag1;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_do_once</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(flag1, []()&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Simple example: called once\n"</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">st1</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">st2</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    st1.join();</span><br><span class="line">    st2.join();</span><br><span class="line">&#125;<span class="comment">//只输出一次</span></span><br></pre></td></tr></table></figure>
<h2 id="condition-variable"><a href="#condition-variable" class="headerlink" title="condition_variable"></a>condition_variable</h2><p>Defined in header <code>&lt;condition_variable&gt;</code></p>
<p>只有两个条件变量：</p>
<ul>
<li><code>condition_variable</code> 只能用于 <code>std::unique_lock</code></li>
<li><code>condition_variable_any</code>：可以用于任意的锁</li>
</ul>
<p>只有两种方法：</p>
<ol>
<li><p>提醒别的线程我好了</p>
<p><code>notify_one()</code> 和  <code>notify_all()</code></p>
</li>
<li><p>解开作为参数的锁并且一直阻塞直到别的线程发送提醒（或到达指定的时间），然后重新获得锁。</p>
<p><code>wait()</code> 、 <code>wait_for()</code> 、 <code>wait_until()</code></p>
<p>详细讲一下 <code>wait()</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">( <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock )</span></span>;					<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Predicate</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">wait</span>( <span class="title">std</span>:</span>:unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock, Predicate pred );	<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>Atomically <strong>unlocks lock</strong>, <strong>blocks the current executing thread</strong>, and <strong>adds it to the list of threads waiting on <code>*this</code></strong>. The thread will <strong>be unblocked when <code>notify_all()</code> or <code>notify_one()</code> is executed</strong>. It may also be unblocked spuriously. <strong>When unblocked, regardless of the reason, lock is reacquired and wait exits</strong>.</p>
</li>
<li><p>Equivalent to<code>while (!pred()) { wait(lock);}</code> </p>
<p>所以如果 <code>pred()</code> 一开始就不为0，那根本就不用等待.</p>
<p>This overload may <strong>be used to ignore spurious awakenings</strong> while waiting for a specific condition to become true.</p>
<p><strong>Note that</strong> <code>lock</code> must be acquired before entering this method, and it is reacquired after </p>
<p><code>wait(lock)</code> exits, which means that <code>lock</code> can be used to guard access to <code>pred()</code>.</p>
</li>
</ol>
</li>
</ol>
<p><strong>Notes：</strong></p>
<p>Calling this function if lock.mutex() is not locked by the current thread is undefined behavior.</p>
<p>Calling this function if lock.mutex() is not the same mutex as the one used by all other threads that are currently waiting on the same condition variable is undefined behavior.</p>
<p>直接看例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line"><span class="keyword">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> processed = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Wait until main() sends data</span></span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(m);</span><br><span class="line">    cv.wait(lk, []&#123;<span class="keyword">return</span> ready;&#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// after the wait, we own the lock.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Worker thread is processing data\n"</span>;</span><br><span class="line">    data += <span class="string">" after processing"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Send data back to main()</span></span><br><span class="line">    processed = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Worker thread signals data processing completed\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Manual unlocking is done before notifying, to avoid waking up</span></span><br><span class="line">    <span class="comment">// the waiting thread only to block again (see notify_one for details)</span></span><br><span class="line">    lk.unlock();</span><br><span class="line">    cv.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">worker</span><span class="params">(worker_thread)</span></span>;</span><br><span class="line"> </span><br><span class="line">    data = <span class="string">"Example data"</span>;</span><br><span class="line">    <span class="comment">// send data to the worker thread</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(m);</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main() signals data ready for processing\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.notify_one();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// wait for the worker</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(m);</span><br><span class="line">        cv.wait(lk, []&#123;<span class="keyword">return</span> processed;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Back in main(), data = "</span> &lt;&lt; data &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    worker.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main() signals data ready for processing</span><br><span class="line">Worker thread is processing data</span><br><span class="line">Worker thread signals data processing completed</span><br><span class="line">Back in main(), data = Example data after processing</span><br></pre></td></tr></table></figure>
<h3 id="cv-status"><a href="#cv-status" class="headerlink" title="cv_status"></a>cv_status</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">cv_status</span> &#123;</span></span><br><span class="line">    no_timeout,</span><br><span class="line">    timeout   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>std::cv_status</code> is used by the <code>wait_for</code> and <code>wait_until</code> methods.</p>
<table>
<thead>
<tr>
<th><code>no_timeout</code></th>
<th>the condition variable was awakened with <code>notify_all</code>, <code>notify_one</code>, or spuriously</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>timeout</code></td>
<td>the condition variable was awakened by timeout expiration</td>
</tr>
</tbody>
</table>
<h3 id="notify-all-at-thread-exit"><a href="#notify-all-at-thread-exit" class="headerlink" title="notify_all_at_thread_exit"></a>notify_all_at_thread_exit</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify_all_at_thread_exit</span><span class="params">( <span class="built_in">std</span>::condition_variable&amp; cond,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk )</span></span>;</span><br></pre></td></tr></table></figure>
<p>It provides a mechanism to notify other threads that a given thread has completely finished, including destroying all <code>thread_local</code> objects. <strong>It operates as follows:</strong></p>
<ol>
<li>destroy thread_locals;</li>
<li>unlock mutex;</li>
<li>notify cv.</li>
</ol>
<ul>
<li><p>Ownership of the previously acquired lock <code>lk</code> is transferred to internal storage.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::notify_all_at_thread_exit(cv, <span class="built_in">std</span>::move(lk));</span><br></pre></td></tr></table></figure>
</li>
<li><p>The execution environment is modified such that when the current thread exits, the condition variable <code>cond</code> is notified as if by:</p>
<ul>
<li>lk.unlock();</li>
<li>cond.notify_all();</li>
</ul>
</li>
</ul>
<p>An equivalent effect may be achieved with the facilities provided by std::promise or std::packaged_task.</p>
<h2 id="Futures"><a href="#Futures" class="headerlink" title="Futures"></a>Futures</h2><p>Defined in header <code>&lt;future&gt;</code></p>
<hr>
<p>这个库提供异步任务（比如函数被分发到不同的线程）的返回值获取和异常捕获。</p>
<p>The standard library provides facilities to obtain values that are returned and to catch exceptions that are thrown by asynchronous tasks (i.e. functions launched in separate threads). These values are communicated in a <em>shared state</em>, in which the asynchronous task may write its return value or store an exception, and which may be examined, waited for, and otherwise manipulated by other threads that hold instances of <code>std::future</code> or <code>std::shared_future</code> that reference that shared state.</p>
<hr>
<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://118.25.53.128/Picture/C_C++/promise01.png" alt="promise01"></p>
<p><strong>来个直观的例子</strong>：</p>
<p>This example shows how <code>promise&lt;int&gt;</code> can be used as signals between threads.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accumulate</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator first,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator last,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; accumulate_promise)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="built_in">std</span>::accumulate(first, last, <span class="number">0</span>);</span><br><span class="line">    accumulate_promise.set_value(sum);  <span class="comment">// Notify future</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_work</span><span class="params">(<span class="built_in">std</span>::promise&lt;<span class="keyword">void</span>&gt; barrier)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    barrier.set_value();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Demonstrate using promise&lt;int&gt; to transmit a result between threads.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; accumulate_promise;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; accumulate_future = accumulate_promise.get_future();</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">work_thread</span><span class="params">(accumulate, numbers.begin(), numbers.end(),</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="built_in">std</span>::move(accumulate_promise))</span></span>;</span><br><span class="line">    accumulate_future.wait();  <span class="comment">// wait for result</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result="</span> &lt;&lt; accumulate_future.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    work_thread.join();  <span class="comment">// wait for thread completion</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Demonstrate using promise&lt;void&gt; to signal state between threads.</span></span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">void</span>&gt; barrier;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">void</span>&gt; barrier_future = barrier.get_future();</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">new_work_thread</span><span class="params">(do_work, <span class="built_in">std</span>::move(barrier))</span></span>;</span><br><span class="line">    barrier_future.wait();</span><br><span class="line">    new_work_thread.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="future"><a href="#future" class="headerlink" title="future"></a>future</h3><p>std::future 可以用来获取异步任务的结果，因此可以把它当成一种简单的线程间同步的手段。std::future 通常由某个 Provider 创建，你可以把 Provider 想象成一个异步任务的提供者，Provider 在某个线程中设置共享状态的值，与该共享状态相关联的 std::future 对象调用 get（通常在另外一个线程中） 获取该值，如果共享状态的标志不为 ready，则调用 std::future::get 会阻塞当前的调用者，直到 Provider 设置了共享状态的值（此时共享状态的标志变为 ready），std::future::get 返回异步任务的值或异常（如果发生了异常）。</p>
<p>一个有效(valid)的 std::future 对象通常由以下三种 Provider 创建，并和某个共享状态相关联。Provider 可以是函数或者类，其实我们前面都已经提到了，他们分别是：</p>
<ul>
<li>std::async 函数。</li>
<li>std::promise::get_future，get_future 为 promise 类的成员函数。</li>
<li>std::packaged_task::get_future，此时 get_future为 packaged_task 的成员函数。</li>
</ul>
<p>一个 std::future 对象只有在有效(valid)的情况下才有用(useful)，由 std::future 默认构造函数创建的 future 对象不是有效的（除非当前非有效的 future 对象被 move 赋值另一个有效的 future 对象）。</p>
<p>在一个有效的 future 对象上调用 get 会阻塞当前的调用者，直到 Provider 设置了共享状态的值或异常（此时共享状态的标志变为 ready），std::future::get 将返回异步任务的值或异常（如果发生了异常）。</p>
<hr>
<p><strong>Member Function</strong></p>
<ul>
<li><p><code>share()</code></p>
<p>返回一个 std::shared_future 对象（本文后续内容将介绍 std::shared_future ），调用该函数之后，该 std::future 对象本身已经不和任何共享状态相关联，因此该 std::future 的状态不再是 valid 的了。</p>
</li>
<li><p><code>get()</code>  get 返回 Provider 所设置的共享状态的值或者异常。如果共享状态的标志不为 ready，则调用该函数会阻塞当前的调用者，而此后一旦共享状态的标志变为 ready，get 返回。</p>
</li>
<li><p><code>valid()</code>  检查当前的 std::future 对象是否有效，即是否与某个共享状态相关联。</p>
</li>
<li><p><code>wait()</code>  等待与当前std::future 对象相关联的共享状态的标志变为 ready.</p>
</li>
<li><p><code>wait_for()</code>  时间点过后如果没ready，则直接阻塞当前线程。</p>
</li>
<li><p><code>wait_until()</code></p>
</li>
</ul>
<h4 id="shared-future"><a href="#shared-future" class="headerlink" title="shared_future"></a>shared_future</h4><p>std::shared_future 与 std::future 类似，但是 std::shared_future 可以拷贝、多个 std::shared_future 可以共享某个共享状态的最终结果(即共享状态的某个值或者异常)。shared_future 可以通过某个 std::future 对象隐式转换（构造函数），或者通过 std::future::share() 显示转换，无论哪种转换，被转换的那个 std::future 对象都会变为 not-valid.</p>
<p>成员函数和 std::future 基本相同。</p>
<h4 id="future-error"><a href="#future-error" class="headerlink" title="future_error"></a>future_error</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">future_error</span> :</span> <span class="keyword">public</span> logic_error;</span><br></pre></td></tr></table></figure>
<h4 id="future-errc"><a href="#future-errc" class="headerlink" title="future_errc"></a>future_errc</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">future_errc</span> &#123;</span></span><br><span class="line">    broken_promise             = <span class="comment">/* implementation-defined */</span>,</span><br><span class="line">    future_already_retrieved   = <span class="comment">/* implementation-defined */</span>,</span><br><span class="line">    promise_already_satisfied  = <span class="comment">/* implementation-defined */</span>,</span><br><span class="line">    no_state                   = <span class="comment">/* implementation-defined */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="future-status"><a href="#future-status" class="headerlink" title="future_status"></a>future_status</h4><p>Specifies state of a future as returned by <code>wait_for</code> and <code>wait_until</code> functions of std::future and std::shared_future.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">future_status</span> &#123;</span></span><br><span class="line">    ready,</span><br><span class="line">    timeout,</span><br><span class="line">    deferred</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>deferred</code></td>
<td>the shared state contains a deferred function, so the result will be computed only when explicitly requested</td>
</tr>
<tr>
<td><code>ready</code></td>
<td>the shared state is ready</td>
</tr>
<tr>
<td><code>timeout</code></td>
<td>the shared state did not become ready before specified timeout duration has passed</td>
</tr>
</tbody>
</table>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">R</span> &gt; <span class="title">class</span> <span class="title">promise</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">R</span> &gt; <span class="title">class</span> <span class="title">promise</span>&lt;R&amp;&gt;;</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;          <span class="class"><span class="keyword">class</span> <span class="title">promise</span>&lt;void&gt;;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>base template</li>
<li>non-void specialization, used to communicate objects between threads</li>
<li>void specialization, used to communicate stateless events</li>
</ol>
<hr>
<p><strong>Member functions</strong></p>
<table>
<thead>
<tr>
<th>functions</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>operator=</td>
<td>只有移动赋值，没有拷贝赋值。First, abandons the shared state (as in ~promise()), then assigns the shared state of <code>other</code> as if by executing <code>std::promise(std::move(other)).swap(*this)</code>.</td>
</tr>
<tr>
<td>swap</td>
<td>swaps two promise objects</td>
</tr>
<tr>
<td>get_future</td>
<td>returns a <code>future</code> associated with the promised result</td>
</tr>
<tr>
<td>set_value</td>
<td>sets the result to specific value</td>
</tr>
<tr>
<td>set_value_at_thread_exit</td>
<td>sets only at thread exit</td>
</tr>
<tr>
<td>set_exception( p )</td>
<td>p is exception pointer to store. The behavior is undefined if <code>p</code> is null.</td>
</tr>
<tr>
<td>set_exception_at_thread_exit</td>
<td>sets only at thread exit</td>
</tr>
</tbody>
</table>
<p><strong>set_exception的例子</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; f = p.get_future();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">([&amp;p]&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="comment">// code that may throw</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"Example"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125; <span class="keyword">catch</span>(...) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="comment">// store anything thrown in the promise</span></span></span></span><br><span class="line"><span class="function"><span class="params">                p.set_exception(<span class="built_in">std</span>::current_exception());</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125; <span class="keyword">catch</span>(...) &#123;&#125; <span class="comment">// set_exception() may throw too</span></span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Exception from the thread: "</span> &lt;&lt; e.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h3><p>std::packaged_task 包装一个可调用的对象，并且允许异步获取该可调用对象产生的结果，从包装可调用对象意义上来讲，std::packaged_task 与 std::function 类似（可参照），只不过 std::packaged_task 将其包装的可调用对象的执行结果传递给一个 std::future 对象（该对象通常在另外一个线程中获取 std::packaged_task 任务的执行结果）。</p>
<p>std::packaged_task 对象内部包含了两个最基本元素：</p>
<ol>
<li>被包装的任务(stored task)，任务(task)是一个可调用的对象，如函数指针、成员函数指针或者函数对象，</li>
<li>共享状态(shared state)，用于保存任务的返回值，可以通过 std::future 对象来达到异步访问共享状态的效果。</li>
</ol>
<p><strong>构造函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="title">class</span> ...<span class="title">Args</span> &gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">packaged_task</span>&lt;R(Args...)&gt;;</span></span><br></pre></td></tr></table></figure>
<p><strong>成员方法：</strong></p>
<ul>
<li><p><code>valid()</code>  checks if the task object has a valid function.</p>
</li>
<li><p><code>swap()</code></p>
</li>
<li><p><code>get_future()</code>  returns a <code>std::future</code> associated with the promised result </p>
</li>
<li><p><code>void operator()( ArgTypes... args );</code></p>
<p>Calls the stored task with <code>args</code> as the arguments. The return value of the task or any exceptions thrown are stored in the shared state. The shared state is made ready and any threads waiting for this are unblocked.</p>
</li>
<li><p><code>void make_ready_at_thread_exit( ArgTypes... args );</code></p>
<p>和 <code>operator()</code> 一样，但是 The shared state is only made ready after the current thread exits and all objects of <em>thread local</em> storage duration are destroyed.</p>
</li>
<li><p><code>reset()</code>  </p>
<p>Resets the state abandoning the results of previous executions. New shared state is constructed.</p>
<p>Equivalent to <code>*this = packaged_task(std::move(f))</code>, where <code>f</code> is the stored task.</p>
</li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// unique function to avoid disambiguating the std::pow overload set</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">pow</span>(x,y); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_lambda</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; task([](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">pow</span>(a, b); </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; result = task.get_future();</span><br><span class="line"> </span><br><span class="line">    task(<span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task_lambda:\t"</span> &lt;&lt; result.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_bind</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>()&gt; task(<span class="built_in">std</span>::bind(f, <span class="number">2</span>, <span class="number">11</span>));</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; result = task.get_future();</span><br><span class="line"> </span><br><span class="line">    task();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task_bind:\t"</span> &lt;&lt; result.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; task(f);</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; result = task.get_future();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">task_td</span><span class="params">(<span class="built_in">std</span>::move(task), <span class="number">2</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    task_td.join();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task_thread:\t"</span> &lt;&lt; result.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    task_lambda();</span><br><span class="line">    task_bind();</span><br><span class="line">    task_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>大致上有两类函数原型（省略模板声明部分）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">future <span class="title">async</span><span class="params">( Function&amp;&amp; f, Args&amp;&amp;... args )</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">future <span class="title">async</span><span class="params">( <span class="built_in">std</span>::launch policy, Function&amp;&amp; f, Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>std::async() 的 fn 和 args 参数用来指定异步任务及其参数。另外，std::async() 返回一个 std::future 对象，通过该对象可以获取异步任务的值或异常（如果异步任务抛出了异常）。</p>
</li>
<li><p>第二类函数指定了启动策略。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::launch::async</td>
<td>a new thread is launched to execute the task asynchronously</td>
</tr>
<tr>
<td>std::launch::deferred</td>
<td>the task is executed on the calling thread the first time its result is requested (lazy evaluation)</td>
</tr>
</tbody>
</table>
<p><strong>例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parallel_sum</span><span class="params">(RandomIt beg, RandomIt end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> len = end - beg;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::accumulate(beg, end, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    RandomIt mid = beg + len/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> handle = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,</span><br><span class="line">                             parallel_sum&lt;RandomIt&gt;, mid, end);</span><br><span class="line">    <span class="keyword">int</span> sum = parallel_sum(beg, mid);</span><br><span class="line">    <span class="keyword">return</span> sum + handle.get();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">10000</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum is "</span> &lt;&lt; parallel_sum(v.begin(), v.end()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="fin"><a href="#fin" class="headerlink" title="fin"></a>fin</h1>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2020 Skuaka
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 1;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>