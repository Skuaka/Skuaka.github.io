<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="Skuaka">


    
    


<meta name="description" content="For you, a thousand times over.">
<meta name="keywords" content="skuaka">
<meta property="og:type" content="website">
<meta property="og:title" content="Skuaka">
<meta property="og:url" content="http://skuaka.cn/page/2/index.html">
<meta property="og:site_name" content="Skuaka">
<meta property="og:description" content="For you, a thousand times over.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Skuaka">
<meta name="twitter:description" content="For you, a thousand times over.">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Skuaka" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/avatar.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Skuaka</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Skuaka</a></h1>
        </hgroup>

        
        <p class="header-subtitle">For you, a thousand times over.</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">Home</a></li>
                        
                            <li><a href="/archives/">Archives</a></li>
                        
                            <li><a href="/tags/">Tags</a></li>
                        
                            <li><a href="/about/">about</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCIE/">CCIE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DDos/">DDos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DTD/">DTD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DoNotStarve/">DoNotStarve</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dreamweaver/">Dreamweaver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kali/">Kali</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Macos/">Macos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MetaProgram/">MetaProgram</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mp3/">Mp3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenGL/">OpenGL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Perl/">Perl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QT/">QT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Raspberrypi/">Raspberrypi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLserver/">SQLserver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Security/">Security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Socks5/">Socks5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wifi/">Wifi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wireshark/">Wireshark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/base64/">base64</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/clion/">clion</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcc-gdb/">gcc,gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unp/">unp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vultr/">vultr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a></li></ul>
                    </div>
                </section>
                
                
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Skuaka</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Skuaka</a></h1>
            </hgroup>
            
            <p class="header-subtitle">For you, a thousand times over.</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">Home</a></li>
                
                    <li><a href="/archives/">Archives</a></li>
                
                    <li><a href="/tags/">Tags</a></li>
                
                    <li><a href="/about/">about</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" target="_blank" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me">
</nav>
      <div class="body-wrap">
  
    <article id="post-C_C++/Concept_gcc/C++命名规范" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/04/07/C_C++/Concept_gcc/C++命名规范/" class="article-date">
      <time datetime="2019-04-07T08:37:00.000Z" itemprop="datePublished">2019-04-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/07/C_C++/Concept_gcc/C++命名规范/">C++命名规范</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="C-命名规范"><a href="#C-命名规范" class="headerlink" title="C++命名规范"></a>C++命名规范</h2><p>源自：<a href="https://www.cnblogs.com/heyonggang/p/3362873.html" target="_blank" rel="noopener">https://www.cnblogs.com/heyonggang/p/3362873.html</a></p>
<h3 id="整体原则"><a href="#整体原则" class="headerlink" title="整体原则"></a>整体原则</h3><p>在引入细节之前，先说明一下命名规范的整体原则：</p>
<table>
<thead>
<tr>
<th>同一性</th>
<th>在编写一个子模块或派生类的时候，要遵循其基类或整体模块的命名风格，保持命名风格在整个模块中的同一性。</th>
</tr>
</thead>
<tbody>
<tr>
<td>标识符组成</td>
<td>标识符采用英文单词或其组合，应当直观且可以拼读，可望文知意，用词应当准确。</td>
</tr>
<tr>
<td>最小化长度 &amp;&amp; 最大化信息量原则</td>
<td>在保持一个标识符意思明确的同时，应当尽量缩短其长度。</td>
</tr>
<tr>
<td>避免过于相似</td>
<td>不要出现仅靠大小写区分的相似的标识符，例如“i”与“I”，“function”与“Function”等等。</td>
</tr>
<tr>
<td>避免在不同级别的作用域中重名</td>
<td>程序中不要出现名字完全相同的局部变量和全局变量，尽管两者的作用域不同而不会发生语法错误，但容易使人误解。</td>
</tr>
<tr>
<td>正确命名具有互斥意义的标识符</td>
<td>用正确的反义词组命名具有互斥意义的标识符，如：”nMinValue”和”nMaxValue”，”GetName()” 和 “SetName()” ….</td>
</tr>
<tr>
<td>避免名字中出现数字编号</td>
<td>尽量避免名字中出现数字编号，如Value1,Value2等，除非逻辑上的确需要编号。这是为了防止程序员偷懒，不肯为命名动脑筋而导致产生无意义的名字（因为用数字编号最省事）。</td>
</tr>
</tbody>
</table>
<h3 id="类-结构"><a href="#类-结构" class="headerlink" title="类/结构"></a>类/结构</h3><p>除了异常类等个别情况（不希望用户把该类看作一个普通的、正常的类之情况）外，C++类/结构<br>的命名应该遵循以下准则：</p>
<table>
<thead>
<tr>
<th>C++类/结构的命名</th>
<th>类的名称都要以大写字母“C”开头，后跟一个或多个单词。为便于界定，每个单词的首字母要大写。</th>
</tr>
</thead>
<tbody>
<tr>
<td>推荐的组成形式</td>
<td>类的命名推荐用”名词”或”形容词＋名词”的形式，例如：”CAnalyzer”, “CFastVector” ….</td>
</tr>
<tr>
<td>传统C结构体的命名</td>
<td>传统C结构体的名称全部由大写字母组成，单词间使用下划线界定，例如：”SERVICE_STATUS”, “DRIVER_INFO” ….</td>
</tr>
</tbody>
</table>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><table>
<thead>
<tr>
<th>函数的命名</th>
<th>函数的名称由一个或多个单词组成。为便于界定，每个单词的首字母要大写。</th>
</tr>
</thead>
<tbody>
<tr>
<td>推荐的组成形式</td>
<td>函数名应当使用”动词”或者”动词＋名词”（动宾词组）的形式。例如：”GetName()”, “SetValue()”, “Erase()”, “Reserve()” ….</td>
</tr>
<tr>
<td>保护成员函数</td>
<td>保护成员函数的开头应当加上一个下划线“_”以示区别，例如：”_SetState()” ….</td>
</tr>
<tr>
<td>私有成员函数</td>
<td>类似地，私有成员函数的开头应当加上两个下划线“<strong>”，例如：”</strong>DestroyImp()” ….</td>
</tr>
<tr>
<td>虚函数</td>
<td>虚函数习惯以“Do”开头，如：”DoRefresh()”, “_DoEncryption()” ….</td>
</tr>
<tr>
<td>回调和事件处理函数</td>
<td>回调和事件处理函数习惯以单词“On”开头。例如：”_OnTimer()”, “OnExit()” ….</td>
</tr>
</tbody>
</table>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量名由<strong><em>作用域前缀＋类型前缀＋一个或多个单词</em></strong>组成。为便于界定，每个单词的首字母要大写。</p>
<p>对于某些用途简单明了的局部变量，也可以使用简化的方式，如：i, j, k, x, y, z ….</p>
<p><strong>作用域前缀</strong></p>
<table>
<thead>
<tr>
<th><strong>前缀</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>无</em></td>
<td>局部变量</td>
</tr>
<tr>
<td>m_</td>
<td>类的成员变量（member）</td>
</tr>
<tr>
<td>sm_</td>
<td>类的静态成员变量（static member）</td>
</tr>
<tr>
<td>s_</td>
<td>静态变量（static）</td>
</tr>
<tr>
<td>g_</td>
<td>外部全局变量（global）</td>
</tr>
<tr>
<td>sg_</td>
<td>静态全局变量（static global）</td>
</tr>
<tr>
<td>gg_</td>
<td>进程间共享的共享数据段全局变量（global global）</td>
</tr>
</tbody>
</table>
<p><strong>类型前缀</strong></p>
<p>类型前缀可以组合使用，例如”gc”表示字符数组，”ppn”表示指向整型的指针的指针等等。</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>整型和位域变量（number）</td>
</tr>
<tr>
<td>e</td>
<td>枚举型变量（enumeration）</td>
</tr>
<tr>
<td>c</td>
<td>字符型变量（char）</td>
</tr>
<tr>
<td>b</td>
<td>布尔型变量（bool）</td>
</tr>
<tr>
<td>f</td>
<td>浮点型变量（float）</td>
</tr>
<tr>
<td>p</td>
<td>指针型变量和迭代子（pointer）</td>
</tr>
<tr>
<td>pfn</td>
<td>特别针对指向函数的指针变量和函数对象指针（pointer of function）</td>
</tr>
<tr>
<td>g</td>
<td>数组（grid）</td>
</tr>
<tr>
<td>i</td>
<td>类的实例（instance）<br>对于经常用到的类，也可以定义一些专门的前缀，<br>如：std::string类的前缀可以定义为”st”，std::vector类的前缀可以定义为”v”。</td>
</tr>
</tbody>
</table>
<p><strong>推荐的组成形式</strong></p>
<p>变量的名字应当使用”名词”或者”形容词＋名词”。例如：”nCode”, “m_nState”，”nMaxWidth” ….</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量名由类型前缀＋全大写字母组成，单词间通过下划线来界定，如：cDELIMITER, nMAX_BUFFER ….</p>
<p>类型前缀的定义与变量命名规则中的相同。</p>
<h3 id="枚举-联合-typedef"><a href="#枚举-联合-typedef" class="headerlink" title="枚举/联合/typedef"></a>枚举/联合/typedef</h3><p>枚举、联合、typedef语句生成的类型名由全大写字母组成，单词间通过下划线来界定，如：FAR_PROC, ERROR_TYPE ….</p>
<h3 id="宏-枚举"><a href="#宏-枚举" class="headerlink" title="宏/枚举"></a>宏/枚举</h3><p>宏和枚举值由全大写字母组成，单词间通过下划线来界定，如：ERROR_UNKNOWN, OP_STOP ….</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Network/Http/https与ssl" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/04/06/Network/Http/https与ssl/" class="article-date">
      <time datetime="2019-04-06T12:39:23.000Z" itemprop="datePublished">2019-04-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/06/Network/Http/https与ssl/">https 与 ssl</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL，HTTP Secure。</p>
<p>HTTP端口：80，HTTPS端口：443。</p>
<p>在计算机网络上，HTTPS经由超文本传输协议（HTTP）进行通信，但利用SSL/TLS来加密数据包。</p>
<p><strong>HTTP的特点</strong></p>
<ul>
<li><p>无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作</p>
</li>
<li><p>无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。</p>
</li>
<li><p>基于请求和响应：基本的特性，由客户端发起请求，服务端响应</p>
</li>
<li><p>简单快速、灵活</p>
</li>
<li><p>通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性</p>
</li>
</ul>
<p><strong>HTTPS的特点</strong></p>
<ol>
<li>内容加密：采用混合加密技术，中间者无法直接查看明文内容</li>
<li>验证身份：通过证书认证客户端访问的是自己的服务器</li>
<li>保护数据完整性：防止传输的内容被中间人冒充或者篡改</li>
</ol>
<h3 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h3><p>HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS/SSL中使用了<strong>非对称加密</strong>，<strong>对称加密</strong>，<strong>HASH算法</strong>。握手过程的具体描述如下：</p>
<ul>
<li>1）浏览器将自己支持的一套加密规则发送给网站。 </li>
<li>2）网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。  </li>
<li>3）浏览器获得网站证书之后浏览器要做以下工作：  a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。  b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。  c) 使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。 </li>
<li> 4）网站接收浏览器发来的数据之后要做以下的操作：  a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。  b) 使用密码加密一段握手消息，发送给浏览器。 </li>
<li> 5）浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。 </li>
</ul>
<p>这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。另外，HTTPS一般使用的加密与HASH算法如下：</p>
<ul>
<li>非对称加密算法：RSA，DSA/DSS</li>
<li>对称加密算法：AES，RC4，3DES</li>
<li>HASH算法：MD5，SHA1，SHA256</li>
</ul>
<h4 id="通信时序图"><a href="#通信时序图" class="headerlink" title="通信时序图"></a>通信时序图</h4><p><img src="http://www.runoob.com/wp-content/uploads/2017/05/201208201734403507.png" alt="201208201734403507"></p>
<h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>secure socket layer (安全套接字层)</p>
<p>SSL证书和我们日常用的身份证类似，是一个支持HTTPS网站的身份证明，SSL证书里面包含了网站的域名，证书有效期，证书的颁发机构以及用于加密传输密码的公钥等信息，由于公钥加密的密码只能被在申请证书时生成的私钥解密，因此浏览器在生成密码之前需要先核对当前访问的域名与证书上绑定的域名是否一致，同时还要对证书的颁发机构进行验证，如果验证失败浏览器会给出证书错误的提示。</p>
<h3 id="证书的类型"><a href="#证书的类型" class="headerlink" title="证书的类型"></a>证书的类型</h3><p>实际上，我们使用的证书分很多种类型，SSL证书只是其中的一种。SSL证书负责传输公钥，是一种PKI（Public Key Infrastructure，公钥基础结构）证书。 我们常见的证书根据用途不同大致有以下几种：</p>
<ul>
<li> 1、SSL证书，用于加密HTTP协议，也就是HTTPS。</li>
<li> 2、代码签名证书，用于签名二进制文件，比如Windows内核驱动，Firefox插件，Java代码签名等等。</li>
<li> 3、客户端证书，用于加密邮件。</li>
<li> 4、双因素证书，网银专业版使用的USB Key里面用的就是这种类型的证书。</li>
</ul>
<p> 这些证书都是由受认证的证书颁发机构——我们称之为<strong>CA（Certificate Authority）</strong>机构来颁发，针对企业与个人的不同，可申请的证书的类型也不同，价格也不同。CA机构颁发的证书都是受信任的证书，对于SSL证书来说，如果访问的网站与证书绑定的网站一致就可以通过浏览器的验证而不会提示错误。</p>
<h3 id="SSL证书申请与规则"><a href="#SSL证书申请与规则" class="headerlink" title="SSL证书申请与规则"></a>SSL证书申请与规则</h3><p>SSL证书可以向CA机构通过付费的方式申请，也可以自己制作。 CA机构颁发的证书价格非常昂贵，而且有效期一般只有一年到三年不等（年数不同，价格也不同），过期之后还要再次交钱申请，因此一般只有企业才会申请证书。但是随着个人网站的增多，目前也有针对个人的SSL证书服务，价格相对便宜一些，国内的话400多块钱就能申请到一个，国外更是有免费的SSL证书可以申请。 在申请SSL证书时需要向CA机构提供网站域名，营业执照，以及申请人的身份信息等。网站的域名非常重要，申请人必须证明自己对域名有所有权，如果支持Hotmail.com，Gmail.com的SSL证书都可以随便申请，黑客们就不用做假证书欺骗了。</p>
<p>此外，一个证书一般只绑定一个域名，如果CA机构心情好的话，会免费再绑一个，比如你要申请域名时绑定的域名是 <a href="http://www.runoob.com" target="_blank" rel="noopener">www.runoob.com</a> ，那么只有在浏览器地址是 <a href="https://www.runoob.com" target="_blank" rel="noopener">https://www.runoob.com</a>  的时候，这个证书才是受信任的，如果地址是 <a href="https://tt.runoob.com" target="_blank" rel="noopener">https://tt.runoob.com</a> 或者 <a href="https://login.runoob.com" target="_blank" rel="noopener">https://login.runoob.com</a> ，那么这个证书由于访问的域名与证书绑定的域名不同，仍然会被浏览器显示为不受信任的。</p>
<p>CA机构也提供申请通配符域名（例如，*.runoob.com），通配符域名相当于绑定了主域名下的所有域名，因此使用起来非常方便，但是价格也超级昂贵，一个通配符域名一年大概得5000块钱，只有企业才可以申请。 </p>
<hr>
<p>以上说的是向CA机构申请证书的情况，如果个人网站只为加密传输也可以自己制作SSL证书，自己制作的证书不会受到浏览器的信任，在访问的时候由于证书验证失败而给出警告。</p>
<h3 id="SSL证书欺骗"><a href="#SSL证书欺骗" class="headerlink" title="SSL证书欺骗"></a>SSL证书欺骗</h3><p>对HTTPS最常见的攻击手段就是SSL证书欺骗或者叫SSL劫持，是一种典型的中间人攻击。不过SSL劫持并非只是用于攻击目的，在一些特殊情况下利用SSL劫持我们可以更顺畅的访问网络，我会在后文提到。</p>
<p>以攻击为目的的SSL劫持如果不注意浏览器安全提示的话，很容易就中招。当网络中有中间人发起SSL劫持攻击时，攻击者需要伪造一个SSL证书发给浏览器，这个时候由于伪造的SSL证书不受信任，浏览器会给出提示。</p>
<p>这里有一个误区，当SSL证书不受信任的时候，并不一定就是有SSL劫持发生，有种例外情况是：一些个人网站买不起合法的SSL证书，因此会自己制作一个SSL证书来加密传输的数据。如果你经常访问某个个人网站，而且你知道这个网站是干什么的，那么这种情况可以不用担心。但是如果你访问的是网银，在线支付，或者是hotmail.com，gmail.com等，这类公司性质的网站一定会申请合法的SSL证书（12306.cn除外），一旦SSL证书不受信任，应该果断的终止访问，这个时候网络中一定会存在异常行为，对于一些小区宽带的用户一定要注意这点。</p>
<p>所以作为个人用户，你一定要知道你访问的是什么网站，如果你只是一个没有多少计算机只是的普通网民，我相信你不会经常上那些自己制作SSL证书的个人网站（12306.cn除外），因此如果你没有办法判断网络是不是有异常，只要是证书有问题的，干脆就别再访问了。</p>
<blockquote>
<p>小提示：对于12306.cn，一定要按照网站说的那样，”为保障您顺畅购票，请下载安装根证书”。</p>
</blockquote>
<p>总结一下使用SSL证书要注意的问题：</p>
<ul>
<li>1、除非必要，不要随意安装根证书。安装根证书的时候一定要明确证书的来源。</li>
<li>2、对于网银，在线支付，重要邮箱等网站，一定要确保SSL证书是没有问题的，如果浏览器给出SSL证书错误的警告，一定要拒绝访问。一些小区宽带用户一定要注意这点。</li>
<li>3、由于现在个人申请SSL证书比较便宜，一定要注意挂着合法SSL证书的钓鱼网站（国外比较常见）。对于钓鱼网站，一定要看清域名，另外别相信什么中奖的消息，同时要安装带有钓鱼防护功能的安全软件。</li>
</ul>
<h3 id="证书如何保证安全传输"><a href="#证书如何保证安全传输" class="headerlink" title="证书如何保证安全传输"></a>证书如何保证安全传输</h3><p>数字证书包括了加密后服务器的公钥、权威机构的信息、服务器域名，还有经过CA私钥签名之后的证书内容（经过先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名。当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要，然后根据证书上描述的计算证书的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。</p>
<p>那第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？（伪装服务端一样的配置）显然这个是不行的，因为当第三方攻击者去CA那边寻求认证的时候CA会要求其提供例如域名的whois信息、域名管理邮箱等证明你是服务端域名的拥有者，而第三方攻击者是无法提供这些信息所以他就是无法骗CA他拥有属于服务端的域名</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="安全性考虑"><a href="#安全性考虑" class="headerlink" title="安全性考虑"></a>安全性考虑</h3><ol>
<li>HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。</li>
<li>SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</li>
</ol>
<h3 id="成本考虑"><a href="#成本考虑" class="headerlink" title="成本考虑"></a>成本考虑</h3><p>SSL证书需要购买申请，功能越强大的证书费用越高。</p>
<p>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。</p>
<p>根据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电。</p>
<p>HTTPS连接缓存不如HTTP高效，流量成本高。</p>
<p>HTTPS连接服务器端资源占用高很多，支持访客多的网站需要投入更大的成本。</p>
<p>HTTPS协议握手阶段比较费时，对网站的响应速度有影响，影响用户体验。比较好的方式是采用分而治之，类似12306网站的主页使用HTTP协议，有关于用户信息等方面使用HTTPS。</p>
<h2 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h2><p>SSL只是一个协议，openssl则是SSL的实现版，另外openssl还包含了公钥私钥的生成、摘要生成等各种工具。</p>
<p><strong>使用场景</strong></p>
<p>我们知道，有些时候我们浏览网站的时候会有一些广告，这些广告什么的不一定是原网站挂上去的，也有可能是中间的运营商在中间篡改了内容导致的，可以使用https技术（一般是基于openssl）来对数据进行加密，保证数据不被篡改。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p><strong>学习来源</strong></p>
<p><a href="http://www.runoob.com/w3cnote/https-ssl-intro.html" target="_blank" rel="noopener">http://www.runoob.com/w3cnote/https-ssl-intro.html</a></p>
<p><a href="https://blog.csdn.net/xiaoming100001/article/details/81109617" target="_blank" rel="noopener">https://blog.csdn.net/xiaoming100001/article/details/81109617</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Unix/Programming/ide_git" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/04/01/Unix/Programming/ide_git/" class="article-date">
      <time datetime="2019-04-01T07:24:56.000Z" itemprop="datePublished">2019-04-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/Unix/Programming/ide_git/">IDE+git使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="IDE-Git使用"><a href="#IDE-Git使用" class="headerlink" title="IDE+Git使用"></a>IDE+Git使用</h3><p>拿Clion举个例子，大部分IDE都差不多。</p>
<ol>
<li><p>先创建本地仓库并且发布(命令行或者GitHub Desktop)</p>
</li>
<li><p>Clion只需要在上一步创建的位置上创建新项目，便会自动使用Git进行版本控制。</p>
</li>
<li><p>工具栏只能pull和commit，而push在菜单栏里。</p>
</li>
<li><p>如果不想上传clion自动创建的文件夹，可以添加ignore文件名(命令行或者GitHub Desktop)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake-build*</span><br><span class="line">.idea</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>PS：</p>
<ul>
<li>可以设置commit的时候检查todo注释</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/clion/">clion</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Network/IO/libevent" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/27/Network/IO/libevent/" class="article-date">
      <time datetime="2019-03-27T14:47:57.000Z" itemprop="datePublished">2019-03-27</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/27/Network/IO/libevent/">libevent</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="libevent"><a href="#libevent" class="headerlink" title="libevent"></a>libevent</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>官方文档：<a href="http://libevent.org/" target="_blank" rel="noopener">http://libevent.org </a>.</p>
<p>本篇是对官方文档的学习摘录。有目录方便查找。</p>
<hr>
<p>各系统分别提出了基于异步/callback的系统调用，例如Linux的epoll，BSD的kqueue，Windows的IOCP。由于在内核层面做了支持，所以可以用O(1)的效率查找到active的fd。基本上，<strong>libevent就是对这些高效IO的封装，提供统一的API，简化开发。</strong></p>
<p><em>libevent</em> is meant to replace the event loop found in event driven network servers. An application just needs to call<em>event_dispatch()</em> and then add or remove events dynamically without having to change the event loop.</p>
<p>Libevent can also be used for multi-threaded applications, either by isolating each event_base so that only a single thread accesses it, or by locked access to a single shared event_base. </p>
<p>Libevent additionally provides a sophisticated framework for buffered network IO, with support for sockets, filters, rate-limiting, SSL, zero-copy file transmission, and IOCP. Libevent includes support for several useful protocols, including DNS, HTTP, and a minimal RPC framework.</p>
<h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h3><p><strong>Libevent is divided into the following components:</strong></p>
<p><strong>evutil</strong></p>
<p>Generic functionality to abstract out the differences between different platforms’ networking implementations.</p>
<p><strong>event</strong> and <strong>event_base</strong></p>
<p>This is <em>the heart of Libevent</em>. It provides an abstract API to the various platform-specific, event-based nonblocking IO backends. It can let you know when sockets are ready to read or write, do basic timeout functionality, and detect OS signals.</p>
<p><strong>bufferevent</strong></p>
<p>These functions provide a more convenient wrapper around Libevent’s event-based core. They let your application request buffered reads and writes, and rather than informing you when sockets are ready to do, they let you know when IO has actually occurred.</p>
<p><strong>evbuffer</strong></p>
<p>This module implements the buffers underlying bufferevents, and provides functions for efficient and/or convenient access.</p>
<p><strong>evhttp</strong></p>
<p>A simple HTTP client/server implementation.</p>
<p><strong>evdns</strong></p>
<p>A simple DNS client/server implementation.</p>
<p><strong>evrpc</strong></p>
<p>A simple RPC implementation.</p>
<h3 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h3><p>When Libevent is built, by default it installs the following libraries:</p>
<ul>
<li><p>libevent_core</p>
<p>All core event and buffer functionality. This library contains all the event_base, evbuffer, bufferevent, and utility functions.</p>
</li>
<li><p>libevent_extra</p>
<p>This library defines protocol-specific functionality that you may or may not want for your application, <em>including HTTP, DNS, and RPC</em>.</p>
</li>
<li><p>libevent</p>
<p>This library <em>exists for historical reasons</em>; it contains the contents of both libevent_core and libevent_extra. <em>You shouldn’t use it; it may go away in a future version of Libevent</em>.</p>
</li>
</ul>
<p>The following libraries are installed only on some platforms:</p>
<ul>
<li><p>libevent_pthreads</p>
<p>This library adds threading and locking implementations based on the pthreads portable threading library. It is separated from libevent_core so that you don’t need to link against pthreads to use Libevent unless you are <em>actually</em> using Libevent in a multithreaded way.</p>
</li>
<li><p>libevent_openssl</p>
<p>This library provides support for encrypted communications using bufferevents and the OpenSSL library. It is separated from libevent_core so that you don’t need to link against OpenSSL to use Libevent unless you are <em>actually</em> using encrypted connections.</p>
</li>
</ul>
<h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><p>All current public Libevent headers are <strong>installed under the <em>event2</em> directory</strong>. </p>
<table>
<thead>
<tr>
<th>OLD HEADER</th>
<th>REPLACED BY CURRENT HEADERS</th>
</tr>
</thead>
<tbody>
<tr>
<td>event.h</td>
<td>event2/event*.h, event2/buffer*.h event2/bufferevent*.h event2/tag*.h</td>
</tr>
<tr>
<td>evdns.h</td>
<td>event2/dns*.h</td>
</tr>
<tr>
<td>evhttp.h</td>
<td>event2/http*.h</td>
</tr>
<tr>
<td>evrpc.h</td>
<td>event2/rpc*.h</td>
</tr>
<tr>
<td>evutil.h</td>
<td>event2/util*.h</td>
</tr>
</tbody>
</table>
<p><strong>编译参数：</strong></p>
<p>gcc link lib：<code>-levent</code> .</p>
<p>因为我是在mac下用brew安装的，所以我的<strong>cmake</strong>这么写：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(/usr/local/Cellar/libevent/<span class="number">2.1</span>.<span class="number">8</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(/usr/local/Cellar/libevent/<span class="number">2.1</span>.<span class="number">8</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(server main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(server event)</span><br></pre></td></tr></table></figure>
<p>目录可以用 <code>brew info libevent</code> 查找。</p>
<h2 id="Program"><a href="#Program" class="headerlink" title="Program"></a>Program</h2><h3 id="Lib-setup"><a href="#Lib-setup" class="headerlink" title="Lib setup"></a>Lib setup</h3><p>在开始调用libevent之前，可以进行一些设置来影响程序的行为。</p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2019/03/27/Network/IO/libevent/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Operating System/操作系统知识点" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/25/Operating System/操作系统知识点/" class="article-date">
      <time datetime="2019-03-25T13:03:29.000Z" itemprop="datePublished">2019-03-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/25/Operating System/操作系统知识点/">操作系统知识点</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="操作系统知识点"><a href="#操作系统知识点" class="headerlink" title="操作系统知识点"></a>操作系统知识点</h2><h3 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h3><p>IPC(Inter-Process Communication)进程间通信，提供了各种进程间通信的方法。在Linux C编程中有几种方法</p>
<ol>
<li>半双工Unix管道</li>
<li>FIFOs(命名管道)</li>
<li>消息队列</li>
<li>信号量</li>
<li>共享内存</li>
<li>Unix域套接字</li>
</ol>
<h3 id="多核CPU和进程线程"><a href="#多核CPU和进程线程" class="headerlink" title="多核CPU和进程线程"></a>多核CPU和进程线程</h3><ol>
<li>单CPU中进程只能是并发，多CPU计算机中进程可以并行。</li>
<li>单CPU单核中线程只能并发，单CPU多核中线程可以并行。</li>
</ol>
<h3 id="用户态和内核态的切换"><a href="#用户态和内核态的切换" class="headerlink" title="用户态和内核态的切换"></a>用户态和内核态的切换</h3><p>　　因为操作系统的资源是有限的，如果访问资源的操作过多，必然会消耗过多的资源，而且如果不对这些操作加以区分，很可能造成资源访问的冲突。所以，为了减少有限资源的访问和使用冲突，Unix/Linux的设计哲学之一就是：对不同的操作赋予不同的执行等级，就是所谓特权的概念。简单说就是有多大能力做多大的事，与系统相关的一些特别关键的操作必须由最高特权的程序来完成。Intel的X86架构的CPU提供了0到3四个特权级，数字越小，特权越高，Linux操作系统中主要采用了0和3两个特权级，分别对应的就是内核态和用户态。运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。比如C函数库中的内存分配函数malloc()，它具体是使用sbrk()系统调用来分配内存，当malloc调用sbrk()的时候就涉及一次从用户态到内核态的切换，类似的函数还有printf()，调用的是wirte()系统调用来输出字符串，等等。</p>
<p>一般存在以下三种情况会发生从用户态到内核态的切换：</p>
<p>1）<strong>系统调用</strong>：原因如上分析。</p>
<p>2）<strong>异常事件</strong>： 当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。</p>
<p>3）<strong>外围设备的中断</strong>：<strong><em>当外围设备完成用户的请求操作后，会向CPU发出中断信号</em></strong>，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</p>
<p>　　注意：系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为软中断，这是操作系统为用户特别开放的一种中断，如Linux int 80h中断。所以，从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，系统调用是进程主动请求切换的，而异常和硬中断则是被动的。</p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/操作系统/">操作系统</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/操作系统/">操作系统</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Database/Concept/数据库理论知识" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/25/Database/Concept/数据库理论知识/" class="article-date">
      <time datetime="2019-03-25T12:24:14.000Z" itemprop="datePublished">2019-03-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/25/Database/Concept/数据库理论知识/">数据库理论知识</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="数据库理论知识"><a href="#数据库理论知识" class="headerlink" title="数据库理论知识"></a>数据库理论知识</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇索引也称为聚集索引，聚类索引，簇集索引，聚簇索引确定表中数据的物理顺序。聚簇索引类似于电话簿，后者按姓氏排列数据。由于聚簇索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚簇索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。汉语字典也是聚簇索引的典型应用，在汉语字典里，索引项是字母+声调，字典正文也是按照先字母再声调的顺序排列。</p>
<h3 id="索引种类"><a href="#索引种类" class="headerlink" title="索引种类"></a>索引种类</h3><p>来自：<a href="https://www.cnblogs.com/sessionbest/articles/8689255.html" target="_blank" rel="noopener">https://www.cnblogs.com/sessionbest/articles/8689255.html</a></p>
<ol>
<li>按照索引列值的唯一性，索引可分为唯一索引和非唯一索引；</li>
<li>按照索引列的个数：单列索引和复合索引；</li>
<li>按照索引列的物理组织方式。</li>
</ol>
<p><strong>物理组织方式</strong>：</p>
<p>一、<strong>B树索引</strong></p>
<p>最常用的索引，各叶子节点中包括的数据有索引列的值和数据表中对应行的ROWID，简单的说，在B树索引中，是通过在索引中保存排过续的索引列值与相对应记录的ROWID来实现快速查询的目的。</p>
<p>可以保证无论用户要搜索哪个分支的叶子结点，都需要经过相同的索引层次，即都需要相同的I/O次数。</p>
<p>注1：索引是针对字段创建的，相同字段不能创建一个以上的索引；</p>
<p>注2：默认的索引是不唯一的，但是也可以加上unique，表示该索引的字段上没有重复值(定义unique约束时会自动创建)；</p>
<p>注3：创建主键时，默认在主键上创建了B树索引，因此不能再在主键上创建索引。</p>
<p>二、<strong>位图索引</strong></p>
<p>有些字段中使用B树索引的效率仍然不高，例如性别的字段中，只有“男、女”两个值，则即便使用了B树索引，在进行检索时也将返回接近一半的记录。</p>
<p>所以当字段的基数很低时，需要使用位图索引。(“低”的标准是取值数量 &lt; 行数*1%)</p>
<p><img src="http://118.25.53.128/Picture/Database/bitmap_index.jpg" alt="bitmap_index"></p>
<p>位图索引的逻辑结构如上图所示：索引中不再记录rowid和键值，而是将每个值作为一列，用0和1表示该行是否等于该键值(0表示否;1表示是)。其中位图索引的行顺序与原表的行顺序一致，可以在查询数据的过程中对应计算出行的原始物理位置。</p>
<p>注：位图索引不可能是唯一索引，也不能进行键值压缩。</p>
<p>三、<strong>反向键索引</strong></p>
<p>考虑这个情况：某一字段的值是1-1000顺序排列，建立B树索引后依旧递增，到后来该B数索引不断在后面增加分支，会形成不对称树。</p>
<p>反向键索引是<strong>一种特殊的B树索引</strong>，在存储构造中与B树索引完全相同，但是针对数值时，反向键索引会先反向每个键值的字节，然后对反向后的新数据进行索引。例如输入2008则转换为8002，这样当数值一次增加时，其反向键在大小中的分布仍然是比较平均的。</p>
<p>注：键的反转由系统自行完成。对于用户是透明的。</p>
<p>四、<strong>基于函数的索引</strong></p>
<p>有的时候，需要进行如下查询：<code>select * from t1 where to_char(date,&#39;yyyy&#39;)&gt;&#39;2007&#39;;</code></p>
<p>但是即便在date字段上建立了索引，还是不得不进行全表扫描。在这种情况下，可以使用基于函数的索引。</p>
<p>注：简单来说，基于函数的索引，就是将查询要用到的表达式作为索引项。</p>
<p>五、<strong>全局索引和局部索引</strong></p>
<p>这个索引貌似很复杂，其实很简单。总得来说一句话，就是无论怎么分区，都是为了方便管理。</p>
<p>具体索引和表的关系有三种：</p>
<p>1、局部分区索引：分区索引和分区表1对1</p>
<p>2、全局分区索引：分区索引和分区表N对N</p>
<p>3、全局非分区索引：非分区索引和分区表1对N</p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Database/">Database</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Database/">Database</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Operating System/Linux虚拟地址空间" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/24/Operating System/Linux虚拟地址空间/" class="article-date">
      <time datetime="2019-03-24T08:31:27.000Z" itemprop="datePublished">2019-03-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/24/Operating System/Linux虚拟地址空间/">Linux虚拟地址空间</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Linux虚拟地址空间"><a href="#Linux虚拟地址空间" class="headerlink" title="Linux虚拟地址空间"></a>Linux虚拟地址空间</h2><blockquote>
<p>整理自：<a href="http://www.cnblogs.com/clover-toeic/p/3754433.html" target="_blank" rel="noopener">http://www.cnblogs.com/clover-toeic/p/3754433.html</a></p>
<p>另一篇已经写了C程序内存结构，这篇是更详细的。</p>
</blockquote>
<p><strong>在多任务操作系统中</strong>，每个进程都运行在属于自己的内存沙盘中。这个沙盘就是<strong>虚拟地址空间(Virtual Address Space)</strong>，在32位模式下它是一个4GB的内存地址块。在Linux系统中, 内核进程和用户进程所占的虚拟内存比例是1:3，而Windows系统为2:2(通过设置Large-Address-Aware Executables标志也可为1:3)。这并不意味着内核使用那么多物理内存，仅表示它可支配这部分地址空间，根据需要将其映射到物理内存。</p>
<p><strong>虚拟地址通过页表(Page Table)映射到物理内存</strong>，页表由操作系统维护并被处理器引用。<strong>每个进程都拥有一套属于它自己的页表，因此对于每个进程而言都好像独享了整个虚拟地址空间。</strong></p>
<p><strong>内核空间在页表中拥有较高特权级，因此用户态程序试图访问这些页时会导致一个页错误</strong>(page fault)。</p>
<p><strong>在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存</strong>。内核代码和数据总是可寻址，随时准备处理中断和系统调用。<strong>与此相反，用户模式地址空间的映射随进程切换的发生而不断变化</strong>。</p>
<hr>
<p><strong>Linux进程在虚拟内存中的标准内存段布局</strong>如下图所示：</p>
<p><img src="http://118.25.53.128/Picture/Op/vitural_addr.jpg" alt="vitural_addr"></p>
<p>其中，用户地址空间中的蓝色条带对应于映射到物理内存的不同内存段，灰白区域表示未映射的部分。这些段只是简单的内存地址范围，与Intel处理器的段没有关系。</p>
<p>上图中<strong>Random stack offset等随机值意在防止恶意程序</strong>。Linux通过对栈、内存映射段、堆的起始地址加上随机偏移量来打乱布局，以免恶意程序通过计算访问栈、库函数等地址。execve(2)负责为进程代码段和数据段建立映射，真正将代码段和数据段的内容读入内存是由系统的缺页异常处理程序按需完成的。另外，execve(2)还会将BSS段清零。</p>
<p>在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并在内存中为这些段分配空间。栈也由操作系统分配和管理；堆由程序员自己管理，即显式地申请和释放空间。</p>
<p>BSS段、数据段和代码段是可执行程序编译时的分段，运行时还需要栈和堆。</p>
<hr>
<h3 id="mm-struct"><a href="#mm-struct" class="headerlink" title="mm_struct"></a>mm_struct</h3><p>内核使用内存描述符来表示进程的地址空间，该描述符表示着进程所有地址空间的信息。内存描述符由 mm_struct 结构体表示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span>           <span class="comment">/* 内存区域链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span>                  <span class="comment">/* VMA 形成的红黑树 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span>               <span class="comment">/* 所有 mm_struct 形成的链表 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> total_vm;                <span class="comment">/* 全部页面数目 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> locked_vm;               <span class="comment">/* 上锁的页面数据 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pinned_vm;               <span class="comment">/* Refcount permanently increased */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> shared_vm;               <span class="comment">/* 共享页面数目 Shared pages (files) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> exec_vm;                 <span class="comment">/* 可执行页面数目 VM_EXEC &amp; ~VM_WRITE */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm;                <span class="comment">/* 栈区页面数目 VM_GROWSUP/DOWN */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> def_flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data;    <span class="comment">/* 代码段、数据段 起始地址和结束地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack;                   <span class="comment">/* 栈区 的起始地址，堆区 起始地址和结束地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end;        <span class="comment">/* 命令行参数 和 环境变量的 起始地址和结束地址 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">    <span class="keyword">mm_context_t</span> context;                  <span class="comment">/* 体系结构特殊数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Must use atomic bitops to access the bits */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;                   <span class="comment">/* 状态标志位 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Coredumping and NUMA and HugePage 相关结构体 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://118.25.53.128/Picture/Op/mm_struct.png" alt="mm_struct"></p>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>线程是进程的执行单元，每个线程都运行在进程的上下文中，共享该进程虚拟地址空间里的：</p>
<ul>
<li><strong>代码段、数据段、堆、共享库、打开的文件</strong>。</li>
</ul>
<p>每个线程都有自己的线程上下文，包括：</p>
<ul>
<li><strong>线程 ID、栈、栈指针、PC、通用目的寄存器、条件码</strong>。</li>
</ul>
<p>各自独立的线程栈的内存模型并不整齐清楚，它们都保存在进程虚拟地址空间的栈区域中，通常被相应的线程独立访问，但<strong>并不对其他线程设防</strong>。</p>
<p><img src="http://118.25.53.128/Picture/Op/thread_model.png" alt="thread_model"></p>
<p><strong>线程栈</strong></p>
<p>从 Linux 内核的角度来说，其实它并没有线程的概念。Linux 把所有线程都当做进程来实现，它将线程和进程不加区分的统一到了 task_struct 中。<strong>线程仅仅被视为一个与其他进程共享某些资源的进程，而是否共享地址空间几乎是进程和 Linux 中所谓线程的唯一区别</strong>。线程创建的时候，加上了 CLONE_VM 标记，这样 线程的内存描述符 将直接指向 父进程的内存描述符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * current 是父进程而 tsk 在 fork() 执行期间是共享子进程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    atomic_inc(&amp;current-&gt;mm-&gt;mm_users);</span><br><span class="line">    tsk-&gt;mm = current-&gt;mm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然线程的地址空间和进程一样，但是对待其地址空间的 stack 还是有些区别的。对于 Linux 进程或者说主线程，其 stack 是在 fork 的时候生成的，实际上就是复制了父亲的 stack 空间地址，然后写时拷贝 (cow) 以及动态增长。然而对于主线程生成的子线程而言，其 stack 将不再是这样的了，而是事先固定下来的，使用 mmap 系统调用，它不带有 VM_STACK_FLAGS 标记。<strong>线程栈不能动态增长，一旦用尽就没了，这是和生成进程的 fork 不同的地方</strong>。</p>
<p><strong>线程的栈在哪？</strong></p>
<p>Stack space for a new thread is created by the parent thread with <code>mmap(MAP_ANONYMOUS|MAP_STACK)</code>. So they’re in the “memory map segment”. It can end up anywhere that a large <code>malloc()</code> could go. (glibc <code>malloc(3)</code> uses <code>mmap(MAP_ANONYMOUS)</code> for large allocations.)</p>
<hr>
<h3 id="各个分段的含义"><a href="#各个分段的含义" class="headerlink" title="各个分段的含义"></a>各个分段的含义</h3><ul>
<li><p><strong>内核空间</strong></p>
<p>内核总是驻留在内存中，是操作系统的一部分。内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。</p>
</li>
<li><p><strong>栈</strong>(stack)</p>
<p>栈又称堆栈，由编译器自动分配释放，行为类似数据结构中的栈(先进后出)。堆栈主要有三个用途：</p>
<ul>
<li>为函数内部声明的非静态局部变量(C语言中称“自动变量”)提供存储空间。</li>
<li>记录函数调用过程相关的维护性信息，称为栈帧(Stack Frame)或过程活动记录(Procedure Activation Record)。它包括函数返回地址，不适合装入寄存器的函数参数及一些寄存器值的保存。除递归调用外，堆栈并非必需。因为编译时可获知局部变量，参数和返回地址所需空间，并将其分配于BSS段。</li>
<li>临时存储区，用于暂存长算术表达式部分计算结果或alloca()函数分配的栈内内存。</li>
</ul>
<p>持续地重用栈空间有助于使活跃的栈内存保持在CPU缓存中，从而加速访问。<strong>进程中的每个线程都有属于自己的栈。</strong>向栈中不断压入数据时，若超出其容量就会耗尽栈对应的内存区域，从而触发一个页错误。此时若栈的大小低于堆栈最大值RLIMIT_STACK(通常是8M)，则<strong>栈会动态增长</strong>，程序继续运行。<strong>映射的栈区扩展到所需大小后，不再收缩。</strong></p>
<p>Linux中<code>ulimit -s</code>命令可查看和设置堆栈最大值，当程序使用的堆栈超过该值时, 发生栈溢出(Stack Overflow)，程序收到一个段错误(Segmentation Fault)。注意，调高堆栈容量可能会增加内存开销和启动时间。</p>
<p>堆栈既可向下增长(向内存低地址)也可向上增长, 这依赖于具体的实现。本文所述堆栈向下增长。</p>
<p>堆栈的大小在运行时由内核动态调整。</p>
</li>
<li><p><strong>内存映射段(mmap)</strong></p>
<p>此处，内核<strong>将硬盘文件的内容直接映射到内存</strong>, 任何应用程序都可通过<strong>Linux的mmap()</strong>系统调用或Windows的CreateFileMapping()/MapViewOfFile()请求这种映射。<strong>内存映射是一种方便高效的文件I/O方式， 因而被用于装载动态共享库</strong>。用户也可创建匿名内存映射，该映射没有对应的文件, 可用于存放程序数据。<strong>在 Linux中，若通过malloc()请求一大块内存，C运行库将创建一个匿名内存映射，而不使用堆内存。”大块” 意味着比阈值 MMAP_THRESHOLD还大，缺省为128KB，可通过mallopt()调整。</strong></p>
<p>（该区域用于映射用到的动态链接库。在Linux 2.4版本中，若可执行文件依赖共享库，则系统会为这些动态库在从0x40000000开始的地址分配相应空间，并在程序装载时将其载入到该空间。在Linux 2.6内核中，共享库的起始地址被往上移动至更靠近栈区的位置。）</p>
<p>（从进程地址空间的布局可以看到，在有共享库的情况下，留给堆的可用空间还有两处：一处是从.bss段到0x40000000，约不到1GB的空间；另一处是从共享库到栈之间的空间，约不到2GB。这两块空间大小取决于栈、共享库的大小和数量。这样来看，是否应用程序可申请的最大堆空间只有2GB？事实上，这与Linux内核版本有关。在上面给出的进程地址空间经典布局图中，共享库的装载地址为0x40000000，这实际上是Linux kernel 2.6版本之前的情况了，在2.6版本里，共享库的装载地址已经被挪到靠近栈的位置，即位于0xBFxxxxxx附近，因此，此时的堆范围就不会被共享库分割成2个“碎片”，故kernel 2.6的32位Linux系统中，malloc申请的最大内存理论值在2.9GB左右。）</p>
</li>
<li><p><strong>堆</strong>(heap)</p>
<p>堆用于存放进程运行时动态分配的内存段，可动态扩张或缩减。<strong>堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问</strong>。当进程调用malloc(C)/new(C++)等函数分配内存时，新分配的内存动态添加到堆上(扩张)；当调用free(C)/delete(C++)等函数释放内存时，被释放的内存从堆中剔除(缩减) 。</p>
<p>分配的堆内存是经过字节对齐的空间，以适合原子操作。堆管理器通过链表管理每个申请的内存，由于堆申请和释放是无序的，最终会产生内存碎片。堆内存一般由应用程序分配释放，回收的内存可供重新使用。若程序员不释放，程序结束时操作系统可能会自动回收。</p>
<p>堆的末端由break指针标识，当堆管理器需要更多内存时，可通过系统调用brk()和sbrk()来移动break指针以扩张堆，一般由系统自动调用。</p>
</li>
<li><p>【扩展阅读】<strong>栈和堆的区别</strong></p>
<ul>
<li>①<strong>管理方式</strong>：栈由编译器自动管理；堆由程序员控制，使用方便，但易产生内存泄露。</li>
<li>②<strong>生长方向</strong>：栈向低地址扩展(即”向下生长”)，是连续的内存区域；堆向高地址扩展(即”向上生长”)，是不连续的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。</li>
<li>③<strong>空间大小</strong>：栈顶地址和栈的最大容量由系统预先规定(通常默认2M或10M)；堆的大小则受限于计算机系统中有效的虚拟内存，32位Linux系统中堆内存可达2.9G空间。</li>
<li>④<strong>存储内容</strong>：栈在函数调用时，首先压入主调函数中下条指令(函数调用语句的下条可执行语句)的地址，然后是函数实参，然后是被调函数的局部变量。本次调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的指令地址，程序由该点继续运行下条可执行语句。堆通常在头部用一个字节存放其大小，堆用于存储生存期与函数调用无关的数据，具体内容由程序员安排。</li>
<li>⑤<strong>分配方式</strong>：栈可静态分配或动态分配。静态分配由编译器完成，如局部变量的分配。动态分配由alloca函数在栈上申请空间，用完后自动释放。堆只能动态分配且手工释放。</li>
<li>⑥<strong>分配效率</strong>：栈由计算机底层提供支持：分配专门的寄存器存放栈地址，压栈出栈由专门的指令执行，因此效率较高。堆由函数库提供，机制复杂，效率比栈低得多。Windows系统中VirtualAlloc可直接在进程地址空间中分配一块内存，快速且灵活。</li>
<li>⑦<strong>分配后系统响应</strong>：只要栈剩余空间大于所申请空间，系统将为程序提供内存，否则报告异常提示栈溢出。     操作系统为堆维护一个记录空闲内存地址的链表。当系统收到程序的内存分配申请时，会遍历该链表寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点空间分配给程序。若无足够大小的空间(可能由于内存碎片太多)，有可能调用系统功能去增加程序数据段的内存空间，以便有机会分到足够大小的内存，然后进行返回。，大多数系统会在该内存空间首地址处记录本次分配的内存大小，供后续的释放函数(如free/delete)正确释放本内存空间。     此外，由于找到的堆结点大小不一定正好等于申请的大小，系统会自动将多余的部分重新放入空闲链表中。</li>
<li>⑧<strong>碎片问题</strong>：栈不会存在碎片问题，因为栈是先进后出的队列，内存块弹出栈之前，在其上面的后进的栈内容已弹出。而频繁申请释放操作会造成堆内存空间的不连续，从而造成大量碎片，使程序效率降低。     可见，堆容易造成内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和内核态切换，内存申请的代价更为昂贵。所以栈在程序中应用最广泛，函数调用也利用栈来完成，调用过程中的参数、返回地址、栈基指针和局部变量等都采用栈的方式存放。所以，建议尽量使用栈，仅在分配大量或大块内存空间时使用堆。</li>
</ul>
</li>
<li><p><strong>BSS段</strong>(Block Started by Symbol)</p>
<p>BSS段中通常存放程序中以下符号：</p>
<ul>
<li>未初始化的全局变量和静态局部变量</li>
<li>初始值为0的全局变量和静态局部变量(依赖于编译器实现)</li>
<li>未定义且初值不为0的符号(该初值即common block的大小)</li>
</ul>
<p>C语言中，未显式初始化的静态分配变量被初始化为0(算术类型)或空指针(指针类型)。由于程序加载时，BSS会被操作系统清零，所以未赋初值或初值为0的全局变量都在BSS中。BSS段仅为未初始化的静态分配变量预留位置，在目标文件中并不占据空间，这样可<strong>减少目标文件体积</strong>。但程序运行时需为变量分配内存空间，故目标文件必须记录所有未初始化的静态分配变量大小总和(通过start_bss和end_bss地址写入机器代码)。当加载器(loader)加载程序时，将为BSS段分配的内存初始化为0。在嵌入式软件中，进入main()函数之前BSS段被C运行时系统映射到初始化为全零的内存(效率较高)。</p>
<p>注意，尽管均放置于BSS段，但初值为0的全局变量是强符号，而未初始化的全局变量是弱符号。若其他地方已定义同名的强符号(初值可能非0)，则弱符号与之链接时不会引起重定义错误，但运行时的初值可能并非期望值(会被强符号覆盖)。因此，定义全局变量时，若只有本文件使用，则尽量使用static关键字修饰；否则需要<strong>为全局变量定义赋初值(哪怕0值)，保证该变量为强符号，以便链接时发现变量名冲突</strong>，而不是被未知值覆盖。</p>
</li>
<li><p><strong>数据段</strong>(Data)</p>
<p>数据段通常用于存放程序中已初始化且初值不为0的全局变量和静态局部变量。数据段属于静态内存分配(静态存储区)，可读可写。</p>
<p>数据段保存在目标文件中(在嵌入式系统里一般固化在镜像文件中)，其内容由程序初始化。例如，对于全局变量int gVar = 10，必须在目标文件数据段中保存10这个数据，然后在程序加载时复制到相应的内存。</p>
</li>
<li><p>【扩展阅读】<strong>数据段与BSS段的区别</strong></p>
<ul>
<li><p>BSS段不占用物理文件尺寸，但占用内存空间；数据段占用物理文件，也占用内存空间。</p>
<p>对于大型数组如int ar0[10000] = {1, 2, 3, …}和int ar1[10000]，ar1放在BSS段，只记录共有10000*4个字节需要初始化为0，而不是像ar0那样记录每个数据1、2、3…，此时BSS为目标文件所节省的磁盘空间相当可观。</p>
</li>
<li><p>当程序读取数据段的数据时，系统会出发缺页故障，从而分配相应的物理内存；当程序读取BSS段的数据时，内核会将其转到一个全零页面，不会发生缺页故障，也不会为其分配相应的物理内存。</p>
</li>
</ul>
</li>
<li><p><strong>代码段</strong>(text)</p>
<p>代码段也称正文段或文本段，通常用于存放程序执行代码(即CPU执行的机器指令)。一般C语言执行语句都编译成机器代码保存在代码段。通常代码段是可共享的，因此频繁执行的程序只需要在内存中拥有一份拷贝即可。代码段通常属于只读，以防止其他程序意外地修改其指令(对该段的写操作将导致段错误)。某些架构也允许代码段为可写，即允许修改程序。</p>
<p>代码段指令根据程序设计流程依次执行，对于顺序指令，只会执行一次(每个进程)；若有反复，则需使用跳转指令；若进行递归，则需要借助栈来实现。</p>
<p>代码段指令中包括操作码和操作对象(或对象地址引用)。若操作对象是立即数(具体数值)，将直接包含在代码中；若是局部数据，将在栈区分配空间，然后引用该数据地址；若位于BSS段和数据段，同样引用该数据地址。</p>
<p>代码段最容易受优化措施影响。</p>
</li>
<li><p><strong>保留区</strong></p>
<p><strong>位于虚拟地址空间的最低部分</strong>，未赋予物理地址。任何对它的引用都是非法的，<strong>用于捕捉使用空指针和小整型值指针引用内存的异常情况</strong>。</p>
<p>它并不是一个单一的内存区域，而是对地址空间中受到操作系统保护而禁止用户进程访问的地址区域的总称。大多数操作系统中，极小的地址通常都是不允许访问的，如NULL。<strong>C语言将无效指针赋值为0也是出于这种考虑</strong>，因为0地址上正常情况下不会存放有效的可访问数据。</p>
</li>
</ul>
<hr>
<h3 id="分段的好处"><a href="#分段的好处" class="headerlink" title="分段的好处"></a>分段的好处</h3><p>进程运行过程中，代码指令根据流程依次执行，只需访问一次(当然跳转和递归可能使代码执行多次)；而数据(数据段和BSS段)通常需要访问多次，因此单独开辟空间以方便访问和节约空间。具体解释如下：</p>
<p>当程序被装载后，数据和指令分别映射到两个虚存区域。数据区对于进程而言可读写，而指令区对于进程只读。两区的权限可分别设置为可读写和只读。以防止程序指令被有意或无意地改写。</p>
<p>现代CPU具有极为强大的缓存(Cache)体系，程序必须尽量提高缓存命中率。<strong>指令区和数据区的分离有利于提高程序的局部性</strong>。现代CPU一般数据缓存和指令缓存分离，故程序的指令和数据分开存放有利于<strong>提高CPU缓存命中率。</strong></p>
<p>当系统中运行多个该程序的副本时，其指令相同，故内存中只须保存一份该程序的指令部分。若系统中运行数百进程，通过共享指令将节省大量空间(尤其对于有动态链接的系统)。其他只读数据如程序里的图标、图片、文本等资源也可共享。而每个副本进程的数据区域不同，它们是进程私有的。</p>
<p>此外，临时数据及需要再次使用的代码在运行时放入栈区中，生命周期短。全局数据和静态数据可能在整个程序执行过程中都需要访问，因此单独存储管理。堆区由用户自由分配，以便管理。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/操作系统/">操作系统</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/操作系统/">操作系统</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C_C++/C++Collection/C++ref" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/23/C_C++/C++Collection/C++ref/" class="article-date">
      <time datetime="2019-03-23T10:28:23.000Z" itemprop="datePublished">2019-03-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/23/C_C++/C++Collection/C++ref/">C++ref</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="C-ref"><a href="#C-ref" class="headerlink" title="C++ ref"></a>C++ ref</h2><p>像thread类 和 bind函数的参数只能按值传递（内部decay，移除了引用），如果想传递引用，那么就需要 <code>std::ref</code>，const引用则用<code>cref</code>。</p>
<p>ref的返回类型为<code>std::reference_wrapper</code>，其实这个模板类保存了传入参数的地址，然后定义了左值引用的类型转化函数，所以把它赋值给一个引用就可以让这个引用获得对象内保存的地址，看起来就和真正的引用一样了。</p>
<p>官方实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">reference_wrapper</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// types</span></span><br><span class="line">  <span class="keyword">typedef</span> T type;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// construct/copy/destroy</span></span><br><span class="line">  reference_wrapper(T&amp; ref) <span class="keyword">noexcept</span> : _ptr(<span class="built_in">std</span>::addressof(ref)) &#123;&#125;</span><br><span class="line">  reference_wrapper(T&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  reference_wrapper(<span class="keyword">const</span> reference_wrapper&amp;) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// assignment</span></span><br><span class="line">  reference_wrapper&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> reference_wrapper&amp; x) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// access</span></span><br><span class="line">  <span class="keyword">operator</span> T&amp; () <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">  <span class="function">T&amp; <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span>... <span class="title">ArgTypes</span> &gt;</span></span><br><span class="line"><span class="class">  <span class="title">std</span>:</span>:<span class="keyword">invoke_result_t</span>&lt;T&amp;, ArgTypes...&gt;</span><br><span class="line">    <span class="keyword">operator</span>() ( ArgTypes&amp;&amp;... args ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::invoke(get(), <span class="built_in">std</span>::forward&lt;ArgTypes&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T* _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// deduction guides</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">reference_wrapper</span>(<span class="title">reference_wrapper</span>&lt;T&gt;) -&gt; <span class="title">reference_wrapper</span>&lt;T&gt;;</span></span><br></pre></td></tr></table></figure>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Network/Tcp/IP头_TCP头_UDP头" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/22/Network/Tcp/IP头_TCP头_UDP头/" class="article-date">
      <time datetime="2019-03-22T14:49:12.000Z" itemprop="datePublished">2019-03-22</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/22/Network/Tcp/IP头_TCP头_UDP头/">IP头_TCP头_UDP头</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>源自：<a href="https://www.cnblogs.com/shenpengyan/p/5912567.html" target="_blank" rel="noopener">https://www.cnblogs.com/shenpengyan/p/5912567.html</a></p>
<h3 id="报文封装整体结构"><a href="#报文封装整体结构" class="headerlink" title="报文封装整体结构"></a>报文封装整体结构</h3><p><img src="http://118.25.53.128/Picture/Tcp/o_封装结构.jpg" alt="o_封装结构"></p>
<h3 id="mac帧头定义"><a href="#mac帧头定义" class="headerlink" title="mac帧头定义"></a>mac帧头定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数据帧定义，头14个字节，尾4个字节*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MAC_FRAME_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span> m_cDstMacAddress[<span class="number">6</span>];    <span class="comment">//目的mac地址</span></span><br><span class="line">   <span class="keyword">char</span> m_cSrcMacAddress[<span class="number">6</span>];    <span class="comment">//源mac地址</span></span><br><span class="line">	 <span class="keyword">short</span> m_cType;       　　　　　<span class="comment">//上一层协议类型，如0x0800代表上一层是IP协议，0x0806为arp</span></span><br><span class="line">&#125;__attribute__((packed))MAC_FRAME_HEADER,*PMAC_FRAME_HEADER;</span><br></pre></td></tr></table></figure>
<h3 id="ip头部定义"><a href="#ip头部定义" class="headerlink" title="ip头部定义"></a>ip头部定义</h3><p><img src="http://118.25.53.128/Picture/Tcp/o_ip_header.jpg" alt="o_ip头部2"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IP头定义，共20个字节*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IP_HEADER</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">char</span> m_cVersionAndHeaderLen;					<span class="comment">//版本信息(前4位)，头长度(后4位)</span></span><br><span class="line"> <span class="keyword">char</span> m_cTypeOfService;								<span class="comment">// 服务类型8位</span></span><br><span class="line"> <span class="keyword">short</span> m_sTotalLenOfPacket;						<span class="comment">//数据包长度</span></span><br><span class="line"> <span class="keyword">short</span> m_sPacketID;										<span class="comment">//数据包标识</span></span><br><span class="line"> <span class="keyword">short</span> m_sSliceinfo;									<span class="comment">//分片使用</span></span><br><span class="line"> <span class="keyword">char</span> m_cTTL;													<span class="comment">//存活时间</span></span><br><span class="line"> <span class="keyword">char</span> m_cTypeOfProtocol;							<span class="comment">//协议类型</span></span><br><span class="line"> <span class="keyword">short</span> m_sCheckSum;      　　　　　　 	<span class="comment">//校验和</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> m_uiSourIp;							<span class="comment">//源ip</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> m_uiDestIp;							<span class="comment">//目的ip</span></span><br><span class="line">&#125; __attribute__((packed))IP_HEADER, *PIP_HEADER ;</span><br></pre></td></tr></table></figure>
<ul>
<li>版本（Version）字段：占4比特。用来表明IP协议实现的版本号，当前一般为IPv4，即0100。</li>
<li>报头长度（Internet Header Length，IHL）字段：占4比特。是头部占32比特的数字，包括可选项。普通IP数据报（没有任何选项），该字段的值是5，即160比特=20字节。此字段最大值为60字节。</li>
<li>服务类型（Type of Service ，TOS）字段：占8比特。其中前3比特为优先权子字段（Precedence，现已被忽略）。第8比特保留未用。<strong><em>第4至第7比特分别代表延迟、吞吐量、可靠性和花费</em></strong>。当它们取值为1时分别代表要求最小时延、最大吞吐量、最高可靠性和最小费用。这4比特的服务类型中只能置其中1比特为1。可以全为0，若全为0则表示一般服务。服务类型字段声明了数据报被网络系统传输时可以被怎样处理。例如：TELNET协议可能要求有最小的延迟，FTP协议（数据）可能要求有最大吞吐量，SNMP协议可能要求有最高可靠性，NNTP（Network News Transfer Protocol，网络新闻传输协议）可能要求最小费用，而ICMP协议可能无特殊要求（4比特全为0）。实际上，大部分主机会忽略这个字段，但一些动态路由协议如OSPF（Open Shortest Path First Protocol）、IS-IS（Intermediate System to Intermediate System Protocol）可以根据这些字段的值进行路由决策。</li>
<li>总长度字段：占16比特。指明整个数据报的长度（以字节为单位）。最大长度为65535字节。</li>
<li><strong>标志字段：占16比特。用来唯一地标识主机发送的每一份数据报。通常每发一份报文，它的值会加1。</strong></li>
<li>标志位字段：占3比特。标志一份数据报<strong>是否要求分段</strong>。</li>
<li>段偏移字段：占13比特。如果一份数据报要求分段的话，此字段指明该段偏移距原始数据报开始的位置。</li>
<li>生存期（TTL：Time to Live）字段：占8比特。用来设置数据报最多可以经过的路由器数。由发送数据的源主机设置，通常为32、64、128等。每经过一个路由器，其值减1，直到0时该数据报被丢弃。</li>
<li>协议字段：占8比特。指明IP层所封装的上层协议类型，如ICMP（1）、IGMP（2） 、TCP（6）、UDP（17）等。</li>
<li>头部校验和字段：占16比特。内容是根据IP头部计算得到的校验和码。计算方法是：对头部中每个16比特进行二进制反码求和。（和ICMP、IGMP、TCP、UDP不同，IP不对头部后的数据进行校验）。</li>
<li>源IP地址、目标IP地址字段：各占32比特。用来标明发送IP数据报文的源主机地址和接收IP报文的目标主机地址。</li>
<li>可选项字段：占32比特。用来定义一些任选项：如记录路径、时间戳等。这些选项很少被使用，同时并不是所有主机和路由器都支持这些选项。可选项字段的长度必须是32比特的整数倍，如果不足，必须填充0以达到此长度要求。</li>
</ul>
<h3 id="tcp头部定义"><a href="#tcp头部定义" class="headerlink" title="tcp头部定义"></a>tcp头部定义</h3><p><img src="http://118.25.53.128/Picture/Tcp/o_tcp_header.jpg" alt="o_tcp头部2"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*TCP头定义，共20个字节*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TCP_HEADER</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">short</span> m_sSourPort;										<span class="comment">// 源端口号16bit</span></span><br><span class="line"> <span class="keyword">short</span> m_sDestPort;										<span class="comment">// 目的端口号16bit</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> m_uiSequNum;						<span class="comment">// 序列号32bit</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> m_uiAcknowledgeNum;			<span class="comment">// 确认号32bit</span></span><br><span class="line"> <span class="keyword">short</span> m_sHeaderLenAndFlag;						<span class="comment">// 前4位：TCP头长度；中6位：保留；后6位：标志位</span></span><br><span class="line"> <span class="keyword">short</span> m_sWindowSize;									<span class="comment">// 窗口大小16bit</span></span><br><span class="line"> <span class="keyword">short</span> m_sCheckSum;										<span class="comment">// 检验和16bit</span></span><br><span class="line"> <span class="keyword">short</span> m_surgentPointer;							<span class="comment">// 紧急数据偏移量16bit</span></span><br><span class="line">&#125;__attribute__((packed))TCP_HEADER, *PTCP_HEADER;</span><br><span class="line"><span class="comment">/*TCP头中的选项定义</span></span><br><span class="line"><span class="comment">kind(8bit)+Length(8bit，整个选项的长度，包含前两部分)+内容(如果有的话)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">KIND = </span></span><br><span class="line"><span class="comment">  1表示 无操作NOP，无后面的部分</span></span><br><span class="line"><span class="comment">  2表示 maximum segment 后面的LENGTH就是maximum segment选项的长度（以byte为单位，1+1+内容部分长度）</span></span><br><span class="line"><span class="comment">  3表示 windows scale 后面的LENGTH就是 windows scale选项的长度（以byte为单位，1+1+内容部分长度）</span></span><br><span class="line"><span class="comment">  4表示 SACK permitted，LENGTH为2，没有内容部分</span></span><br><span class="line"><span class="comment">  5表示 这是一个SACK包，LENGTH为2，没有内容部分</span></span><br><span class="line"><span class="comment">  8表示 时间戳，LENGTH为10，含8个字节的时间戳</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>源、目标端口号字段：占16比特。TCP协议通过使用”端口”来标识源端和目标端的应用进程。端口号可以使用0到65535之间的任何数字。在收到服务请求时，操作系统动态地为客户端的应用程序分配端口号。在服务器端，每种服务在”众所周知的端口”（Well-Know Port）为用户提供服务。</p>
</li>
<li><p>顺序号字段：占32比特。用来标识从TCP源端向TCP目标端发送的数据字节流，当前所携带的数据的第一个字节的顺序号。</p>
<p>（如：本次连接共要发送1000个字节，已发出了100个字节，现在发送下一个报文，假设每个报文携带的数据为100字节，则这个报文的头结构中的序号是100【注：从0开始编号】）</p>
</li>
<li><p><strong>确认号字段：占32比特。只有ACK标志为1时，确认号字段才有效。它包含源端期望收到目标端的下一个数据字节的序号。</strong></p>
<p>（如上例中那个报文已被正确接收，则接收端会发送一个ACK=1且确认序号=200的应答报文给发送方。）</p>
</li>
<li><p>头部长度字段：占4比特。给出头部占32比特的数目。没有任何选项字段的TCP头部长度为20字节；最多可以有60字节的TCP头部。</p>
</li>
<li><p>标志位字段（U、A、P、R、S、F）：占6比特。各比特的含义如下：</p>
<ul>
<li><p>URG：紧急指针（urgent pointer）有效。</p>
</li>
<li><p>ACK：确认序号有效。</p>
</li>
<li><p>PSH：接收方应该尽快将这个报文段交给应用层。</p>
</li>
<li><p>RST：重建连接。</p>
</li>
<li><p>SYN：发起一个连接。</p>
</li>
<li><p>FIN：释放一个连接。</p>
</li>
</ul>
</li>
<li><p><strong>窗口大小字段：占16比特。此字段用来进行流量控制。单位为字节数，这个值是本机期望一次接收的字节数。</strong></p>
</li>
<li><p>TCP校验和字段：占16比特。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。</p>
</li>
<li><p><strong>紧急指针字段：占16比特。它是一个偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。</strong></p>
</li>
<li><p>选项字段：占32比特。可能包括”窗口扩大因子”、”时间戳”等选项。</p>
</li>
</ul>
<h3 id="udp头部定义"><a href="#udp头部定义" class="headerlink" title="udp头部定义"></a>udp头部定义</h3><p><img src="http://118.25.53.128/Picture/Tcp/o_udp_header.jpg" alt="o_udp头部"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*UDP头定义，共8个字节*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UDP_HEADER</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> m_usSourPort;					<span class="comment">// 源端口号16bit</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> m_usDestPort;					<span class="comment">// 目的端口号16bit</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> m_usLength;						<span class="comment">// 数据包长度16bit</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> m_usCheckSum;					<span class="comment">// 校验和16bit</span></span><br><span class="line">&#125;__attribute__((packed))UDP_HEADER, *PUDP_HEADER;</span><br></pre></td></tr></table></figure>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C_C++/C++Collection/C++线程池" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/22/C_C++/C++Collection/C++线程池/" class="article-date">
      <time datetime="2019-03-22T05:05:39.000Z" itemprop="datePublished">2019-03-22</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/22/C_C++/C++Collection/C++线程池/">C++线程池</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="C-线程池原理（转）"><a href="#C-线程池原理（转）" class="headerlink" title="C++线程池原理（转）"></a>C++线程池原理（转）</h2><h3 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h3><p>目前的大多数网络服务器都具有一个共同点，就是单位时间内必须处理数目巨大的连接请求，但处理时间却相对较短。 </p>
<p>传统多线程方案中我们采用的服务器模型则是一旦接受到请求之后，即创建一个新的线程，由该线程执行任务。任务执行完毕后，线程退出，这就是是“即时创建，即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数极其频繁，那么服务器将处于不停的创建线程，销毁线程的状态。</p>
<p>我们将传统方案中的线程执行过程分为三个过程：T1、T2、T3。</p>
<ol>
<li>T1：线程创建时间</li>
<li>T2：线程执行时间，包括线程的同步等时间</li>
<li>T3：线程销毁时间</li>
</ol>
<p>那么我们可以看出，线程本身的开销所占的比例为(T1+T3) / (T1+T2+T3)。如果线程执行的时间很短的话，这比开销可能占到20%-50%左右。</p>
<p>除此之外，线程池能够减少创建的线程个数。通常线程池所允许的并发线程是有上界的，如果同时需要并发的线程数超过上界，那么一部分线程将会等待。而传统方案中，如果同时请求数目为2000，那么最坏情况下，系统可能需要产生2000个线程。</p>
<p>因此线程池的出现正是着眼于减少线程池本身带来的开销。线程池采用预创建的技术，在应用程序启动之后，将立即创建一定数量的线程(N1)，放入空闲队列中。这些线程都是处于阻塞（Suspended）状态，不消耗CPU，但占用较小的内存空间。当任务到来后，缓冲池选择一个空闲线程，把任务传入此线程中运行。当N1个线程都在处理任务后，缓冲池自动创建一定数量的新线程，用于处理更多的任务。在任务执行完毕后线程也不退出，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程都一直处于暂停状态，线程池自动销毁一部分线程，回收系统资源。</p>
<p>基于这种预创建技术，线程池将线程创建和销毁本身所带来的开销分摊到了各个具体的任务上，执行次数越多，每个任务所分担到的线程本身开销则越小，不过我们另外可能需要考虑进去线程之间同步所带来的开销</p>
<h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><p>事实上，线程池并不是万能的。它有其特定的使用场合。</p>
<p>线程池致力于减少线程本身的开销对应用所产生的影响，这是有前提的，前提就是线程本身开销与线程执行任务相比不可忽略。如果线程本身的开销相对于线程任务执行开销而言是可以忽略不计的，那么此时线程池所带来的好处是不明显的，比如对于FTP服务器以及Telnet服务器，通常传送文件的时间较长，开销较大，那么此时，我们采用线程池未必是理想的方法，我们可以选择“即时创建，即时销毁”的策略。 </p>
<p>总之线程池通常适合下面的几个场合： </p>
<ol>
<li>单位时间内<strong>处理任务频繁而且任务处理时间短</strong>。</li>
<li><strong>对实时性要求较高</strong>。如果接受到任务后在创建线程，可能满足不了实时要求，因此必须采用线程池进行预创建。 </li>
<li>必须<strong>经常面对高突发性事件</strong>，如果采取传统方法，会不停地大量产生线程，销毁线程。此时采用动态线程池可以避免这种情况的发生。</li>
</ol>
<h3 id="线程池框架"><a href="#线程池框架" class="headerlink" title="线程池框架"></a>线程池框架</h3><p>一般线程池都必须具备下面几个组成部分：</p>
<ul>
<li>线程池管理器：用于创建并管理线程池</li>
<li>工作线程：线程池中实际执行的线程</li>
<li>任务接口：尽管线程池大多数情况下是用来支持网络服务器，但是我们将线程执行的任务抽象出来，形成任务接口，从而使得线程池与具体的任务无关。</li>
<li>任务队列：线程池的概念具体到实现则可能是队列，链表之类的数据结构，其中保存执行线程。</li>
</ul>
<hr>
<p>我们实现的通用线程池框架由五个重要部分组成CThreadManage，CThreadPool，CThread，CJob，</p>
<ul>
<li><p>CWorkerThread，除此之外框架中还包括线程同步使用的类CThreadMutex和CCondition。 </p>
</li>
<li><p>CJob是所有的任务的基类，其提供一个接口Run，所有的任务类都必须从该类继承，同时实现Run方法。该方法中实现具体的任务逻辑。 </p>
</li>
<li><p>CThread是Linux中线程的包装，其封装了Linux线程最经常使用的属性和方法，它也是一个抽象类，是所有线程类的基类，具有一个接口Run。 </p>
</li>
<li><p>CWorkerThread是实际被调度和执行的线程类，其从CThread继承而来，实现了CThread中的Run方法。 </p>
</li>
<li><p>CThreadPool是线程池类，其负责保存线程，释放线程以及调度线程。 </p>
</li>
<li><p>CThreadManage是线程池与用户的直接接口，其屏蔽了内部的具体实现。 </p>
</li>
<li><p>CThreadMutex用于线程之间的互斥。 </p>
</li>
<li><p>CCondition则是条件变量的封装，用于线程之间的同步。 </p>
</li>
</ul>
<p>线程池的时序很简单。CThreadManage直接跟客户端打交道，其接受需要创建的线程初始个数，并接受客户端提交的任务。这儿的任务是具体的非抽象的任务。CThreadManage的内部实际上调用的都是CThreadPool的相关操作。CThreadPool创建具体的线程，并把客户端提交的任务分发给CWorkerThread，CWorkerThread实际执行具体的任务。</p>
<h3 id="组件实现"><a href="#组件实现" class="headerlink" title="组件实现"></a>组件实现</h3><h4 id="CThreadManage"><a href="#CThreadManage" class="headerlink" title="CThreadManage"></a>CThreadManage</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CThreadManage</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    CThreadPool*    m_Pool; </span><br><span class="line">    <span class="keyword">int</span>          m_NumOfThread; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetParallelNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    CThreadManage();</span><br><span class="line">    CThreadManage(<span class="keyword">int</span> num);</span><br><span class="line">    <span class="keyword">virtual</span> ~CThreadManage();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">Run</span><span class="params">(CJob* job,<span class="keyword">void</span>* jobdata)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">TerminateAll</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中：m_Pool指向实际的线程池。m_NumOfThread是初始创建时候允许创建的并发的线程个数。另外Run和TerminateAll方法只是简单的调用CThreadPool的一些相关方法。具体实现如下: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CThreadManage::CThreadManage()&#123; </span><br><span class="line">    m_NumOfThread = <span class="number">10</span>; </span><br><span class="line">    m_Pool = <span class="keyword">new</span> CThreadPool(m_NumOfThread); </span><br><span class="line">&#125; </span><br><span class="line">CThreadManage::CThreadManage(<span class="keyword">int</span> num)&#123; </span><br><span class="line">    m_NumOfThread = num; </span><br><span class="line">    m_Pool = <span class="keyword">new</span> CThreadPool(m_NumOfThread); </span><br><span class="line">&#125; </span><br><span class="line">CThreadManage::~CThreadManage()&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != m_Pool)</span><br><span class="line">    <span class="keyword">delete</span> m_Pool;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CThreadManage::SetParallelNum(<span class="keyword">int</span> num)&#123; </span><br><span class="line">    m_NumOfThread = num; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CThreadManage::Run(CJob* job,<span class="keyword">void</span>* jobdata)&#123; </span><br><span class="line">    m_Pool-&gt;Run(job,jobdata); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CThreadManage::TerminateAll(<span class="keyword">void</span>)&#123; </span><br><span class="line">    m_Pool-&gt;TerminateAll(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CThread"><a href="#CThread" class="headerlink" title="CThread"></a>CThread</h4><p>CThread 类实现了对Linux中线程操作的封装，它是所有线程的基类，也是一个抽象类，提供了一个抽象接口Run，所有的CThread都必须实现该Run方法。CThread的定义如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CThread</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span>          m_ErrCode; </span><br><span class="line">    Semaphore    m_ThreadSemaphore;  <span class="comment">//the inner semaphore, which is used to realize </span></span><br><span class="line">    <span class="keyword">unsigned</span>     <span class="keyword">long</span> m_ThreadID;   </span><br><span class="line">    <span class="keyword">bool</span>         m_Detach;       <span class="comment">//The thread is detached </span></span><br><span class="line">    <span class="keyword">bool</span>         m_CreateSuspended;  <span class="comment">//if suspend after creating </span></span><br><span class="line">    <span class="keyword">char</span>*        m_ThreadName; </span><br><span class="line">    ThreadState m_ThreadState;      <span class="comment">//the state of the thread </span></span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetErrcode</span><span class="params">(<span class="keyword">int</span> errcode)</span></span>&#123;m_ErrCode = errcode;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">ThreadFunction</span><span class="params">(<span class="keyword">void</span>*)</span></span>; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CThread(); </span><br><span class="line">    CThread(<span class="keyword">bool</span> createsuspended,<span class="keyword">bool</span> detach); </span><br><span class="line">    <span class="keyword">virtual</span> ~CThread(); </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">(<span class="keyword">void</span>)</span> </span>= <span class="number">0</span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetThreadState</span><span class="params">(ThreadState state)</span></span>&#123;m_ThreadState = state;&#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">Terminate</span><span class="params">(<span class="keyword">void</span>)</span></span>;    <span class="comment">//Terminate the threa </span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">Start</span><span class="params">(<span class="keyword">void</span>)</span></span>;        <span class="comment">//Start to execute the thread </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">Exit</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">Wakeup</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">   </span><br><span class="line">    <span class="function">ThreadState  <span class="title">GetThreadState</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_ThreadState;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">GetLastError</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_ErrCode;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetThreadName</span><span class="params">(<span class="keyword">char</span>* thrname)</span></span>&#123;<span class="built_in">strcpy</span>(m_ThreadName,thrname);&#125; </span><br><span class="line">    <span class="function"><span class="keyword">char</span>*    <span class="title">GetThreadName</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_ThreadName;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">GetThreadID</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_ThreadID;&#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">SetPriority</span><span class="params">(<span class="keyword">int</span> priority)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">GetPriority</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">GetConcurrency</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetConcurrency</span><span class="params">(<span class="keyword">int</span> num)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">Detach</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">Join</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">bool</span>     <span class="title">Yield</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">Self</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>线程的状态可以分为四种，空闲、忙碌、挂起、终止(包括正常退出和非正常退出)。由于目前Linux线程库不支持挂起操作，因此，我们的此处的挂起操作类似于暂停。如果线程创建后不想立即执行任务，那么我们可以将其“暂停”，如果需要运行，则唤醒。有一点必须注意的是，一旦线程开始执行任务，将不能被挂起，其将一直执行任务至完毕。<br>线程类的相关操作均十分简单。线程的执行入口是从Start()函数开始，其将调用函数ThreadFunction，ThreadFunction再调用实际的Run函数，执行实际的任务。 </p>
<h4 id="CThreadPool"><a href="#CThreadPool" class="headerlink" title="CThreadPool"></a>CThreadPool</h4><p>CThreadPool是线程的承载容器，一般可以将其实现为堆栈、单向队列或者双向队列。在我们的系统中我们使用STL Vector对线程进行保存。CThreadPool的实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CThreadPool</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CWorkerThread</span>;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_MaxNum;   <span class="comment">//the max thread num that can create at the same time </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_AvailLow; <span class="comment">//The min num of idle thread that shoule kept </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_AvailHigh;    <span class="comment">//The max num of idle thread that kept at the same time </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_AvailNum; <span class="comment">//the normal thread num of idle num; </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_InitNum;  <span class="comment">//Normal thread num; </span></span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">    <span class="function">CWorkerThread* <span class="title">GetIdleThread</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">AppendToIdleList</span><span class="params">(CWorkerThread* jobthread)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">MoveToBusyList</span><span class="params">(CWorkerThread* idlethread)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">MoveToIdleList</span><span class="params">(CWorkerThread* busythread)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">DeleteIdleThread</span><span class="params">(<span class="keyword">int</span> num)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">CreateIdleThread</span><span class="params">(<span class="keyword">int</span> num)</span></span>; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CThreadMutex m_BusyMutex;    <span class="comment">//when visit busy list,use m_BusyMutex to lock and unlock </span></span><br><span class="line">    CThreadMutex m_IdleMutex;    <span class="comment">//when visit idle list,use m_IdleMutex to lock and unlock </span></span><br><span class="line">    CThreadMutex m_JobMutex; <span class="comment">//when visit job list,use m_JobMutex to lock and unlock </span></span><br><span class="line">    CThreadMutex m_VarMutex; </span><br><span class="line"></span><br><span class="line">    CCondition       m_BusyCond; <span class="comment">//m_BusyCond is used to sync busy thread list </span></span><br><span class="line">    CCondition       m_IdleCond; <span class="comment">//m_IdleCond is used to sync idle thread list </span></span><br><span class="line">    CCondition       m_IdleJobCond;  <span class="comment">//m_JobCond is used to sync job list </span></span><br><span class="line">    CCondition       m_MaxNumCond; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;CWorkerThread*&gt;   m_ThreadList; </span><br><span class="line">    <span class="built_in">vector</span>&lt;CWorkerThread*&gt;   m_BusyList;     <span class="comment">//Thread List </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;CWorkerThread*&gt;   m_IdleList; <span class="comment">//Idle List </span></span><br><span class="line"></span><br><span class="line">    CThreadPool(); </span><br><span class="line">    CThreadPool(<span class="keyword">int</span> initnum); </span><br><span class="line">    <span class="keyword">virtual</span> ~CThreadPool(); </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">SetMaxNum</span><span class="params">(<span class="keyword">int</span> maxnum)</span></span>&#123;m_MaxNum = maxnum;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetMaxNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_MaxNum;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">SetAvailLowNum</span><span class="params">(<span class="keyword">int</span> minnum)</span></span>&#123;m_AvailLow = minnum;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetAvailLowNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_AvailLow;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">SetAvailHighNum</span><span class="params">(<span class="keyword">int</span> highnum)</span></span>&#123;m_AvailHigh = highnum;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetAvailHighNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_AvailHigh;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetActualAvailNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_AvailNum;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetAllNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_ThreadList.size();&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetBusyNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_BusyList.size();&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">SetInitNum</span><span class="params">(<span class="keyword">int</span> initnum)</span></span>&#123;m_InitNum = initnum;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">GetInitNum</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_InitNum;&#125; </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">TerminateAll</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">Run</span><span class="params">(CJob* job,<span class="keyword">void</span>* jobdata)</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line">CThreadPool::CThreadPool() </span><br><span class="line">&#123; </span><br><span class="line">    m_MaxNum = <span class="number">50</span>; </span><br><span class="line">    m_AvailLow = <span class="number">5</span>; </span><br><span class="line">    m_InitNum=m_AvailNum = <span class="number">10</span> ;  </span><br><span class="line">    m_AvailHigh = <span class="number">20</span>; </span><br><span class="line"></span><br><span class="line">    m_BusyList.clear(); </span><br><span class="line">    m_IdleList.clear(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m_InitNum;i++)&#123; </span><br><span class="line">    CWorkerThread* thr = <span class="keyword">new</span> CWorkerThread(); </span><br><span class="line">    thr-&gt;SetThreadPool(<span class="keyword">this</span>); </span><br><span class="line">    AppendToIdleList(thr); </span><br><span class="line">    thr-&gt;Start(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">CThreadPool::CThreadPool(<span class="keyword">int</span> initnum) </span><br><span class="line">&#123; </span><br><span class="line">    assert(initnum&gt;<span class="number">0</span> &amp;&amp; initnum&lt;=<span class="number">30</span>); </span><br><span class="line">    m_MaxNum   = <span class="number">30</span>; </span><br><span class="line">    m_AvailLow = initnum<span class="number">-10</span>&gt;<span class="number">0</span>?initnum<span class="number">-10</span>:<span class="number">3</span>; </span><br><span class="line">    m_InitNum=m_AvailNum = initnum ;  </span><br><span class="line">    m_AvailHigh = initnum+<span class="number">10</span>; </span><br><span class="line"></span><br><span class="line">    m_BusyList.clear(); </span><br><span class="line">    m_IdleList.clear(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m_InitNum;i++)&#123; </span><br><span class="line">    CWorkerThread* thr = <span class="keyword">new</span> CWorkerThread(); </span><br><span class="line">    AppendToIdleList(thr); </span><br><span class="line">    thr-&gt;SetThreadPool(<span class="keyword">this</span>); </span><br><span class="line">    thr-&gt;Start();       <span class="comment">//begin the thread,the thread wait for job </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">CThreadPool::~CThreadPool() </span><br><span class="line">&#123; </span><br><span class="line">   TerminateAll(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CThreadPool::TerminateAll() </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; m_ThreadList.size();i++) &#123; </span><br><span class="line">    CWorkerThread* thr = m_ThreadList[i]; </span><br><span class="line">    thr-&gt;Join(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">CWorkerThread* CThreadPool::GetIdleThread(<span class="keyword">void</span>) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">while</span>(m_IdleList.size() ==<span class="number">0</span> ) </span><br><span class="line">    m_IdleCond.Wait(); </span><br><span class="line">   </span><br><span class="line">    m_IdleMutex.Lock(); </span><br><span class="line">    <span class="keyword">if</span>(m_IdleList.size() &gt; <span class="number">0</span> ) </span><br><span class="line">    &#123; </span><br><span class="line">    CWorkerThread* thr = (CWorkerThread*)m_IdleList.front(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Get Idle thread %dn"</span>,thr-&gt;GetThreadID()); </span><br><span class="line">    m_IdleMutex.Unlock(); </span><br><span class="line">    <span class="keyword">return</span> thr; </span><br><span class="line">    &#125; </span><br><span class="line">    m_IdleMutex.Unlock(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//add an idle thread to idle list </span></span><br><span class="line"><span class="keyword">void</span> CThreadPool::AppendToIdleList(CWorkerThread* jobthread) </span><br><span class="line">&#123; </span><br><span class="line">    m_IdleMutex.Lock(); </span><br><span class="line">    m_IdleList.push_back(jobthread); </span><br><span class="line">    m_ThreadList.push_back(jobthread); </span><br><span class="line">    m_IdleMutex.Unlock(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//move and idle thread to busy thread </span></span><br><span class="line"><span class="keyword">void</span> CThreadPool::MoveToBusyList(CWorkerThread* idlethread) </span><br><span class="line">&#123; </span><br><span class="line">    m_BusyMutex.Lock(); </span><br><span class="line">    m_BusyList.push_back(idlethread); </span><br><span class="line">    m_AvailNum--; </span><br><span class="line">    m_BusyMutex.Unlock(); </span><br><span class="line">  </span><br><span class="line">    m_IdleMutex.Lock(); </span><br><span class="line">    <span class="built_in">vector</span>&lt;CWorkerThread*&gt;::iterator pos; </span><br><span class="line">    pos = find(m_IdleList.begin(),m_IdleList.end(),idlethread); </span><br><span class="line">    <span class="keyword">if</span>(pos !=m_IdleList.end()) </span><br><span class="line">    m_IdleList.erase(pos); </span><br><span class="line">    m_IdleMutex.Unlock(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CThreadPool::MoveToIdleList(CWorkerThread* busythread) </span><br><span class="line">&#123; </span><br><span class="line">    m_IdleMutex.Lock(); </span><br><span class="line">    m_IdleList.push_back(busythread); </span><br><span class="line">    m_AvailNum++; </span><br><span class="line">    m_IdleMutex.Unlock(); </span><br><span class="line"></span><br><span class="line">    m_BusyMutex.Lock(); </span><br><span class="line">    <span class="built_in">vector</span>&lt;CWorkerThread*&gt;::iterator pos; </span><br><span class="line">    pos = find(m_BusyList.begin(),m_BusyList.end(),busythread); </span><br><span class="line">    <span class="keyword">if</span>(pos!=m_BusyList.end()) </span><br><span class="line">    m_BusyList.erase(pos); </span><br><span class="line">    m_BusyMutex.Unlock(); </span><br><span class="line"></span><br><span class="line">    m_IdleCond.Signal(); </span><br><span class="line">    m_MaxNumCond.Signal(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//create num idle thread and put them to idlelist </span></span><br><span class="line"><span class="keyword">void</span> CThreadPool::CreateIdleThread(<span class="keyword">int</span> num) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123; </span><br><span class="line">    CWorkerThread* thr = <span class="keyword">new</span> CWorkerThread(); </span><br><span class="line">    thr-&gt;SetThreadPool(<span class="keyword">this</span>); </span><br><span class="line">    AppendToIdleList(thr); </span><br><span class="line">    m_VarMutex.Lock(); </span><br><span class="line">    m_AvailNum++; </span><br><span class="line">    m_VarMutex.Unlock(); </span><br><span class="line">    thr-&gt;Start();       <span class="comment">//begin the thread,the thread wait for job </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CThreadPool::DeleteIdleThread(<span class="keyword">int</span> num) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter into CThreadPool::DeleteIdleThreadn"</span>); </span><br><span class="line">    m_IdleMutex.Lock(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Delete Num is %dn"</span>,num); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123; </span><br><span class="line">    CWorkerThread* thr; </span><br><span class="line">    <span class="keyword">if</span>(m_IdleList.size() &gt; <span class="number">0</span> )&#123; </span><br><span class="line">            thr = (CWorkerThread*)m_IdleList.front(); </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Get Idle thread %dn"</span>,thr-&gt;GetThreadID()); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;CWorkerThread*&gt;::iterator pos; </span><br><span class="line">    pos = find(m_IdleList.begin(),m_IdleList.end(),thr); </span><br><span class="line">    <span class="keyword">if</span>(pos!=m_IdleList.end()) </span><br><span class="line">        m_IdleList.erase(pos); </span><br><span class="line">    m_AvailNum--; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The idle thread available num:%d n"</span>,m_AvailNum); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The idlelist              num:%d n"</span>,m_IdleList.size()); </span><br><span class="line">    &#125; </span><br><span class="line">    m_IdleMutex.Unlock(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CThreadPool::Run(CJob* job,<span class="keyword">void</span>* jobdata) </span><br><span class="line">&#123; </span><br><span class="line">    assert(job!=<span class="literal">NULL</span>); </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//if the busy thread num adds to m_MaxNum,so we should wait </span></span><br><span class="line">    <span class="keyword">if</span>(GetBusyNum() == m_MaxNum) </span><br><span class="line">        m_MaxNumCond.Wait(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m_IdleList.size()&lt;m_AvailLow) </span><br><span class="line">    &#123; </span><br><span class="line">    <span class="keyword">if</span>(GetAllNum()+m_InitNum-m_IdleList.size() &lt; m_MaxNum ) </span><br><span class="line">        CreateIdleThread(m_InitNum-m_IdleList.size()); </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        CreateIdleThread(m_MaxNum-GetAllNum()); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    CWorkerThread*  idlethr = GetIdleThread(); </span><br><span class="line">    <span class="keyword">if</span>(idlethr !=<span class="literal">NULL</span>) </span><br><span class="line">    &#123; </span><br><span class="line">    idlethr-&gt;m_WorkMutex.Lock(); </span><br><span class="line">    MoveToBusyList(idlethr); </span><br><span class="line">    idlethr-&gt;SetThreadPool(<span class="keyword">this</span>); </span><br><span class="line">    job-&gt;SetWorkThread(idlethr); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Job is set to thread %d n"</span>,idlethr-&gt;GetThreadID()); </span><br><span class="line">    idlethr-&gt;SetJob(job,jobdata); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在CThreadPool中存在两个链表，一个是空闲链表，一个是忙碌链表。Idle链表中存放所有的空闲进程，当线程执行任务时候，其状态变为忙碌状态，同时从空闲链表中删除，并移至忙碌链表中。在CThreadPool的构造函数中，我们将执行下面的代码: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m_InitNum;i++) </span><br><span class="line">&#123; </span><br><span class="line">    CWorkerThread* thr = <span class="keyword">new</span> CWorkerThread(); </span><br><span class="line">    AppendToIdleList(thr); </span><br><span class="line">    thr-&gt;SetThreadPool(<span class="keyword">this</span>); </span><br><span class="line">    thr-&gt;Start();       <span class="comment">//begin the thread,the thread wait for job </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该代码中，我们将创建m_InitNum个线程，创建之后即调用AppendToIdleList放入Idle链表中，由于目前没有任务分发给这些线程，因此线程执行Start后将自己挂起。<br>事实上，线程池中容纳的线程数目并不是一成不变的，其会根据执行负载进行自动伸缩。为此在CThreadPool中设定四个变量：<br>m_InitNum：处世创建时线程池中的线程的个数。<br>m_MaxNum:当前线程池中所允许并发存在的线程的最大数目。<br>m_AvailLow:当前线程池中所允许存在的空闲线程的最小数目，如果空闲数目低于该值，表明负载可能过重，此时有必要增加空闲线程池的数目。实现中我们总是将线程调整为m_InitNum个。<br>m_AvailHigh：当前线程池中所允许的空闲的线程的最大数目，如果空闲数目高于该值，表明当前负载可能较轻，此时将删除多余的空闲线程，删除后调整数也为m_InitNum个。<br>m_AvailNum：目前线程池中实际存在的线程的个数，其值介于m_AvailHigh和m_AvailLow之间。如果线程的个数始终维持在m_AvailLow和m_AvailHigh之间，则线程既不需要创建，也不需要删除，保持平衡状态。因此如何设定m_AvailLow和m_AvailHigh的值，使得线程池最大可能的保持平衡态，是线程池设计必须考虑的问题。<br>线程池在接受到新的任务之后，线程池首先要检查是否有足够的空闲池可用。检查分为三个步骤：<br>      (1)检查当前处于忙碌状态的线程是否达到了设定的最大值m_MaxNum，如果达到了，表明目前没有空闲线程可用，而且也不能创建新的线程，因此必须等待直到有线程执行完毕返回到空闲队列中。<br>      (2)如果当前的空闲线程数目小于我们设定的最小的空闲数目m_AvailLow，则我们必须创建新的线程，默认情况下，创建后的线程数目应该为m_InitNum，因此创建的线程数目应该为( 当前空闲线程数与m_InitNum);但是有一种特殊情况必须考虑，就是现有的线程总数加上创建后的线程数可能超过m_MaxNum，因此我们必须对线程的创建区别对待。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(GetAllNum()+m_InitNum-m_IdleList.size() &lt; m_MaxNum ) </span><br><span class="line">         CreateIdleThread(m_InitNum-m_IdleList.size()); </span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">         CreateIdleThread(m_MaxNum-GetAllNum());</span><br></pre></td></tr></table></figure>
<p>如果创建后总数不超过m_MaxNum，则创建后的线程为m_InitNum；如果超过了，则只创建( m_MaxNum-当前线程总数 )个。<br>      (3)调用GetIdleThread方法查找空闲线程。如果当前没有空闲线程，则挂起；否则将任务指派给该线程，同时将其移入忙碌队列。<br>当线程执行完毕后，其会调用MoveToIdleList方法移入空闲链表中，其中还调用m_IdleCond.Signal()方法，唤醒GetIdleThread()中可能阻塞的线程。 </p>
<h4 id="CWorkerThread"><a href="#CWorkerThread" class="headerlink" title="CWorkerThread"></a>CWorkerThread</h4><p>CWorkerThread是CThread的派生类，是事实上的工作线程。在CThreadPool的构造函数中，我们创建了一定数量的CWorkerThread。一旦这些线程创建完毕，我们将调用Start()启动该线程。Start方法最终会调用Run方法。Run方法是个无限循环的过程。在没有接受到实际的任务的时候，m_Job为NULL，此时线程将调用Wait方法进行等待，从而处于挂起状态。一旦线程池将具体的任务分发给该线程，其将被唤醒，从而通知线程从挂起的地方继续执行。CWorkerThread的完整定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CWorkerThread</span>:</span><span class="keyword">public</span> CThread </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    CThreadPool*  m_ThreadPool; </span><br><span class="line">    CJob*    m_Job; </span><br><span class="line">    <span class="keyword">void</span>*    m_JobData; </span><br><span class="line">   </span><br><span class="line">    CThreadMutex m_VarMutex; </span><br><span class="line">    <span class="keyword">bool</span>      m_IsEnd; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CCondition   m_JobCond; </span><br><span class="line">    CThreadMutex m_WorkMutex; </span><br><span class="line">    CWorkerThread(); </span><br><span class="line">    <span class="keyword">virtual</span> ~CWorkerThread(); </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">SetJob</span><span class="params">(CJob* job,<span class="keyword">void</span>* jobdata)</span></span>; </span><br><span class="line">    <span class="function">CJob*   <span class="title">GetJob</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_Job;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">SetThreadPool</span><span class="params">(CThreadPool* thrpool)</span></span>; </span><br><span class="line">    <span class="function">CThreadPool* <span class="title">GetThreadPool</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> m_ThreadPool;&#125; </span><br><span class="line">&#125;; </span><br><span class="line">CWorkerThread::CWorkerThread() </span><br><span class="line">&#123; </span><br><span class="line">    m_Job = <span class="literal">NULL</span>; </span><br><span class="line">    m_JobData = <span class="literal">NULL</span>; </span><br><span class="line">    m_ThreadPool = <span class="literal">NULL</span>; </span><br><span class="line">    m_IsEnd = <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line">CWorkerThread::~CWorkerThread() </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != m_Job) </span><br><span class="line">    <span class="keyword">delete</span> m_Job; </span><br><span class="line">    <span class="keyword">if</span>(m_ThreadPool != <span class="literal">NULL</span>) </span><br><span class="line">    <span class="keyword">delete</span> m_ThreadPool; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CWorkerThread::Run() </span><br><span class="line">&#123; </span><br><span class="line">    SetThreadState(THREAD_RUNNING); </span><br><span class="line">    <span class="keyword">for</span>(;;) </span><br><span class="line">    &#123; </span><br><span class="line">    <span class="keyword">while</span>(m_Job == <span class="literal">NULL</span>) </span><br><span class="line">        m_JobCond.Wait(); </span><br><span class="line"></span><br><span class="line">    m_Job-&gt;Run(m_JobData); </span><br><span class="line">    m_Job-&gt;SetWorkThread(<span class="literal">NULL</span>); </span><br><span class="line">    m_Job = <span class="literal">NULL</span>; </span><br><span class="line">    m_ThreadPool-&gt;MoveToIdleList(<span class="keyword">this</span>); </span><br><span class="line">    <span class="keyword">if</span>(m_ThreadPool-&gt;m_IdleList.size() &gt; m_ThreadPool-&gt;GetAvailHighNum()) </span><br><span class="line">    &#123; </span><br><span class="line">m_ThreadPool-&gt;DeleteIdleThread(m_ThreadPool-&gt;m_IdleList.size()-m_T </span><br><span class="line">hreadPool-&gt;GetInitNum()); </span><br><span class="line">    &#125; </span><br><span class="line">    m_WorkMutex.Unlock(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CWorkerThread::SetJob(CJob* job,<span class="keyword">void</span>* jobdata) </span><br><span class="line">&#123; </span><br><span class="line">    m_VarMutex.Lock(); </span><br><span class="line">    m_Job = job; </span><br><span class="line">    m_JobData = jobdata; </span><br><span class="line">    job-&gt;SetWorkThread(<span class="keyword">this</span>); </span><br><span class="line">    m_VarMutex.Unlock(); </span><br><span class="line">    m_JobCond.Signal(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CWorkerThread::SetThreadPool(CThreadPool* thrpool) </span><br><span class="line">&#123; </span><br><span class="line">    m_VarMutex.Lock(); </span><br><span class="line">    m_ThreadPool = thrpool; </span><br><span class="line">    m_VarMutex.Unlock(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当线程执行任务之前首先必须判断空闲线程的数目是否低于m_AvailLow，如果低于，则必须创建足够的空闲线程，使其数目达到m_InitNum个，然后将调用MoveToBusyList()移出空闲队列，移入忙碌队列。当任务执行完毕后，其又调用MoveToIdleList()移出忙碌队列，移入空闲队列，等待新的任务。<br>      除了Run方法之外，CWorkerThread中另外一个重要的方法就是SetJob，该方法将实际的任务赋值给线程。当没有任何执行任务即m_Job为NULL的时候，线程将调用m_JobCond.Wait进行等待。一旦Job被赋值给线程，其将调用m_JobCond.Signal方法唤醒该线程。由于m_JobCond属于线程内部的变量，每个线程都维持一个m_JobCond，只有得到任务的线程才被唤醒，没有得到任务的将继续等待。无论一个线程何时被唤醒，其都将从等待的地方继续执行m_Job-&gt;Run(m_JobData)，这是线程执行实际任务的地方。<br>      在线程执行给定Job期间，我们必须防止另外一个Job又赋给该线程，因此在赋值之前，通过m_VarMutex进行锁定， Job执行期间，其于的Job将不能关联到该线程；任务执行完毕，我们调用m_VarMutex.Unlock()进行解锁，此时，线程又可以接受新的执行任务。<br>在线程执行任务结束后返回空闲队列前，我们还需要判断当前空闲队列中的线程是否高于m_AvailHigh个。如果超过m_AvailHigh，则必须从其中删除(m_ThreadPool-&gt;m_IdleList.size()-m_ThreadPool-&gt;GetInitNum())个线程，使线程数目保持在m_InitNum个。 </p>
<h4 id="CJob"><a href="#CJob" class="headerlink" title="CJob"></a>CJob</h4><p>CJob类相对简单，其封装了任务的基本的属性和方法，其中最重要的是Run方法，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CJob</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span>      m_JobNo;        <span class="comment">//The num was assigned to the job </span></span><br><span class="line">    <span class="keyword">char</span>*    m_JobName;      <span class="comment">//The job name </span></span><br><span class="line">    CThread  *m_pWorkThread;     <span class="comment">//The thread associated with the job </span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CJob( <span class="keyword">void</span> ); </span><br><span class="line">    <span class="keyword">virtual</span> ~CJob(); </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">int</span>      <span class="title">GetJobNo</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_JobNo; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetJobNo</span><span class="params">(<span class="keyword">int</span> jobno)</span></span>&#123; m_JobNo = jobno;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">char</span>*    <span class="title">GetJobName</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_JobName; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetJobName</span><span class="params">(<span class="keyword">char</span>* jobname)</span></span>; </span><br><span class="line">    <span class="function">CThread *<span class="title">GetWorkThread</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="keyword">return</span> m_pWorkThread; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span>     <span class="title">SetWorkThread</span> <span class="params">( CThread *pWorkThread )</span></span>&#123; </span><br><span class="line">        m_pWorkThread = pWorkThread; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Run</span> <span class="params">( <span class="keyword">void</span> *ptr )</span> </span>= <span class="number">0</span>; </span><br><span class="line">&#125;; </span><br><span class="line">CJob::CJob(<span class="keyword">void</span>) </span><br><span class="line">:m_pWorkThread(<span class="literal">NULL</span>) </span><br><span class="line">,m_JobNo(<span class="number">0</span>) </span><br><span class="line">,m_JobName(<span class="literal">NULL</span>) </span><br><span class="line">&#123; </span><br><span class="line">&#125; </span><br><span class="line">CJob::~CJob()&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != m_JobName) </span><br><span class="line">    <span class="built_in">free</span>(m_JobName); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> CJob::SetJobName(<span class="keyword">char</span>* jobname) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> !=m_JobName)    &#123; </span><br><span class="line">        <span class="built_in">free</span>(m_JobName); </span><br><span class="line">        m_JobName = <span class="literal">NULL</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> !=jobname)    &#123; </span><br><span class="line">        m_JobName = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(jobname)+<span class="number">1</span>); </span><br><span class="line">        <span class="built_in">strcpy</span>(m_JobName,jobname); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池使用示例"><a href="#线程池使用示例" class="headerlink" title="线程池使用示例"></a>线程池使用示例</h3><p>至此我们给出了一个简单的与具体任务无关的线程池框架。使用该框架非常的简单，我们所需要的做的就是派生CJob类，将需要完成的任务实现在Run方法中。然后将该Job交由CThreadManage去执行。下面我们给出一个简单的示例程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CXJob</span>:</span><span class="keyword">public</span> CJob </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CXJob()&#123;i=<span class="number">0</span>;&#125; </span><br><span class="line">    ~CXJob()&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(<span class="keyword">void</span>* jobdata)</span>    </span>&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The Job comes from CXJOB\n"</span>); </span><br><span class="line">        sleep(<span class="number">2</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CYJob</span>:</span><span class="keyword">public</span> CJob </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CYJob()&#123;i=<span class="number">0</span>;&#125; </span><br><span class="line">    ~CYJob()&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(<span class="keyword">void</span>* jobdata)</span>    </span>&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The Job comes from CYJob\n"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">main() </span><br><span class="line">&#123; </span><br><span class="line">    CThreadManage* manage = <span class="keyword">new</span> CThreadManage(<span class="number">10</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++) </span><br><span class="line">    &#123; </span><br><span class="line">        CXJob*   job = <span class="keyword">new</span> CXJob(); </span><br><span class="line">        manage-&gt;Run(job,<span class="literal">NULL</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    sleep(<span class="number">2</span>); </span><br><span class="line">    CYJob* job = <span class="keyword">new</span> CYJob(); </span><br><span class="line">    manage-&gt;Run(job,<span class="literal">NULL</span>); </span><br><span class="line">    manage-&gt;TerminateAll(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CXJob和CYJob都是从Job类继承而来，其都实现了Run接口。CXJob只是简单的打印一句”The Job comes from CXJob”，CYJob也只打印”The Job comes from CYJob”，然后均休眠2秒钟。在主程序中我们初始创建10个工作线程。然后分别执行40次CXJob和一次CYJob。</p>
<h2 id="C-11线程池"><a href="#C-11线程池" class="headerlink" title="C++11线程池"></a>C++11线程池</h2><p>100行代码，源自 <a href="https://github.com/progschj/ThreadPool" target="_blank" rel="noopener">GitHub</a> .这个线程池的任务要用future获取返回值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadPool.h c++11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ThreadPool(<span class="keyword">size_t</span>);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">auto</span> <span class="title">enqueue</span>(<span class="title">F</span>&amp;&amp; <span class="title">f</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>)</span></span><br><span class="line"><span class="class">        -&gt; <span class="title">std</span>:</span>:future&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;F(Args...)&gt;::type&gt;;</span><br><span class="line">    ~ThreadPool();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// need to keep track of threads so we can join them</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::thread &gt; workers;</span><br><span class="line">    <span class="comment">// the task queue</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt; <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; &gt; tasks;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// synchronization</span></span><br><span class="line">    <span class="built_in">std</span>::mutex queue_mutex;</span><br><span class="line">    <span class="built_in">std</span>::condition_variable condition;</span><br><span class="line">    <span class="keyword">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the constructor just launches some amount of workers</span></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::ThreadPool(<span class="keyword">size_t</span> threads)</span><br><span class="line">    :   stop(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i&lt;threads;++i)</span><br><span class="line">        workers.emplace_back(</span><br><span class="line">            [<span class="keyword">this</span>]</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(;;)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; task;</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">                        <span class="keyword">this</span>-&gt;condition.wait(lock,</span><br><span class="line">                            [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.empty(); &#125;);</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.empty())</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        task = <span class="built_in">std</span>::move(<span class="keyword">this</span>-&gt;tasks.front());</span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks.pop();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    task();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add new work item to the pool</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">auto</span> <span class="title">ThreadPool</span>:</span>:enqueue(F&amp;&amp; f, Args&amp;&amp;... args) </span><br><span class="line">    -&gt; <span class="built_in">std</span>::future&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;F(Args...)&gt;::type&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> return_type = <span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;F(Args...)&gt;::type;</span><br><span class="line">    <span class="comment">//return_type是函数返回值，return_type()就可以作为packaged_task的模板参数</span></span><br><span class="line">    </span><br><span class="line">		<span class="comment">//packaged_task可以用bind构造，比如：packaged_task task(bind(f,1));</span></span><br><span class="line">		<span class="comment">//make_shared将函数参数构造为模板类型，并指向构造后的对象。</span></span><br><span class="line">		<span class="comment">//使用shared_ptr的原因是下面lambda表达式将这个task指针传入了tasks队列的Function对象，值传递引用计数+1，等任务被执行后，task才被析构。</span></span><br><span class="line">    <span class="keyword">auto</span> task = <span class="built_in">std</span>::make_shared&lt; <span class="built_in">std</span>::packaged_task&lt;return_type()&gt; &gt;(</span><br><span class="line">            <span class="built_in">std</span>::bind(<span class="built_in">std</span>::forward&lt;F&gt;(f), <span class="built_in">std</span>::forward&lt;Args&gt;(args)...)</span><br><span class="line">        );</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::future&lt;return_type&gt; res = task-&gt;get_future();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(queue_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don't allow enqueueing after stopping the pool</span></span><br><span class="line">        <span class="keyword">if</span>(stop)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"enqueue on stopped ThreadPool"</span>);</span><br><span class="line"></span><br><span class="line">        tasks.emplace([task]()&#123; (*task)(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    condition.notify_one();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the destructor joins all threads</span></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::~ThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(queue_mutex);</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    condition.notify_all();</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::thread &amp;worker: workers)</span><br><span class="line">        worker.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ThreadPool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; &gt; results;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        results.emplace_back(</span><br><span class="line">            pool.enqueue([i] &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"world "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> i*i;</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;&amp; result: results)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2019 Skuaka
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 1;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>