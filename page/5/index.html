<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="Skuaka">


    
    


<meta name="description" content="For you, a thousand times over.">
<meta name="keywords" content="skuaka">
<meta property="og:type" content="website">
<meta property="og:title" content="Skuaka">
<meta property="og:url" content="http://skuaka.cn/page/5/index.html">
<meta property="og:site_name" content="Skuaka">
<meta property="og:description" content="For you, a thousand times over.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Skuaka">
<meta name="twitter:description" content="For you, a thousand times over.">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Skuaka" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/avatar.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Skuaka</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Skuaka</a></h1>
        </hgroup>

        
        <p class="header-subtitle">For you, a thousand times over.</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">Home</a></li>
                        
                            <li><a href="/archives/">Archives</a></li>
                        
                            <li><a href="/tags/">Tags</a></li>
                        
                            <li><a href="/about/">about</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCIE/">CCIE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DDos/">DDos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DTD/">DTD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DoNotStarve/">DoNotStarve</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dreamweaver/">Dreamweaver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kali/">Kali</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Macos/">Macos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MetaProgram/">MetaProgram</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mp3/">Mp3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenGL/">OpenGL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Perl/">Perl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QT/">QT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Raspberrypi/">Raspberrypi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLserver/">SQLserver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Socks5/">Socks5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wifi/">Wifi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wireshark/">Wireshark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/base64/">base64</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/epoll/">epoll</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcc-gdb/">gcc,gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reactor/">reactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unp/">unp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vultr/">vultr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a></li></ul>
                    </div>
                </section>
                
                
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Skuaka</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Skuaka</a></h1>
            </hgroup>
            
            <p class="header-subtitle">For you, a thousand times over.</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">Home</a></li>
                
                    <li><a href="/archives/">Archives</a></li>
                
                    <li><a href="/tags/">Tags</a></li>
                
                    <li><a href="/about/">about</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" target="_blank" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me">
</nav>
      <div class="body-wrap">
  
    <article id="post-Unix/Command/ln" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/02/01/Unix/Command/ln/" class="article-date">
      <time datetime="2019-02-01T10:19:22.000Z" itemprop="datePublished">2019-02-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/01/Unix/Command/ln/">ln</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>ln -s 源文件 目标文件 </p>
<p>举例：</p>
<p>当前目录是<code>/local</code>，而我经常要访问<code>/usr/local/linux/work</code></p>
<p>那么我就可以使用在 local 下建立一个文件 linkwork，</p>
<p>然后<code>ln -s /usr/local/linux/work  /local/linkwork</code></p>
<p>即建立两者之间的链接。</p>
<p>删除链接 </p>
<p><code>rm -rf   symbolic_name</code>   注意不是  <code>rm -rf   symbolic_name/</code></p>
<p>那么上面就是</p>
<p><code>rm -rf   /local/linkwork</code></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Shell/">Shell</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Unix/Command/screen" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/02/01/Unix/Command/screen/" class="article-date">
      <time datetime="2019-02-01T07:32:17.000Z" itemprop="datePublished">2019-02-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/01/Unix/Command/screen/">使用 screen 管理远程会话</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="使用-screen-管理远程会话"><a href="#使用-screen-管理远程会话" class="headerlink" title="使用 screen 管理远程会话"></a>使用 screen 管理远程会话</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>你是不是经常需要 SSH 或者 telent 远程登录到 Linux 服务器？你是不是经常为一些长时间运行的任务而头疼，比如系统备份、ftp 传输等等。通常情况下我们都是为每一个这样的任务开一个远程终端窗口，因为他们执行的时间太长了。必须等待它执行完毕，在此期间可不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。</p>
<h3 id="元凶就是-SIGHUP-信号"><a href="#元凶就是-SIGHUP-信号" class="headerlink" title="元凶就是 SIGHUP 信号"></a>元凶就是 SIGHUP 信号</h3><ul>
<li>当终端接口检测到网络连接断开，将挂断信号发送给控制进程（会话期首进程）。</li>
<li>如果会话期首进程终止，则该信号发送到该会话期前台进程组。</li>
<li>一个进程退出导致一个孤儿进程组中产生时，如果任意一个孤儿进程组进程处于STOP状态，发送SIGHUP和SIGCONT信号到该进程组中所有进程。</li>
</ul>
<p>因此当网络断开或终端窗口关闭后，控制进程收到SIGHUP信号退出，会导致该会话期内其他进程退出。</p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2019/02/01/Unix/Command/screen/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Mess/Game/DoNotStarve/饥荒联机控制台" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/02/01/Mess/Game/DoNotStarve/饥荒联机控制台/" class="article-date">
      <time datetime="2019-01-31T19:44:37.000Z" itemprop="datePublished">2019-02-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/01/Mess/Game/DoNotStarve/饥荒联机控制台/">饥荒联机控制台</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h3 id="饥荒联机控制台"><a href="#饥荒联机控制台" class="headerlink" title="饥荒联机控制台"></a>饥荒联机控制台</h3><p>当你为服务器管理员时，在游戏中按 <code>~</code> 呼出控制台，再按 <code>Ctrl</code> 键即可转换为 <code>Remote</code> 模式，会出现 <code>“Remote”</code> 字样。</p>
<p>你在重新加载世界后必须重新输入每一个命令。</p>
<h4 id="简单命令"><a href="#简单命令" class="headerlink" title="简单命令"></a>简单命令</h4><p>#####生成实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c_spawn(&quot;prefab&quot;,amount)</span><br></pre></td></tr></table></figure>
<p><em>在鼠标所指处生成一定数量被指定的”预设”。</em></p>
<p>#####获得物品</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c_give(&quot;prefab&quot;,amount)</span><br></pre></td></tr></table></figure>
<p><em>在你的物品栏中生成一定数量被指定的”预设”。只适用于可以被储存在物品栏的背包和物品 。</em></p>
<p>#####生命值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c_sethealth(percent)</span><br></pre></td></tr></table></figure>
<p><em>用百分比设置你的生命值。注：使用分数 0.90 = 90%</em></p>
<p>#####理智值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c_setsanity(percent)</span><br></pre></td></tr></table></figure>
<p><em>用百分比设置你的理智值。注：使用分数 0.90 = 90%</em></p>
<p>#####饥饿值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c_sethunger(percent)</span><br></pre></td></tr></table></figure>
<p><em>用百分比设置你的饥饿值。注：使用分数 0.90 = 90%</em></p>
<p>#####湿度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c_setmoisture(percent)</span><br></pre></td></tr></table></figure>
<p><em>用百分比设置你的湿度。注：使用分数 0.90 = 90%</em></p>
<p>#####温度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c_settemperature(degrees)</span><br></pre></td></tr></table></figure>
<p><em>用百分比设置你的温度。注：使用分数 0.90 = 90%</em></p>
<p>#####-上帝模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c_godmode()</span><br></pre></td></tr></table></figure>
<p><em>玩家的理智值、饥饿值和被攻击时生命值不再下降。上帝模式下，你不能用命令改变的你统计数据。如果处于死亡状态，将会复活你（通过 c_godmode() 复活后不会将你置于上帝模式）。再次使用命令停用上帝模式。</em></p>
<p>#####超级上帝模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c_supergodmode()</span><br></pre></td></tr></table></figure>
<p><em>和上帝模式一样但会将你的各项统计数据设置为满，即使你将它关闭。与c_godmode()相似,，它也会复活你（通过 c_supergodmode() 复活后不会将你置于上帝模式）。再次使用命令停用上帝模式。</em></p>
<p>#####-移动速度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c_speedmult(multiplier)</span><br></pre></td></tr></table></figure>
<p><em>标准额外的移动速度为 1。设置为 2 使你以两倍的速度移动，设置为 20 可以让你轻松地穿过墙和 “越过 “ 水。</em></p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Game/">Game</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DoNotStarve/">DoNotStarve</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2019/02/01/Mess/Game/DoNotStarve/饥荒联机控制台/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Mess/Game/DoNotStarve/饥荒Linux服务器" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/02/01/Mess/Game/DoNotStarve/饥荒Linux服务器/" class="article-date">
      <time datetime="2019-01-31T16:33:25.000Z" itemprop="datePublished">2019-02-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/01/Mess/Game/DoNotStarve/饥荒Linux服务器/">饥荒Linux服务器搭建</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h2 id="饥荒Linux服务器搭建"><a href="#饥荒Linux服务器搭建" class="headerlink" title="饥荒Linux服务器搭建"></a>饥荒Linux服务器搭建</h2><p>学习自：<a href="http://blog.ttionya.com/article-1233.html" target="_blank" rel="noopener">http://blog.ttionya.com/article-1233.html</a></p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Game/">Game</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DoNotStarve/">DoNotStarve</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2019/02/01/Mess/Game/DoNotStarve/饥荒Linux服务器/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Unix/Command/输出重定向" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/01/28/Unix/Command/输出重定向/" class="article-date">
      <time datetime="2019-01-28T10:29:44.000Z" itemprop="datePublished">2019-01-28</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/28/Unix/Command/输出重定向/">Linux 输出重定向</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><code>command&gt;/dev/null 2&gt;&amp;1</code></p>
<ul>
<li><p>不能颠倒顺序</p>
</li>
<li><p><strong>为什么1要加&amp;?</strong></p>
<p>如果不加&amp;，则把1当成是文件名。&amp;指示1是fd。</p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Shell/">Shell</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C_C++/模板和元编程/C++编译期备忘录" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/01/26/C_C++/模板和元编程/C++编译期备忘录/" class="article-date">
      <time datetime="2019-01-26T08:53:47.000Z" itemprop="datePublished">2019-01-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/26/C_C++/模板和元编程/C++编译期备忘录/">C++ 编译期 备忘录</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="静态断言-static-assert"><a href="#静态断言-static-assert" class="headerlink" title="静态断言 static_assert"></a>静态断言 static_assert</h3><p><strong>和assert类似</strong>。</p>
<p>C++11 中引入了<strong>static_assert</strong>这个关键字，用来做编译期间的断言，因此叫做静态断言。</p>
<p>语法：<code>static_assert(常量表达式，提示字符串)</code>。</p>
<p>如果第一个参数常量表达式的值为真(true或者非零值)，那么<strong>static_assert</strong>不做任何事情；否则会产生一条编译错误，错误位置就是该<strong>static_assert</strong>语句所在行，错误提示就是第二个参数提示字符串。</p>
<ul>
<li>如果该常量表达式依赖于某些模板参数，则延迟到模板实例化时再进行演算，这就让<strong>检查模板参数</strong>成为了可能。</li>
<li><strong>static_assert</strong>不会造成任何运行期性能损失。</li>
</ul>
<p>例子：判断类型是否正确</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">static_assert</span>(is_same&lt;<span class="keyword">int</span> <span class="keyword">const</span>, add_const&lt;<span class="keyword">int</span>&gt;&gt;(), <span class="string">""</span>);</span><br></pre></td></tr></table></figure>
<h3 id="类型选择-std-conditional"><a href="#类型选择-std-conditional" class="headerlink" title="类型选择 std::conditional"></a>类型选择 std::conditional</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Defined in header &lt;type_traits&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">bool</span> B, <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">F</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">conditional</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Possible implementation</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> B, <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">conditional</span> &#123;</span> <span class="keyword">typedef</span> T type; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">conditional</span>&lt;false, T, F&gt; &#123;</span> <span class="keyword">typedef</span> F type; &#125;;</span><br></pre></td></tr></table></figure>
<p>Provides member typedef <code>type</code>, which is defined as <code>T</code> if <code>B</code> is true at compile time, or as <code>F</code> if <code>B</code> is false.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MetaProgram/">MetaProgram</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C_C++/模板和元编程/C++typename用法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/01/25/C_C++/模板和元编程/C++typename用法/" class="article-date">
      <time datetime="2019-01-25T12:35:28.000Z" itemprop="datePublished">2019-01-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/25/C_C++/模板和元编程/C++typename用法/">C++ typename 用法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="typename"><a href="#typename" class="headerlink" title="typename"></a>typename</h2><ol>
<li><p>在C++中typename一般用来声明模板的模板参数(template parameter):<br><code>template&lt;typename T&gt; class X;</code>   //T是一个模板参数</p>
</li>
<li><p>但是还有一个关键的用法。首先是两个概念：</p>
<ol>
<li><p>qualified name 限定名<br>例如:std::cout, std::endl;这样含有作用域符号(::)的就是限定名，<br>当我们用using声明将cout,endl引入到当前作用域之后就可以直接使用<br>这两个名称，这个时候cout，endl就不是限定名了。</p>
</li>
<li><p>dependent name 依赖名<br>dependent name是依赖于模板参数的类型,例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">X</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">    </span><br><span class="line">    T type;</span><br><span class="line"> 	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; tvec;</span><br><span class="line">   	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;::iterator titer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 前3个成员变量是不依赖于模板参数,所以是non-dependent name;</span></span><br><span class="line"><span class="comment">   后3个是dependent name,直到实例化该模板的时候才会知道到底是什么类型。*/</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>下面来讨论typename的第二种用法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在假设我们有一个类如下：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Y</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T::iterator *iter;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 我们可能本意是想定义一个迭代器对象，例如我们如果用vector&lt;int&gt;来实例化这个模板，那么iter</span></span><br><span class="line"><span class="comment">则应该是一个迭代器指针，但是，如果我们用下面这个类来实例化这个模板：*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> iterator;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 那么T::iterator *iter 会被编译器解释为两个数相乘。事实上，C++编译器会采用第二种解释方法</span></span><br><span class="line"><span class="comment">，即使iterator的确是一个类型名。</span></span><br><span class="line"><span class="comment">为了避免这种矛盾，当我们适用qualified dependent name的时候，需要用typename来指出这是一个</span></span><br><span class="line"><span class="comment">类型名.即: */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Y</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> T::iterator *iter;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> T::iterator iterator; <span class="comment">//定义了Y::iterator类型名称</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//typename 指出下面紧跟着的名称是一个类型</span></span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MetaProgram/">MetaProgram</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C_C++/模板和元编程/C++模板元编程书上习题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/01/25/C_C++/模板和元编程/C++模板元编程书上习题/" class="article-date">
      <time datetime="2019-01-25T12:24:27.000Z" itemprop="datePublished">2019-01-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/25/C_C++/模板和元编程/C++模板元编程书上习题/">C++模板元编程书上习题（待续</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>chapter1</p>
<p>Q1</p>
<p>问题：要给非引用类型同时添加const和引用。</p>
<p>发现：我先添加引用再添加const时不成功，但是先添加const再添加引用则成功。</p>
<p>猜测：add_const会清除引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/type_traits/is_reference.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/type_traits/add_reference.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/type_traits/add_const.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果T是引用，就返回T；否则返回T const&amp;。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">bool</span> <span class="title">is_ref</span>&gt; <span class="title">struct</span> <span class="title">add_const_ref_impl</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">add_const_ref_impl</span>&lt;T, true&gt;&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">add_const_ref_impl</span>&lt;T, false&gt;&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::add_reference&lt;<span class="keyword">typename</span> boost::add_const&lt;T&gt;::type&gt;::type type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">add_const_ref</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> add_const_ref_impl&lt;T, boost::is_reference&lt;T&gt;::value&gt;::type type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"int&amp; / add_const_ref&lt;int&amp;&gt; : "</span> &lt;&lt;</span><br><span class="line">        boost::is_same&lt;<span class="keyword">int</span>&amp;, add_const_ref&lt;<span class="keyword">int</span>&amp;&gt;::type&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"std string const&amp; / add_const_ref&lt;std::string&gt; : "</span> &lt;&lt;</span><br><span class="line">        boost::is_same&lt;<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp;, add_const_ref&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::type&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MetaProgram/">MetaProgram</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C_C++/模板和元编程/C++模板元编程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/01/22/C_C++/模板和元编程/C++模板元编程/" class="article-date">
      <time datetime="2019-01-21T17:08:28.000Z" itemprop="datePublished">2019-01-22</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/22/C_C++/模板和元编程/C++模板元编程/">C++模板元编程(待续</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="今天刚开始学"><a href="#今天刚开始学" class="headerlink" title="今天刚开始学"></a>今天刚开始学</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>(为什么要用struct？因为struct默认访问权限是public，如果用class还要多写一行public)</p>
<h4 id="阶乘计算"><a href="#阶乘计算" class="headerlink" title="阶乘计算"></a>阶乘计算</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> n&gt; <span class="comment">// general case: the value of</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span> &#123;</span> <span class="comment">// Factorial&lt;n&gt; is n times the value</span></span><br><span class="line"><span class="comment">// of Factorial&lt;n-1&gt;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; value = n * Factorial&lt;n<span class="number">-1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">// special case: the value of</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span>&lt;0&gt; &#123;</span> <span class="comment">// Factorial&lt;0&gt; is 1</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二进制计算"><a href="#二进制计算" class="headerlink" title="二进制计算"></a>二进制计算</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Binary</span>&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value = Binary&lt;N/<span class="number">10</span>&gt;::value * <span class="number">2</span> + N % <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Binary</span>&lt;0&gt;&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="交换迭代器指向的内容"><a href="#交换迭代器指向的内容" class="headerlink" title="交换迭代器指向的内容"></a>交换迭代器指向的内容</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/type_traits/is_reference.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/type_traits/is_same.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt; // 针对iterator_traits</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // 针对swap</span></span></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">bool</span> use_swap&gt; <span class="class"><span class="keyword">struct</span> <span class="title">iter_swap_impl</span>;</span></span><br><span class="line">    <span class="comment">// 快速版本</span></span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iter_swap_impl</span>&lt;true&gt;&#123;</span></span><br><span class="line">    	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator1</span>, <span class="title">class</span> <span class="title">ForwardIterator2</span>&gt;</span></span><br><span class="line"><span class="class">    	<span class="title">static</span> <span class="title">void</span> <span class="title">do_it</span>(<span class="title">ForwardIterator1</span> <span class="title">i1</span>, <span class="title">ForwardIterator2</span> <span class="title">i2</span>)&#123;</span></span><br><span class="line">			<span class="built_in">std</span>::swap(*i1, *i2);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 总是可行的版本</span></span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">   	<span class="class"><span class="keyword">struct</span> <span class="title">iter_swap_impl</span>&lt;false&gt;&#123;</span></span><br><span class="line">       	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator1</span>, <span class="title">class</span> <span class="title">ForwardIterator2</span>&gt;</span></span><br><span class="line"><span class="class">       	<span class="title">static</span> <span class="title">void</span> <span class="title">do_it</span>(<span class="title">ForwardIterator1</span> <span class="title">i1</span>, <span class="title">ForwardIterator2</span> <span class="title">i2</span>)&#123;</span></span><br><span class="line">       		<span class="keyword">typename</span> iterator_traits&lt;ForwardIterator1&gt;::value_type</span><br><span class="line">            tmp = *i1;</span><br><span class="line">           	*i1 = *i2;</span><br><span class="line">          	*i2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator1</span>, <span class="title">class</span> <span class="title">ForwardIterator2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">iter_swap</span>(<span class="title">ForwardIterator1</span> <span class="title">i1</span>, <span class="title">ForwardIterator2</span> <span class="title">i2</span>)&#123;</span></span><br><span class="line">    	<span class="keyword">typedef</span> iterator_traits&lt;ForwardsIterator1&gt; traits1;</span><br><span class="line">    	<span class="keyword">typedef</span> <span class="keyword">typename</span> traits1::value_type v1;</span><br><span class="line">    	<span class="keyword">typedef</span> <span class="keyword">typename</span> traits1::reference r1;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">typedef</span> iterator_traits&lt;ForwardsIterator1&gt; traits2;</span><br><span class="line">    	<span class="keyword">typedef</span> <span class="keyword">typename</span> traits2::value_type v2;</span><br><span class="line">    	<span class="keyword">typedef</span> <span class="keyword">typename</span> traits2::reference r2; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">const</span> use_swap = boost::is_same&lt;v1,v2&gt;::value</span><br><span class="line">        						&amp;&amp; boost::isreference&lt;r1&gt;::value</span><br><span class="line">        						&amp;&amp; boost::isreference&lt;r2&gt;::value;</span><br><span class="line">		</span><br><span class="line">        iter_swap_impl&lt;use_swap&gt;::do_it(i1,i2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="blob"><a href="#blob" class="headerlink" title="blob"></a>blob</h3><p>在面向对象的编程中将一个带有大量成员的类称作”blob”。类的成员彼此耦合，因为它们必须被声明在一起。为了避免耦合并提高模块化的程度，应该避免使用这种模式。代替方案是采用独立的元函数来定义单独的traits。</p>
<h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>可被C++编译器系统操纵的”值”可以被认为是元数据。在模板元编程中，两种最常见的元数据是<strong>类型</strong>和<strong>整数常量</strong>(包括bool)。</p>
<p>C++的编译器部分通常被称为”纯函数式语言”，因为元数据是不可变的并且元函数不可以有任何副作用。</p>
<h3 id="静态-动态多态"><a href="#静态-动态多态" class="headerlink" title="静态/动态多态"></a>静态/动态多态</h3><p>动态多态</p>
<ul>
<li>允许我们通过单个基指针或引用处理多个派生类型的对象</li>
<li>实际类型决定于运行期</li>
<li>是面向对象的关键特性</li>
</ul>
<p>静态多态</p>
<ul>
<li>允许不同类型的对象以同样的方式被操纵，只要它们支持某种共通的语法。</li>
<li>实际类型决定于编译期</li>
<li>是泛型编程的本质要素</li>
</ul>
<h3 id="Boost-库的多态"><a href="#Boost-库的多态" class="headerlink" title="Boost 库的多态"></a>Boost 库的多态</h3><p>为了在元函数之间实现多态，Boost 程序库使用的约定如下：</p>
<p><code>metafunction-name&lt;type-arguments...&gt;::type</code></p>
<p>从现在开始，当我们使用术语元函数时，就是指可以采用这种语法进行调用的模板。</p>
<h4 id="整型常量外覆器"><a href="#整型常量外覆器" class="headerlink" title="整型常量外覆器"></a>整型常量外覆器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">five</span> // 数值5的整型常量外覆器</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">const</span> value = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> value_type;</span><br><span class="line">    <span class="comment">// ... more</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// to get a int value</span></span><br><span class="line">metafunction-name&lt;type arguments...&gt;::type::value</span><br></pre></td></tr></table></figure>
<h2 id="Boost元函数库"><a href="#Boost元函数库" class="headerlink" title="Boost元函数库"></a>Boost元函数库</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>所有元函数都位于<strong>命名空间</strong>boost中</li>
<li><strong>头文件</strong>格式：<code>#include &lt;boost/type_traits/metafunction-name.hpp&gt;</code></li>
<li>所有<strong>数值元函数</strong>(包括bool, char 类型)都在其自身内直接提供了<code>::value</code></li>
<li>有少数type_traits 为了发挥完整的功能需要一些非标准编译器支持（否则功能降级，但肯定安全、能编译成功）。</li>
<li>类型归类元函数通常会忽视cv修饰符。</li>
</ul>
<h3 id="主类型归类"><a href="#主类型归类" class="headerlink" title="主类型归类"></a>主类型归类</h3><p>Primary Type Categorization</p>
<p>对于给定的类型T，这些元函数中有且仅有一个会产生结果true。</p>
<table>
<thead>
<tr>
<th>主类型Trait</th>
<th>::type::value 和 ::value 为 ture 的情况</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is_array&lt;T&gt;</code></td>
<td>T 是数组类型</td>
</tr>
<tr>
<td><code>is_class&lt;T&gt;</code></td>
<td>T 是类类型，如果缺乏编译器支持，T 是联合体时也是 true</td>
</tr>
<tr>
<td><code>is_enum&lt;T&gt;</code></td>
<td>T 是枚举类型</td>
</tr>
<tr>
<td><code>is_float&lt;T&gt;</code></td>
<td>T 是浮点类型</td>
</tr>
<tr>
<td><code>is_function&lt;T&gt;</code></td>
<td>T 是函数类型，<code>R(*)(args...)</code>/<code>R(&amp;)(args...)</code></td>
</tr>
<tr>
<td><code>is_integral&lt;T&gt;</code></td>
<td>T 是整型</td>
</tr>
<tr>
<td><code>is_member_pointer&lt;T&gt;</code></td>
<td>T 是指向函数成员或数据成员的指针，注意<code>is_pointer</code>识别不了这些类型。</td>
</tr>
<tr>
<td><code>is_pointer&lt;T&gt;</code></td>
<td>T 是指针类型（但不指向成员）</td>
</tr>
<tr>
<td><code>is_reference&lt;T&gt;</code></td>
<td>T 是引用</td>
</tr>
<tr>
<td><code>is_union&lt;T&gt;</code></td>
<td>T 是联合体，若缺乏编译器支持则总是false</td>
</tr>
<tr>
<td><code>is_void&lt;T&gt;</code></td>
<td>T 具有cv void形式</td>
</tr>
</tbody>
</table>
<p><strong>指向成员的指针</strong></p>
<p>指向成员函数的指针：<code>R(C::*)(args...)cv</code></p>
<p>指向数据成员的指针：<code>D C::*</code></p>
<p>实际上它们根本不是指针，而是一种偏移量。所以和指针类型不同。</p>
<h3 id="次类型归类"><a href="#次类型归类" class="headerlink" title="次类型归类"></a>次类型归类</h3><p>Secondary Type Categorization</p>
<p>表示对主类型归类的分组或区分。</p>
<table>
<thead>
<tr>
<th>次类型Trait</th>
<th>::type::value 和 ::value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is_arithmetic&lt;T&gt;</code></td>
<td>`is_integral<t>::value</t></td>
<td></td>
<td>is_float<t>::value`</t></td>
</tr>
<tr>
<td><code>is_compound&lt;T&gt;</code></td>
<td><code>!is_fundamental&lt;T&gt;::value</code></td>
</tr>
<tr>
<td><code>is_fundamental&lt;T&gt;</code></td>
<td>`is_arithmetic<t>::value</t></td>
<td></td>
<td>is_void<t>::value`</t></td>
</tr>
<tr>
<td><code>is_member_function_pointer&lt;T&gt;</code></td>
<td>T是指向成员函数的指针？</td>
</tr>
<tr>
<td><code>is_object&lt;T&gt;</code></td>
<td>`!(is_function<t>::value</t></td>
<td></td>
<td>is_reference<t>::value</t></td>
<td></td>
<td>is_void<t>::value)`</t></td>
</tr>
<tr>
<td><code>is_scalar&lt;T&gt;</code></td>
<td>`is_arithmetic<t>::value</t></td>
<td></td>
<td>is_enum<t>::value</t></td>
<td></td>
<td>is_pointer<t>::value</t></td>
<td></td>
<td>is_member_pointer<t>::value`</t></td>
</tr>
</tbody>
</table>
<h3 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h3><p>对于那些不是和标准类型归类直接相关的traits，type traits程序库使用“属性”作为包罗万象的术语来指定它们。</p>
<p>这个分组中，最简单的是<code>is_const&lt;T&gt;</code>和<code>is_volatile&lt;T&gt;</code>。</p>
<p>其余属性，略。</p>
<h3 id="类型之间的关系"><a href="#类型之间的关系" class="headerlink" title="类型之间的关系"></a>类型之间的关系</h3><table>
<thead>
<tr>
<th>元函数</th>
<th>::value 为 true的条件</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is_same&lt;T,U&gt;</code></td>
<td>T 和 U 类型一致</td>
</tr>
<tr>
<td><code>is_convertible&lt;T,U&gt;</code></td>
<td>T 类型可以被隐式转换为 U 类型</td>
</tr>
<tr>
<td><code>is_base_and_derived&lt;B,D&gt;</code></td>
<td>B 是 D 的一个基类</td>
</tr>
</tbody>
</table>
<h3 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h3><p>不同于之前的，这组元函数产生类型结果而不是布尔值。</p>
<table>
<thead>
<tr>
<th>转化</th>
<th>::type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>remove_const&lt;T&gt;</code></td>
<td>T不带任何顶层const。<code>const int</code>变成int，但<code>const int*</code>不变</td>
</tr>
<tr>
<td><code>remove_volatile&lt;T&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>remove_cv&lt;T&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>remove_reference&lt;T&gt;</code></td>
<td>T不带任何顶层引用。<code>int&amp;</code>变成int，但<code>int*</code>不变</td>
</tr>
<tr>
<td><code>remove_bounds&lt;T&gt;</code></td>
<td>T不带任何顶层数组中括号。<code>int[2][3]</code>变成<code>int[3]</code></td>
</tr>
<tr>
<td><code>remove_pointer&lt;T&gt;</code></td>
<td>T不带任何顶层指针。<code>int*</code>变成int，但<code>int&amp;</code>不变</td>
</tr>
<tr>
<td><code>add_reference&lt;T&gt;</code></td>
<td>如果T是引用类型，结果为T，否则为<code>T&amp;</code></td>
</tr>
<tr>
<td><code>add_pointer&lt;T&gt;</code></td>
<td><code>remove_reference&lt;T&gt;::type*</code>。如<code>int</code>和<code>int&amp;</code>都变成<code>int*</code></td>
</tr>
<tr>
<td><code>add_const&lt;T&gt;</code></td>
<td>T const</td>
</tr>
<tr>
<td><code>add_volatile&lt;T&gt;</code></td>
<td>T volatile</td>
</tr>
<tr>
<td><code>add_cv&lt;T&gt;</code></td>
<td>T const volatile</td>
</tr>
</tbody>
</table>
<h2 id="元函数的定义"><a href="#元函数的定义" class="headerlink" title="元函数的定义"></a>元函数的定义</h2><p><strong>无参元函数</strong></p>
<p>编写无参元函数最容易的方式是借助一个简单的struct：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">always_int</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>元函数的定义</strong></p>
<p>一个元函数可以是</p>
<ul>
<li>一个类模板，它的所有参数都是类型</li>
<li>一个类，带有一个名为”type”的可公开访问的嵌套结果类型</li>
</ul>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MetaProgram/">MetaProgram</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C_C++/C++Collection/C++基础笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/01/20/C_C++/C++Collection/C++基础笔记/" class="article-date">
      <time datetime="2019-01-20T12:51:12.000Z" itemprop="datePublished">2019-01-20</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/20/C_C++/C++Collection/C++基础笔记/">C++ 基础笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="类基础"><a href="#类基础" class="headerlink" title="类基础"></a>类基础</h2><h3 id="说明符和限定符"><a href="#说明符和限定符" class="headerlink" title="说明符和限定符"></a>说明符和限定符</h3><ul>
<li><p>存储说明符：</p>
<p>auto（在c++11 中不再是说明符）</p>
<p>register</p>
<p>static</p>
<p>extern</p>
<p>thread_local（c++11新增，可与static或extern连用）</p>
<p>mutable (指出即使类变量或函数为 const，这个 mutable 成员也能够修改)</p>
<p>PS：除了thread_local，不能在同一个声明中使用多个说明符。</p>
</li>
<li><p>cv限定符：</p>
<p>const</p>
<p>volatile</p>
</li>
</ul>
<h3 id="一些特别的关键字"><a href="#一些特别的关键字" class="headerlink" title="一些特别的关键字"></a>一些特别的关键字</h3><ul>
<li><p>只在类声明时写，定义时不能写的关键字 friend virtual</p>
</li>
<li><p>inline</p>
<p>声明时或者定义时写在前面（不能两个都写）。或者直接在声明时定义，就不需要写了。</p>
<p>//inline的链接性是内部的，函数定义必须在使用函数的文件中，所以可以放在头文件并包含。</p>
</li>
<li><p>explicit</p>
<p>C++11 支持将关键词explicit用于构造函数和转换函数。这样只允许<strong>参数</strong>强制类型转换，不允许隐式转换。</p>
</li>
<li><p>静态函数（内部链接性）使用的static在声明和定义时都要写。</p>
</li>
</ul>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>在重载时，区分const常量和非const常量。</p>
<p>将返回值声明为const可以防止将函数表达式作为左值。</p>
<p>const对象只可以使用const成员函数。</p>
<h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><p>using 编译指令导入一个名称空间中所有的名称。</p>
<p>using 声明只声明名称空间中相应的名称。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> fetch;	<span class="comment">// global namespace ::</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Jill;</span><br><span class="line">    <span class="keyword">double</span> fetch;	<span class="comment">// hides Jill::fetch</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; fetch;	<span class="comment">// local fetch</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ::fetch;	<span class="comment">// global fetch</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Jill::fetch;	<span class="comment">// Jill::fetch</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>指导意见</strong>：</p>
<ul>
<li><p>使用在已命名的名称空间中的变量，而不是全局变量。</p>
</li>
<li><p>对于 using 声明，首选将其作用域设置为局部而不是全局。</p>
</li>
<li><p><strong>注意</strong>：不要在头文件中使用 using 编译指令。</p>
<p>首先，它掩盖了要让哪些名称可用；其次，包含头文件的顺序可能影响程序的行为。</p>
<p>所以，它应该被放在所有 <code>#include</code> 之后。</p>
</li>
</ul>
<p><strong>命名空间别名</strong></p>
<p><code>namespace alias = namespace-name;</code></p>
<h3 id="作用域为类的常量"><a href="#作用域为类的常量" class="headerlink" title="作用域为类的常量"></a>作用域为类的常量</h3><ul>
<li><p><strong>错误</strong>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span>&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> Months = <span class="number">12</span>;</span><br><span class="line">	<span class="keyword">double</span> costs[Months];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释：<strong>声明类只是描述了对象的形式，并没有创建对象，所以没有存储值的空间！！！</strong></p>
</li>
<li><p>正确方法一：使用枚举</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span>&#123;</span></span><br><span class="line">	<span class="keyword">enum</span> &#123;Months = <span class="number">12</span>&#125;;</span><br><span class="line">	<span class="keyword">double</span> costs[Months];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>用这种方式声明枚举并不会创建类数据成员，即所有对象中都不包含枚举。</p>
</li>
<li><p>Months只是一个符号名称，在作用域为整个类的代码中遇到它时，编译器将用12替换它。</p>
</li>
<li><p>不必提供枚举名称。</p>
</li>
</ul>
</li>
<li><p>正确方法二：使用关键字static</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span>&#123;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Months = <span class="number">12</span>;</span><br><span class="line">	<span class="keyword">double</span> costs[Months];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将创建一个常量，<strong>与其他静态变量存储在一起，而不是存储在对象中</strong>。它被所有对象共享。</p>
</li>
</ul>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>非const的static成员需要在类外全局初始化，它不存储在对象中，它被所有对象共享。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func1</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    func1()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> func1::i = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆。</p>
</li>
<li><p>初始化时不加该成员的访问权限控制符private，public等。</p>
</li>
<li><p>初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员。</p>
</li>
</ul>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p><code>operator[op](argument-list)</code></p>
<p>含义：<code>dis = sid + sara</code>  即  <code>dis = sid.operator+(sara)</code></p>
<p>对于第一个操作数不是类本身的运算符重载，则定义非成员函数，如果要用到类私有成员，就可声明为友元函数。</p>
<p>限制：</p>
<ul>
<li><p>至少有一个操作数是用户自定义类型</p>
</li>
<li><p>句法规则不能违反（二元运算符不能变成一元）</p>
</li>
<li><p>优先级不能改变</p>
</li>
<li><p>不能创建新运算符</p>
</li>
<li><p>不能重载一些特别的运算符（c++primerplus 387）</p>
</li>
<li><p>大多数运算符都可以通过成员或非成员函数进行重载，但下面的只能通过成员函数进行重载：</p>
<p><code>=  ()  []  -&gt;</code></p>
</li>
</ul>
<p>重载<code>[]</code>的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> &amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> str_[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> &amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> str_[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在重载时，C++将区分常量和非常量函数的特征标</span></span><br></pre></td></tr></table></figure>
<p>特例：<code>++</code>前缀和后缀</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++ 将 operator++() 作为前缀版本，将 operator++(int) 作为后缀版本，其中的参数永远也不会用到，所以不必指定名称</span></span><br><span class="line"><span class="comment">//下面是定义一个迭代器++的例子</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">double</span> item; Node* p_next;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Node * pt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    iterator &amp; <span class="keyword">operator</span>++()	<span class="comment">//for ++it</span></span><br><span class="line">    &#123;</span><br><span class="line">        pt = pt-&gt;p_next;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>)<span class="comment">//for it++</span></span><br><span class="line">    &#123;</span><br><span class="line">        iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">        pt = pt-&gt;p_next;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><ul>
<li><p>转换构造函数:预定义类型转换成类类型</p>
<p>用单个实参来调用的构造函数默认定义了从形参类型到该类类型的一个隐式转换。</p>
<p>可以用 explicit 来禁止隐式转化。</p>
</li>
<li><p>类型转换函数:类类型转换成其他类型（系统预定义类型）</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> [目标类型]()&#123;</span><br><span class="line">    <span class="keyword">return</span> [目标类型的数据]；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>必须是类方法</li>
<li>没有参数</li>
<li><p>不能指定返回类型（但需要return）</p>
<p><strong>注意</strong>：应该谨慎地使用隐式转换函数。通常，最好选择仅在显式调用时才会执行的普通成员函数：</p>
<p><code>int Stonewt::Stone_to_Int();</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="自动提供的成员函数"><a href="#自动提供的成员函数" class="headerlink" title="自动提供的成员函数"></a>自动提供的成员函数</h3><ul>
<li>默认构造函数（如果没有定义任何构造函数）</li>
<li>默认析构函数</li>
<li>复制构造函数</li>
<li>赋值运算符</li>
<li>地址运算符</li>
<li>移动构造函数（C++11)</li>
<li>移动赋值运算符（C++11）</li>
</ul>
<p><strong>PS</strong>：<strong>如果想隐藏这些函数</strong></p>
<ol>
<li><p>可以定义私有的方法覆盖默认的赋值函数。</p>
</li>
<li><p>可以在函数名后加 <code>= delete</code></p>
</li>
</ol>
<h3 id="何时调用复制构造函数和赋值运算符"><a href="#何时调用复制构造函数和赋值运算符" class="headerlink" title="何时调用复制构造函数和赋值运算符"></a>何时调用复制构造函数和赋值运算符</h3><p>用已有的对象初始化一个新对象时一定调用复制构造函数，即使是用等于号初始化。</p>
<p>将已有对象赋给另一个对象时，使用赋值运算符。</p>
<h3 id="引用变量须初始化"><a href="#引用变量须初始化" class="headerlink" title="引用变量须初始化"></a>引用变量须初始化</h3><p>引用是已定义的变量的别名(指向相同内存单元)，类似于const指针，一旦关联某一变量，便一直效忠于它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp; rodents = rats;</span><br><span class="line"><span class="comment">//实际就是下述代码的伪装表示：</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> pr = &amp;rats;</span><br><span class="line"><span class="comment">//rodents扮演的角色与(*pr)相同</span></span><br></pre></td></tr></table></figure>
<h4 id="引用成员变量"><a href="#引用成员变量" class="headerlink" title="引用成员变量"></a>引用成员变量</h4><p>引用成员不能直接在构造函数里初始化（这时对象已经创建，但是引用还未绑定对象），必须用到初始化列表，且形参也必须是引用类型。</p>
<p>凡是有引用类型的成员变量的类，不能使用默认构造函数。原因是引用类型的成员变量必须在类构造时进行初始化。</p>
<p>如果两个类要对第三个类的数据进行共享处理，可以考虑把第三个类作为这两个类的引用类型的成员变量。</p>
<h3 id="使用了new的复制构造函数定义步骤"><a href="#使用了new的复制构造函数定义步骤" class="headerlink" title="使用了new的复制构造函数定义步骤"></a>使用了new的复制构造函数定义步骤</h3><ol>
<li><p>检查是否为自我赋值，若是，返回*this；</p>
<p>（否则，给对象重新赋值前，释放内存操作可能删除对象内容）</p>
</li>
<li><p>释放成员指针以前指向的内存；</p>
</li>
<li><p>复制数据而不仅仅复制数据的地址</p>
</li>
<li><p>返回一个指向调用对象的引用</p>
</li>
</ol>
<h3 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h3><p>可以在类声明时声明const常量。但是不能在构造函数体内赋值，因为常量只能初始化。这时只能用成员初始化列表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Classy::Classy(<span class="keyword">int</span> n, <span class="keyword">int</span> m) : mem1(n), mem2(<span class="number">0</span>), mem3(n*m+<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这种方法<strong>不限于</strong>初始化常量。不过<strong>只能用于构造函数</strong>。</p>
</li>
<li><p><strong>引用</strong> 和 const 类似，只能在类创建时初始化。所以<strong>必须</strong>用成员初始化列表。</p>
</li>
<li><strong>派生类</strong>不能直接访问基类的私有成员，必须在派生类构造函数之前调用<strong>基类构造函数</strong>，也是使用这种语法。</li>
<li>对于本身就是类对象的成员来说，使用成员初始化列表效率更高。</li>
<li>成员被初始化的顺序为他们被声明的顺序，而不是初始化列表里的顺序。</li>
</ul>
<p><strong>PS</strong>：c++11可以直接在类内初始化。如果还使用成员初始化列表，那么将覆盖类内初始化的值。</p>
<h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>C++里结构也是一种类，所以嵌套类类似于类内声明的结构。</p>
<p>对嵌套类访问权限的控制规则与常规类相同，并没有特权。</p>
<h2 id="继承相关"><a href="#继承相关" class="headerlink" title="继承相关"></a>继承相关</h2><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul>
<li>如果重新定义基类函数，该操作将隐藏所有的同名基类函数。</li>
<li>最好对类数据成员采用私有访问控制。而对于成员函数来说，保护访问控制很有用。</li>
<li>不能被继承的方法：构造函数、析构函数、赋值运算符。</li>
<li>省略访问限定符时默认为私有继承。</li>
</ul>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><h4 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h4><ul>
<li><p><strong>用处</strong>：如果没有关键字virtual，程序将根据引用类型或指针类型选择方法；如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法。</p>
</li>
<li><p>方法在基类中声明为虚的后，它在派生类中自动成为虚方法。（派生类的virtual关键字可选）</p>
</li>
<li><p>virtual只用于声明原型，方法定义不写。</p>
</li>
<li><p>如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。<strong>基类即使不需要析构函数，也要为它提供一个虚析构函数。</strong></p>
<p>否则，则不要用virtual。因为virtual的根据引用类型来选择方法的特性需要<strong>动态联编</strong>，需要额外开销（虚函数表的创建及查找）。</p>
</li>
<li><p>友元不能用 virtual，因为它不是类成员。可以让友元函数使用虚成员函数来解决一些设计问题。</p>
</li>
</ul>
<p>注意：<strong>对于保护继承和私有继承</strong>，不能形成多态。<strong>只有显式类型转换才能将基类指针或引用指向派生类对象。</strong></p>
<h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>形式：在虚函数结尾加上 =0        <code>virtual fun(…) const = 0;</code></p>
<p>只需要结尾的 =0 ，和前面的 virtual 无关联。</p>
<p>当类中包含纯虚函数，则不能创建该类的对象。该类成为抽象基类(abstract bass class, ABC)。</p>
<h3 id="派生类调用基类方法的形式"><a href="#派生类调用基类方法的形式" class="headerlink" title="派生类调用基类方法的形式"></a>派生类调用基类方法的形式</h3><ul>
<li><p><strong>析构函数</strong></p>
<p>自动调用。</p>
</li>
<li><p><strong>（复制）构造函数</strong></p>
<p>在初始化成员列表中调用基类的（复制）构造函数。</p>
</li>
<li><p><strong>赋值运算符</strong></p>
<p>使用作用域解析符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">derive &amp; derive::<span class="keyword">operator</span>=(<span class="keyword">const</span> derive &amp; de)&#123;</span><br><span class="line">    <span class="comment">//this == &amp;de</span></span><br><span class="line">    base::<span class="keyword">operator</span>=(de);	<span class="comment">//copy base portion</span></span><br><span class="line">    <span class="comment">//delete</span></span><br><span class="line">    <span class="comment">//copy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>友元</strong></p>
<p>由于友元不是类成员，不能用作用域解析运算符来指出要使用哪个函数，方法是使用强制类型转换，以便匹配原型时能选择正确的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> derive &amp; de)&#123;</span><br><span class="line">    os &lt;&lt; (<span class="keyword">const</span> base &amp;)de;</span><br><span class="line">    os &lt;&lt; 'additon';</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="基类与派生类的互相赋值"><a href="#基类与派生类的互相赋值" class="headerlink" title="基类与派生类的互相赋值"></a>基类与派生类的互相赋值</h3><ul>
<li><p>派生对象赋给基类对象</p>
<p>默认可行，但这只涉及基类的成员。</p>
</li>
<li><p>基类对象赋给派生对象</p>
<p>默认不行，除非有下面三种定义之一：</p>
<ol>
<li>转换构造函数，将基类转换为派生 <code>derived_type(const type &amp;);</code></li>
<li>默认参数的构造函数 <code>derived_type(const type &amp; a, double b=0, … );</code></li>
<li>赋值运算符 <code>derived_type &amp; derived_type::operator=(const type &amp;);</code></li>
</ol>
</li>
</ul>
<h3 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h3><h4 id="包含与私有继承不同点"><a href="#包含与私有继承不同点" class="headerlink" title="包含与私有继承不同点"></a>包含与私有继承不同点</h4><ol>
<li><p>包含提供了被显式命名的对象成员，而私有继承提供无名子对象成员。</p>
</li>
<li><p>使用构造函数的初始化列表时，包含使用对象名，私有继承使用类名。</p>
</li>
<li><p>使用包含时使用对象名来调用方法，使用私有继承时使用类名和作用域解析运算符来调用方法。</p>
</li>
<li><p>私有继承访问父类对象时，使用强制类型转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> &amp; student::Name() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">const</span> <span class="built_in">string</span> &amp;) *<span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="comment">//返回student里的无名string对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>访问基类的友元函数时，强制类型转换为基类来调用。</p>
</li>
</ol>
<p>附：<strong>使用包含还是私有继承</strong>？</p>
<p>通常，应使用包含来建立has-a关系；</p>
<p>如果类需要访问原有类的保护成员，或需要重新定义虚函数，则使用私有继承。</p>
<h4 id="让私有继承的基类方法在外使用"><a href="#让私有继承的基类方法在外使用" class="headerlink" title="让私有继承的基类方法在外使用"></a>让私有继承的基类方法在外使用</h4><ol>
<li><p>定义一个使用该基类的派生类方法</p>
</li>
<li><p>使用using声明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">private</span> <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">private</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::min;</span><br><span class="line">		<span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::max;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>using 声明只使用成员名——所有重载的同名方法都能用。</li>
<li>using 声明只适用于继承，不适用于包含。</li>
</ul>
</li>
</ol>
<h3 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h3><p>对于外部世界来说，保护成员的行为与私有成员相似；</p>
<p>对于派生类来说，保护成员的行为与公有成员相似。</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><h4 id="虚基类virtual"><a href="#虚基类virtual" class="headerlink" title="虚基类virtual"></a>虚基类virtual</h4><ul>
<li><p>virtual类似关键字重载，与虚函数没有联系。</p>
<p><code>class Singer : virtual public Worker{...}</code></p>
</li>
<li><p>当出现棱形继承时，使用虚基类可以防止基类的对象被声明两次。</p>
</li>
<li><p>基类是虚的，则在构造函数初始化时，信息不能通过中间类自动传递给基类（防止多方传递，可以这么做，但是传递不过去），这时<strong>只能在成员初始化列表里</strong>使用虚基类的构造函数，<strong>否则</strong>将使用默认构造函数。</p>
</li>
</ul>
<h4 id="虚基类的优先级规则"><a href="#虚基类的优先级规则" class="headerlink" title="虚基类的优先级规则"></a>虚基类的优先级规则</h4><p>使用虚基类将改变C++的优先级规则。</p>
<p>使用非虚基类时，规则很简单，如果从不同的类继承了同名成员，则使用该成员时，没用类名限定，将导致二义性。</p>
<p>使用虚基类时，则不一定导致二义性。规则是：派生类中的名称优先于直接或间接祖先类中的相同名称。</p>
<p><strong>注意：</strong>虚二义性规则与访问规则无关。即使有些成员是私有的不能使用，但如果符合规则的二义性，则同样会出现二义性错误；或者派生类的同名成员是私有的，那么默认规则也不能跳过派生类的而使用基类的同名成员。</p>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>友元类的所有方法都可以访问原始类的私有和保护成员。</p>
<p>友元声明可位于公有、私有、保护部分，位置无关紧要。</p>
<h4 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h4><p>需要使用<strong>前向声明</strong>，以Tv类和Remote类做例子。</p>
<p>Tv类里将Remote的函数声明为友元，要使用Remote::，编译器需要知道这个作用域的含义，所以要先声明Remote类；但是Remote的方法提到了Tv对象。这时就需要前向声明Tv对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tv</span>;</span>		<span class="comment">//forward declaration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Remote</span>&#123;</span>…&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tv</span>&#123;</span>…&#125;;</span><br></pre></td></tr></table></figure>
<p>这样在Remote里就知道Tv是一个对象了，Tv也知道Remote::是哪里的作用域。</p>
<p>能否前向声明Remote呢？    不能。</p>
<p>因为Tv类里不仅有Remote::，还有Remote的方法名，所以仅声明Remote对象是不够的。</p>
<p>注意1：Remote里<em>用到了 Tv类 的内联函数</em>应该放在 TV类声明之后定义，使用inline关键字让它成为内联函数。</p>
<p>注意2：让整个Remote类成为友元并不需要前向声明，因为友元语句本身已经指出Remote是一个类。</p>
<h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><h3 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  //<span class="title">definition</span></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">fun</span>(<span class="title">T</span> &amp;, <span class="title">T</span> &amp;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> fun&lt;zzsy&gt;(zzsy &amp;, zzsy &amp;)&#123;...&#125;;  <span class="comment">//显式具体化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> fun&lt;<span class="keyword">char</span>&gt;(<span class="keyword">char</span> &amp;, <span class="keyword">char</span> &amp;);  <span class="comment">//显式实例化</span></span><br></pre></td></tr></table></figure>
<h3 id="类模版"><a href="#类模版" class="headerlink" title="类模版"></a>类模版</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul>
<li><p>可用Typename替换模版里的class关键字</p>
</li>
<li><p>如果在类声明中定义了方法（内联定义），则可以省略模版前缀和类限定符。</p>
</li>
<li><p>在可以在模板类声明和模板函数定义内简写直接使用 <code>[classname]</code>，但是在类的外面，即指定返回类型或使用作用域解析运算符时，必须使用完整的 <code>[classname]&lt;Type&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">myclass</span>&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">myclass &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> myclass &amp; mc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">myclass</span>&lt;Type&gt; &amp; <span class="title">myclass</span>&lt;Type&gt;:</span>:<span class="keyword">operator</span>=(<span class="keyword">const</span> myclass&lt;Type&gt; &amp; mc)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模版是编译器指令，它们不能单独编译。模版必须与特定的模版实例化请求一起使用。为此，最简单的方法是将所有模版信息放在头文件，并在使用时包含。</p>
</li>
</ul>
<h4 id="非类型参数-表达式参数"><a href="#非类型参数-表达式参数" class="headerlink" title="非类型参数/表达式参数"></a>非类型参数/表达式参数</h4><p>定义：  <code>template &lt;class T, int n&gt;</code></p>
<p><code>int n</code> 指出 n 的类型 为 int，这种参数（指定特殊的类型而不是用作泛型名）成为非类型（non-type）或表达式（expression）参数。</p>
<ul>
<li>表达式参数可以是<strong>整型</strong>、<strong>枚举</strong>、<strong>引用</strong>、<strong>指针</strong>。因此double m是不合法的，但是double * m是合法的。</li>
<li>模版代码不能修改参数的值，也不能使用参数的地址，所以不能在模版中使用诸如n++和&amp;n等表达式，<strong>实例化模版时，用作表达式参数的值必须是常量表达式</strong>。</li>
</ul>
<h4 id="递归使用模版"><a href="#递归使用模版" class="headerlink" title="递归使用模版"></a>递归使用模版</h4><p><code>ArrayTP&lt; ArrayTP&lt;int,5&gt;, 10&gt;twodee</code> 与<code>int twodee[10][5]</code>等价，<strong>在模版语法中，维的顺序与二维数组相反</strong>。</p>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>类模板可以为<strong>类型参数</strong>提供默认值，这样如果忽略了类型参数值，则将使用默认的类型。（函数模版不能提供默认类型参数）</p>
<p>类模版和函数模版都能提供<strong>非类型参数</strong>默认值。</p>
<h4 id="具体化"><a href="#具体化" class="headerlink" title="具体化"></a>具体化</h4><p>与模版函数类似。新特点是可以部分具体化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//general template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="title">class</span> <span class="title">Pair</span>&#123;</span>…&#125;;</span><br><span class="line"><span class="comment">//specialization with T2 set to int</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="title">class</span> <span class="title">Pair</span>&lt;T1,int&gt;&#123;</span>…&#125;;</span><br></pre></td></tr></table></figure>
<p>如果有多个模版，则编译器将使用具体化程度最高的模版。</p>
<p>也可以为指针提供特殊版本来部分具体化现有的模版。（如果调用的模板没有部分具体化指针，则将 T 转化为<code>type *</code>，如果部分具体化了指针（<code>&lt;class T*&gt;</code>）则将 T 转化为 type。</p>
<h4 id="模版嵌套"><a href="#模版嵌套" class="headerlink" title="模版嵌套"></a>模版嵌套</h4><p>模板可以用作结构、类或模板类的成员（这样可以在类内实例化参数不同的对象）。要完全实现STL，必须有这项特性。</p>
<p>可以直接在模板内定义模板，也可以像下面这样在外定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">beta</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>&gt;	//<span class="title">declaration</span></span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">hold</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member difinition</span></span><br><span class="line"><span class="keyword">template</span>&lt;Typename T&gt;</span><br><span class="line">	<span class="keyword">template</span>&lt;Typename V&gt;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">beta</span>&lt;T&gt;:</span>:hold</span><br><span class="line">        &#123;</span><br><span class="line">        	...</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//不同于</span></span><br><span class="line"><span class="keyword">template</span>&lt;Typename T, Typename V&gt;</span><br></pre></td></tr></table></figure>
<h4 id="模板作为模板参数"><a href="#模板作为模板参数" class="headerlink" title="模板作为模板参数"></a>模板作为模板参数</h4><p>也是用于实现STL。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Thing</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Crab</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Thing&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    Thing&lt;<span class="keyword">double</span>&gt; s2;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Crab&lt;Stack&gt; s;	<span class="comment">// Stack&lt;int&gt; s1, Stack&lt;double&gt; s2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模版类和友元"><a href="#模版类和友元" class="headerlink" title="模版类和友元"></a>模版类和友元</h4><h5 id="非模版友元函数"><a href="#非模版友元函数" class="headerlink" title="非模版友元函数"></a>非模版友元函数</h5><p>方式：在模版中将一个常规函数声明为友元，则<strong>该函数成为模版所有实例化的友元</strong>。</p>
<p>带某个 模板实例化参数 的友元，成为该实例化的友元。</p>
<h5 id="约束模版友元函数"><a href="#约束模版友元函数" class="headerlink" title="约束模版友元函数"></a>约束模版友元函数</h5><p>使<strong>类的每一个具体化都获得与友元匹配的具体化</strong>。步骤：</p>
<ol>
<li>在类定义的前面声明每个模版函数</li>
<li>在类声明中将模版声明为友元，具体化为类模版的类型参数。</li>
<li>为友元提供模版定义</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">counts</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> counts&lt;TT&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counts</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="非约束模版友元函数"><a href="#非约束模版友元函数" class="headerlink" title="非约束模版友元函数"></a>非约束模版友元函数</h5><p>方法：在类内部声明模版，可以创建非约束友元函数，即<strong>每个友元函数具体化都是每个类具体化的友元</strong>。</p>
<p>对于非约束模板友元，友元模版类型与模版类类型参数是不同的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> D&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(C &amp;, D &amp;)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> D&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(C &amp; c, D &amp; d)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-11模版别名"><a href="#C-11模版别名" class="headerlink" title="C++11模版别名"></a>C++11模版别名</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typedef 只能为*完全实例化*的模板定义别名</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">using</span> arrtype = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;T,<span class="number">12</span>&gt;;	<span class="comment">//differ from typedef</span></span><br><span class="line"></span><br><span class="line">arrtype&lt;<span class="keyword">int</span>&gt; days;		<span class="comment">//days is type std::array&lt;int,12&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在模板元编程里看到的例子</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">add_const_ref_t</span> = <span class="keyword">typename</span> add_const_ref&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于非模版时，using 和 typedef 等价</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">char</span> * pc1;</span><br><span class="line"><span class="keyword">using</span> pc2 = <span class="keyword">const</span> <span class="keyword">char</span> *;</span><br></pre></td></tr></table></figure>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="abort-函数"><a href="#abort-函数" class="headerlink" title="abort()函数"></a>abort()函数</h3><p>位于cstdlib，向标准错误流(cerr)发送消息 abnormal program termination，然后终止程序。返回一个随实现而异的值，告诉父进程处理失败。</p>
<p>abort()不一定刷新文件缓冲区，不过exit()会刷新文件缓冲区，但不显示消息。</p>
<h3 id="捕获方式"><a href="#捕获方式" class="headerlink" title="捕获方式"></a>捕获方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fun();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(bad_2 &amp;be)</span><br><span class="line">&#123;		&#125;</span><br><span class="line"><span class="keyword">catch</span>(bad_1 &amp;be)</span><br><span class="line">&#123;		&#125;</span><br><span class="line"><span class="keyword">catch</span>&#123;...&#125;	<span class="comment">//catch any type exception</span></span><br><span class="line">&#123;		&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bad_1</span>&#123;</span>	&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bad_2</span>:</span> <span class="keyword">public</span> bad_1&#123;	&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>()</span><br><span class="line">        <span class="keyword">throw</span> bad_1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意-amp-特性"><a href="#注意-amp-特性" class="headerlink" title="注意&amp;特性"></a>注意&amp;特性</h3><ul>
<li><p>如果在catch块里面有<code>throw;</code>语句，则将捕捉的异常再次抛出，让其他的catch去捕获。</p>
</li>
<li><p><strong>栈解退</strong></p>
<p>假如函数由于异常终止，它不会在释放栈的第一个返回地址后停止，而是一直释放栈，直到找到一个位于try块的返回地址。</p>
<p>栈解退时对于栈中的自动类对象，析构函数将被调用。</p>
</li>
<li><p>引发异常时，编译器<strong>总是创建一个临时拷贝</strong>，<strong>即使</strong>异常规范和catch快中指定的<strong>是引用</strong>。</p>
<p>因为引发异常后的函数将被释放，原来的异常对象也会被释放。</p>
<p><strong>使用引用的好处是可以让基类引用去引用派生类</strong>（多态）。</p>
</li>
<li><p>如果使用了new，要注意在throw之前delete。或者直接使用智能指针。</p>
</li>
</ul>
<h3 id="异常规范"><a href="#异常规范" class="headerlink" title="异常规范"></a>异常规范</h3><p>一致<strong>建议不要使用</strong>这项功能。</p>
<p>异常规范不适用于模版，因为模版函数引发的异常可能随特定的具体化而异。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++98</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">(bad_thing)</span></span>;	<span class="comment">//may throw bad_thing exception</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;				<span class="comment">//doesn't throw an exception</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c++11</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;			<span class="comment">//doesn't throw an exception</span></span><br></pre></td></tr></table></figure>
<h3 id="exception类"><a href="#exception类" class="headerlink" title="exception类"></a>exception类</h3><ul>
<li>头文件 exception</li>
<li>有一个what()虚成员函数</li>
</ul>
<p>头文件stdexcept定义了其他几个由exception派生来的异常类，下面介绍两个：</p>
<ol>
<li>logic_error系列，以下为它的派生类<ul>
<li>domain_error  参数不在定义域</li>
<li>invalid_error    给函数传递了意外的值</li>
<li>length_error    没有足够空间</li>
<li>out_of_bounds   索引错误</li>
</ul>
</li>
<li>runtime_error系列，以下为它的派生类<ul>
<li>range_error        计算结果不在函数允许的范围内，但没有上溢或下溢</li>
<li>overflow_error    下溢错误</li>
<li>underflow_error   上溢错误</li>
</ul>
</li>
</ol>
<h3 id="new引发的异常"><a href="#new引发的异常" class="headerlink" title="new引发的异常"></a>new引发的异常</h3><p>对于使用new导致的内存分配问题，C++的最新处理方式是让new引发bad_alloc异常。</p>
<p>头文件new包含了bad_alloc类的声明。</p>
<p>但是很多代码都是在new失败时返回空指针时编写的。当前C++提供了一种在失败时返回空指针的new：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">int</span> *pa = <span class="keyword">new</span> (<span class="built_in">std</span>::nowthrow) <span class="keyword">int</span>[<span class="number">500</span>];</span><br></pre></td></tr></table></figure>
<h3 id="意外异常-amp-未捕获异常"><a href="#意外异常-amp-未捕获异常" class="headerlink" title="意外异常&amp;未捕获异常"></a>意外异常&amp;未捕获异常</h3><ol>
<li><p><strong>未捕获异常</strong>——如果异常不是在函数中引发的或者函数没有异常规范，则必须捕获它。如果没捕获，就是未捕获异常。</p>
<p>有未捕获异常时，程序首先调用函数 terminate() 。在默认情况下， terminate() 调用 abort() 。</p>
<p>可以用set_terminate()函数指定 terminate() 函数应调用的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myQuit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Terminating due to exception"</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">set_terminate(myQuit);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>意外异常</strong>——在带异常规范的函数中引发的与规范列表中的异常都不匹配的异常。</p>
<p>有意外异常时，程序首先调用 unexpected() 函数，而它默认调用 terminate() 函数 ，后者在默认情况下调用 abort()。</p>
<p>可以用set_unexpected() 指定 unexpected() 调用的函数。不过这个被指定的函数的行为受到更严格的限制，具体略。</p>
</li>
</ol>
<h3 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h3><p>运行阶段类型识别（runtime Type Identification）</p>
<p>目前没用处，略。</p>
<p>typeid运算符返回一个对type_info对象的引用，而这个对象有一个name()成员，并重载了==和 !=运算符，可以进行类型比较。</p>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="ios类"><a href="#ios类" class="headerlink" title="ios类"></a>ios类</h3><p>ios类是从ios_base类派生出来的,<br>ios类派生出ostream类、istream类和streambuf类，<br>iostream类又从istream和ostream两个类继承了输入输出方法。</p>
<h3 id="流对象"><a href="#流对象" class="headerlink" title="流对象"></a>流对象</h3><p>4个处理char的流对象，4个处理w_char的流对象。</p>
<p>cin  cout  cerr clog         wcin wcout wcerr wclog</p>
<p>cerr和clog都对应标准错误流，但cerr没有被缓冲，clog被缓冲。 </p>
<h3 id="cout"><a href="#cout" class="headerlink" title="cout"></a>cout</h3><ul>
<li><p>cout用于字符串指针时是输出字符串，用于其他指针是输出地址。</p>
<p>想输出字符串的地址时，必须将字符串指针转换为其他类型：<code>cout &lt;&lt; (void *) str</code>。</p>
</li>
<li><p>cout.put()显示字符，cout.write()显示字符串。</p>
<p>可以拼接：<code>cout.put(a).put(b).write(str，10) &lt;&lt; endl</code>。</p>
<p><code>cout.put(66.3);        //convert double 66.3 to char 66, namely &#39;B&#39;</code></p>
</li>
<li><p>刷新缓冲区</p>
<p>控制符flush刷新缓冲区，控制符endl刷新缓冲区并且插入一个换行符。</p>
<p>它们都有各自的函数，其实<code>cout &lt;&lt; flush</code>就是调用的<code>flush(cout)</code>。</p>
</li>
<li><p>控制整数的进制</p>
<p>使用dec、hex和oct控制符。<code>cout &lt;&lt; hex;</code>即调用<code>hex(cout)</code>，这将设置为16进制，<strong>持续到下一次设置</strong>。</p>
</li>
<li><p>调整字段宽度。</p>
<p><code>int width()</code>返回字段宽度的当前设置；</p>
<p><code>int width(int i)</code>将字段宽度设置为 i个空格，并返回以前的字段宽度。</p>
<p>这是成员函数，必须用对象调用。并且<strong>只影响接下来显示的一个项目</strong>，然后会恢复为默认值。</p>
<p>c++永远不会截短数据，如果试图在2位宽度中打印7位值，c++则将增宽字段，以容纳该数据。</p>
</li>
<li><p>调整填充字符   <code>cout.fill(&#39;*&#39;)</code>，不带参数则返回当前值，<strong>持续到下一次设置</strong>。</p>
</li>
<li><p>设置浮点数的显示精度   <code>cout.precision(2)</code>，不带参数则返回当前值，<strong>持续到下一次设置</strong>。</p>
</li>
<li><p>上面3点返回的都不是iostream对象，所以不是控制符，不能用cout拼接。</p>
<p><strong>头文件iomanip</strong>里提供了一些控制符，其中包括了上面3个功能。</p>
<p>分别为setprecision()，setfill()，setw()。因为是控制符，所以能用cout连接。</p>
</li>
</ul>
<h3 id="setf"><a href="#setf" class="headerlink" title="setf()"></a>setf()</h3><p>ios_base类提供了一个setf()成员函数，可以控制多种格式化特性，具体查阅手册。</p>
<p>还有很多标准控制符能调用setf()并提供正确的参数，具体查阅手册。</p>
<h3 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h3><ul>
<li><p>cin跳过空白，即使是读取单字符。</p>
</li>
<li><p><code>cin.get(char &amp;)</code>  /  <code>cin.get(void)</code>  <strong>不会跳过空白</strong>，不带参数的返回int值。</p>
<p><code>cin.get(char*,int,char)</code>  /  <code>getline(char*,int,char)</code>  一直读取直到遇到第三个参数（分界符），它默认为换行符。get()会将分界符留在输入流中，而getline()会读取并丢弃。</p>
<p><code>istream &amp; cin.ignore(int = 1, int = EOF);</code> 第一个参数是读取的最大字符数，第二个是分界符。满足其中一个条件，读取后丢弃。</p>
<p>上面三个函数都是<strong>非格式化输入函数</strong>，因为它们只是读取字符输入，而不会跳过空白，也不进行数据转换。</p>
</li>
<li><p>其他istream方法</p>
<p>peek()返回输入中的下一个字符，但不抽取输入流中的字符。</p>
<p>gcount()返回最后一个非格式化抽取方法读取的字符数（然而并没有对字符串使用strlen()的效率高）。</p>
<p>putback()将一个字符插入到输入流中，这将成为下一次读取的字符。</p>
</li>
<li><p>输入不满足期望时，不会进行赋值，返回0。这时会改变<strong>流状态</strong>：</p>
<p>eofbit、badbit、failbit、goodbit，可以用eof()、bad()、fail()、good()的返回值进行判断。但是由于历史原因，<strong>fail()在badbit被设置时，也会返回true</strong>，所以处理时要进行判断，如下。</p>
<p>改变流状态后<strong>输入或输出将关闭</strong>，直到重新设置流状态。（有时还需要处理输入缓冲区的残留）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cin</span>.fail() &amp;&amp; !<span class="built_in">cin</span>.eof())	<span class="comment">//fail because of mismatched input</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cin</span>.clear();				<span class="comment">//reset stream state</span></span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isspace</span>(<span class="built_in">cin</span>.get() ) )</span><br><span class="line">    	<span class="keyword">continue</span>;				<span class="comment">//get rid of bad input</span></span><br><span class="line">	<span class="comment">/*	OR</span></span><br><span class="line"><span class="comment">	while(cin.get() != '\n')</span></span><br><span class="line"><span class="comment">		continue;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>	<span class="comment">//else bail out</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I cannot go on!\n"</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>clear()将状态设置为它的参数，默认为0，即清除全部三个状态位eofbit、failbit、badbit。</p>
</li>
<li><p>setstate()只影响参数中已设置的位，其他位不变。</p>
</li>
</ul>
</li>
</ul>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><ul>
<li>头文件fstream中包括了ifstream类和ofstream类和fstream类，这些类都是从iostream中的类派生的，可以使用所有的对应iostream里类的方法。</li>
</ul>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="打开关闭文件"><a href="#打开关闭文件" class="headerlink" title="打开关闭文件"></a>打开关闭文件</h4><p><strong>打开文件</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//open-1</span></span><br><span class="line">ofstream fout;</span><br><span class="line">fout.open(<span class="string">"test.txt"</span>);</span><br><span class="line"><span class="comment">//open-2</span></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"test.txt"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test</span></span><br><span class="line"><span class="keyword">if</span>(fout.is_open())&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关闭文件</strong></p>
<ul>
<li><p>当输入和输出流对象过期（如程序终止）时，到文件的连接将<strong>自动关闭</strong>。</p>
</li>
<li><p>可以显式调用<code>f.close()</code>断开到文件的连接。</p>
<p>然而，流管理装置仍然保留，f 对象与它管理的缓冲区仍然存在。</p>
</li>
</ul>
<p><strong>打开多个文件</strong></p>
<p>可以为每个文件创建一个流，也可以仅使用一个流：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ifstream fin;</span><br><span class="line">fin.open(<span class="string">"test1.txt"</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">fin.close();</span><br><span class="line">fin.clear();	<span class="comment">//reset fin (may not be needed)</span></span><br><span class="line">fin.open(<span class="string">"test2.txt"</span>);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<h4 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h4><p><code>open()</code> 函数的第二个参数可以指定文件打开模式。</p>
<p><strong>C++ 和 C 的文件打开模式</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">C++ mode</th>
<th style="text-align:center">c mode</th>
<th style="text-align:center">explain</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ios_base::in</td>
<td style="text-align:center">“r”</td>
<td style="text-align:center">打开以读取</td>
</tr>
<tr>
<td style="text-align:center">ios_base::out</td>
<td style="text-align:center">“w”</td>
<td style="text-align:center">打开以写入，如果已经存在，则截短文件</td>
</tr>
<tr>
<td style="text-align:center">ios_base::out \</td>
<td style="text-align:center">ios_base::trunc</td>
<td style="text-align:center">“w”</td>
<td>等价于上方</td>
</tr>
<tr>
<td style="text-align:center">ios_base::out \</td>
<td style="text-align:center">ios_base::app</td>
<td style="text-align:center">“a”</td>
<td>打开以写入，只追加</td>
</tr>
<tr>
<td style="text-align:center">ios_base::in \</td>
<td style="text-align:center">ios_base::out</td>
<td style="text-align:center">“r+”</td>
<td>打开以读写，在文件允许的位置写入</td>
</tr>
<tr>
<td style="text-align:center">ios_base::in\</td>
<td style="text-align:center">ios_base::out\</td>
<td style="text-align:center">ios_base::trunc</td>
<td>“w+”</td>
<td>打开以读写，如果已经存在，则截短文件</td>
</tr>
<tr>
<td style="text-align:center">[c++mode] \</td>
<td style="text-align:center">ios_base::binary</td>
<td style="text-align:center">“[cmode]b”</td>
<td>二进制模式打开</td>
</tr>
<tr>
<td style="text-align:center">[c++mode] \</td>
<td style="text-align:center">ios_base::ate</td>
<td style="text-align:center">[cmode] +  fseek</td>
<td>以指定的模式打开，并移到文件尾。<br>c 调用 fseek(file, 0, SEEK_END)</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：ios_base::app模式只允许将数据添加到文件尾，ios_base::ate模式只是将指针放到文件尾。</p>
<h4 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//text mode</span></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"planets.dat"</span>, ios_base::out | ios_base::app)</span></span>;</span><br><span class="line">fout &lt;&lt; pl.name &lt;&lt; <span class="string">" "</span> &lt;&lt; pl.population &lt;&lt; <span class="string">" "</span> &lt;&lt; pl.g &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//binary mode</span></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"planets.dat"</span>, ios_base::out | ios_base::app | ios_base::binary)</span></span>;</span><br><span class="line">fout.write( (<span class="keyword">char</span>*)&amp;pl, <span class="keyword">sizeof</span> pl);</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"planets.dat"</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line">fin.read((<span class="keyword">char</span>*)&amp;pl, <span class="keyword">sizeof</span> pl);</span><br></pre></td></tr></table></figure>
<p>注意：二进制模式下write整个对象，有时候可以，有时候不行——指针成员，类成员，虚方法（虚函数表可能会变）</p>
<h4 id="随机存取"><a href="#随机存取" class="headerlink" title="随机存取"></a>随机存取</h4><p>seekg() 用于 ifstream，seekp() 用于 ofstream，两者都用于 fstream。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型一：距离[seekdir]指定的文件位置[streamoff]字节的位置</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">seek</span><span class="params">(streamoff, ios_base::seekdir)</span></span>;</span><br><span class="line"><span class="comment">//原型二：距离文件开头[streampos]字节的位置</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">seek</span><span class="params">(streampos)</span></span>;	<span class="comment">//文件的 streampos 从 0 开始递增。</span></span><br><span class="line"></span><br><span class="line">[ios::seekdir]的取值：</span><br><span class="line">ios_base::cur</span><br><span class="line">ios_base::beg</span><br><span class="line">ios_base::end</span><br></pre></td></tr></table></figure>
<p>tellg() 返回输入流当前文件指针位置(streampos)，tellp() 返回输出流当前指针位置。对于fstream，两者返回相同。</p>
<h4 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">//创建一个临时文件名，将它放在 pszName 指向的C-风格字符串中。</span></span><br><span class="line"><span class="comment">//常量 L_tmpnam 限制文件名包含的字符数；TMP_MAX 限制了不重复情况下可被调用的最多次数。</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span>* pszName)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="内核格式化"><a href="#内核格式化" class="headerlink" title="内核格式化"></a>内核格式化</h3><p>sstream族使用相同的接口提供应用程序和 string 对象之间的 I/O。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="built_in">ostringstream</span> outstr;</span><br><span class="line">outstr &lt;&lt; <span class="string">"Hello"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2019 Skuaka
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 1;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>