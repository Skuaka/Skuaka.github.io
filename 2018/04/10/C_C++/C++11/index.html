<!DOCTYPE html>
<html lang="zh-cmn-Hans">
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <meta http-equiv="”Cache-Control”" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  
  <title>C++11（待续 | Skuaka</title>
  <link rel="icon" type="image/png" sizes="32x32" href>
  



<link rel="stylesheet" href="/./vendor.ec1199.css"><link rel="stylesheet" href="/./app.5ed5af.css">


</head>
  <body>
    <header class="main-header">
  <div class="container">
    <a href="/" " class="logo">
      <img src="logo.jpg" alt="Skuaka" class="logo-img">
    </a>
    <span class="nav-separator"></span>
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索文章"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
    <a href="javascript:void(0);" class="nav-icon">
      <i class="fas fa-bars"></i>
    </a>
    <nav class="main-nav">
      <ul class="nav-list">
        
          <li class="nav-link ">
            <a href="/">首页</a>
          </li>
        
          <li class="nav-link ">
            <a href="/archives/">归档</a>
          </li>
        
          <li class="nav-link ">
            <a href="/categories">分类</a>
          </li>
        
          <li class="nav-link ">
            <a href="/about.html">关于</a>
          </li>
        
      </ul>
    </nav>
  </div>
</header>
    <div class="page--article">
  
    <div class="toc-container">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#新类型"><span class="toc-number">1.</span> <span class="toc-text">新类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化列表"><span class="toc-number">2.</span> <span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#声明"><span class="toc-number">3.</span> <span class="toc-text">声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto"><span class="toc-number">3.1.</span> <span class="toc-text">auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype"><span class="toc-number">3.2.</span> <span class="toc-text">decltype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#返回后置类型"><span class="toc-number">3.3.</span> <span class="toc-text">返回后置类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr"><span class="toc-number">3.4.</span> <span class="toc-text">constexpr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模版别名：using"><span class="toc-number">3.5.</span> <span class="toc-text">模版别名：using=</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nullptr"><span class="toc-number">3.6.</span> <span class="toc-text">nullptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#智能指针"><span class="toc-number">4.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常规范"><span class="toc-number">5.</span> <span class="toc-text">异常规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作用域内枚举"><span class="toc-number">6.</span> <span class="toc-text">作用域内枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对类的修改"><span class="toc-number">7.</span> <span class="toc-text">对类的修改</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#显式转换运算符explicit"><span class="toc-number">7.1.</span> <span class="toc-text">显式转换运算符explicit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类内成员初始化"><span class="toc-number">7.2.</span> <span class="toc-text">类内成员初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模版和STL的修改"><span class="toc-number">8.</span> <span class="toc-text">模版和STL的修改</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基于范围的for循环"><span class="toc-number">8.1.</span> <span class="toc-text">基于范围的for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新的STL容器"><span class="toc-number">8.2.</span> <span class="toc-text">新的STL容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新的STL方法"><span class="toc-number">8.3.</span> <span class="toc-text">新的STL方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#valarray-升级"><span class="toc-number">8.4.</span> <span class="toc-text">valarray 升级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#摒弃-export"><span class="toc-number">8.5.</span> <span class="toc-text">摒弃 export</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尖括号"><span class="toc-number">8.6.</span> <span class="toc-text">尖括号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#移动语义和右值引用"><span class="toc-number">9.</span> <span class="toc-text">移动语义和右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#包装器"><span class="toc-number">9.1.</span> <span class="toc-text">包装器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可变参数模版"><span class="toc-number">9.2.</span> <span class="toc-text">可变参数模版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并行编程"><span class="toc-number">9.3.</span> <span class="toc-text">并行编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#待续"><span class="toc-number">10.</span> <span class="toc-text">待续</span></a></li></ol>
      <div class="toc-tip">Table of Contents ▼</div>
    </div>
  


  <div class="container">
    <article>
      <h1>C++11（待续</h1>
      <h2 id="新类型"><a href="#新类型" class="headerlink" title="新类型"></a>新类型</h2><p>long long / unsigned long long</p>
<p>char16_t / char32_t</p>
<p>原始字符串</p>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>c++11扩大了初始化列表的适用范围，使其可以用于所有内置类型和用户定义的类。</p>
<p>提供了模版类initializer_list，STL提供了将其作为参数的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">double</span>&gt; il)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">double</span>&gt; il = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum(dl) &lt;&lt; sum(&#123;<span class="number">1.1</span>, <span class="number">2.2</span> ,<span class="number">3.3</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">double</span>&gt; il)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p = il.begin(); p != il.end(); ++p)</span><br><span class="line">        total += *p;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>PS：</strong></p>
<ul>
<li>可按值传递也可按引用传递 initializer_list，没有什么大的性能差别。</li>
<li>它的迭代器类型为 const，所以不能修改值。</li>
<li>初始化列表能防止缩窄。</li>
</ul>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>由存储类型说明符变为自动类型推断。</p>
<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>将变量的类型声明为表达式指定的类型。<code>decltype(x) y</code>将y声明为x的类型。</p>
<h3 id="返回后置类型"><a href="#返回后置类型" class="headerlink" title="返回后置类型"></a>返回后置类型</h3><p>常规函数使用这个没有意义，但对于模版函数来说很有用，如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto eff(T t, U u) -&gt; decltype(T*U)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为在编译器遇到eff的参数列表前，T和U还不在作用域内，所以必须在参数列表后使用decltype。</p>
<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>constexpr是C++11中新增的关键字，其语义是“常量表达式”，也就是在编译期可求值的表达式。最基础的常量表达式就是字面值或全局变量/函数的地址或sizeof等关键字返回的结果，而其它常量表达式都是由基础表达式通过各种确定的运算得到的。constexpr值可用于enum、switch、数组长度等场合。</p>
<p>constexpr所修饰的变量一定是编译期可求值的，所修饰的函数在其所有参数都是constexpr时，一定会返回constexpr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">constexpr</span>` `<span class="keyword">int</span>` `Inc(``<span class="keyword">int</span>` `i) &#123;``    ``<span class="keyword">return</span>` `i + <span class="number">1</span>;``&#125;` `<span class="keyword">constexpr</span>` `<span class="keyword">int</span>` `a = Inc(<span class="number">1</span>); ``<span class="comment">// ok``constexpr` `int` `b = Inc(cin.get()); ``// !error``constexpr` `int` `c = a * 2 + 1; ``// ok`</span></span><br></pre></td></tr></table></figure>
<p>constexpr还能用于修饰类的构造函数，即保证如果提供给该构造函数的参数都是constexpr，那么产生的对象中的所有成员都会是constexpr，该对象也就是constexpr对象了，可用于各种只能使用constexpr的场合。注意，<strong>constexpr构造函数必须有一个空的函数体，即所有成员变量的初始化都放到初始化列表中。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="class"><span class="keyword">struct</span>` `<span class="title">A</span> &#123;</span>``    ``<span class="keyword">constexpr</span>` `A(``<span class="keyword">int</span>` `xx, ``<span class="keyword">int</span>` `yy): x(xx), y(yy) &#123;&#125;``    ``<span class="keyword">int</span>` `x, y;``&#125;;` `<span class="keyword">constexpr</span>` `<span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;``<span class="keyword">enum</span>` `&#123;SIZE_X = a.x, SIZE_Y = a.y&#125;;`</span><br></pre></td></tr></table></figure>
<p><strong>好处</strong>：</p>
<ol>
<li>是一种很强的约束，更好地保证程序的正确语义不被破坏。</li>
<li>编译器可以在编译期对constexpr的代码进行非常大的优化，比如将用到的constexpr表达式都直接替换成最终结果等。</li>
<li>相比宏来说，没有额外的开销，但更安全可靠。</li>
</ol>
<h3 id="模版别名：using"><a href="#模版别名：using" class="headerlink" title="模版别名：using="></a>模版别名：using=</h3><p>可以部分具体化模版，但typedef就不行。</p>
<h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>为向后兼容，nullptr==0 为true。</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>摒弃了auto_ptr，新增了三种：unique_ptr , shared_ptr , weak_ptr 。</p>
<h2 id="异常规范"><a href="#异常规范" class="headerlink" title="异常规范"></a>异常规范</h2><p>摒弃了异常规范，添加了关键字noexcept来指出函数不回引发异常。</p>
<h2 id="作用域内枚举"><a href="#作用域内枚举" class="headerlink" title="作用域内枚举"></a>作用域内枚举</h2><p>使用class或struct定义的枚举，需要使用作用域解析运算符，可以避免发生名称冲突</p>
<h2 id="对类的修改"><a href="#对类的修改" class="headerlink" title="对类的修改"></a>对类的修改</h2><h3 id="显式转换运算符explicit"><a href="#显式转换运算符explicit" class="headerlink" title="显式转换运算符explicit"></a>显式转换运算符explicit</h3><p>本来是禁止单参数构造函数导致的自动转换，c++11扩展了这种用法，使其可对转换函数做类似的处理。</p>
<p><code>explicit operator double() const;</code></p>
<h3 id="类内成员初始化"><a href="#类内成员初始化" class="headerlink" title="类内成员初始化"></a>类内成员初始化</h3><p>可以使用等号或大括号版本的初始化，但不能使用圆括号版本的初始化。</p>
<p>如果构造函数在成员初始化列表中提供了相应的值，这些默认值将被覆盖。</p>
<h2 id="模版和STL的修改"><a href="#模版和STL的修改" class="headerlink" title="模版和STL的修改"></a>模版和STL的修改</h2><h3 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h3><p><code>for(auto x : ss)</code></p>
<h3 id="新的STL容器"><a href="#新的STL容器" class="headerlink" title="新的STL容器"></a>新的STL容器</h3><p>单向链表 forward_list</p>
<p>无序集合 unordered_map、unordered_multimap、unordered_set、unordered_multiset。</p>
<p>array模版</p>
<h3 id="新的STL方法"><a href="#新的STL方法" class="headerlink" title="新的STL方法"></a>新的STL方法</h3><p>cbegin()和cend()、crbegin()和crend()。是对应于原来的const版本。</p>
<h3 id="valarray-升级"><a href="#valarray-升级" class="headerlink" title="valarray 升级"></a>valarray 升级</h3><p>为它提供了begin() 和 end()</p>
<h3 id="摒弃-export"><a href="#摒弃-export" class="headerlink" title="摒弃 export"></a>摒弃 export</h3><p>摈弃了C++98的关键字export，但仍保留了以供以后使用。</p>
<h3 id="尖括号"><a href="#尖括号" class="headerlink" title="尖括号"></a>尖括号</h3><p>以前嵌套模版的&gt;&gt;可能会引起歧义，需要分开来，现在不需要了。</p>
<h2 id="移动语义和右值引用"><a href="#移动语义和右值引用" class="headerlink" title="移动语义和右值引用"></a>移动语义和右值引用</h2><p>用&amp;&amp;表明右值引用。将右值关联到右值引用将导致该右值被存储到特定的位置，且可以获取该位置的地址，然后可以将&amp;用于右值引用变量。</p>
<p>可以创建以右值引用为参数的移动构造函数和移动赋值函数。</p>
<p>即使没有定义移动构造函数，智能的编译器（如g++）会自动使用移动语义来优化程序。</p>
<p>以一个数组构造函数为列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Useless::Useless(Useless &amp;&amp; f) : n(f.n) &#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    pc = f.pc;</span><br><span class="line">    f.pc = <span class="literal">nullptr</span>;</span><br><span class="line">    f.n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="包装器"><a href="#包装器" class="headerlink" title="包装器"></a>包装器</h3><h3 id="可变参数模版"><a href="#可变参数模版" class="headerlink" title="可变参数模版"></a>可变参数模版</h3><h3 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程"></a>并行编程</h3><h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
  </article>
    
  </div>
</div>

    <footer class="main-footer">
  <div class="container">
    © 2018 
  </div>
</footer>
    



<script src="/./runtime.32f029.js"></script><script src="/./vendor.ec1199.js"></script><script src="/./app.5ed5af.js"></script>


  </body>
</html>
