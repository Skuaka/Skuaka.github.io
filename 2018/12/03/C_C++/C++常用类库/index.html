<!DOCTYPE html>
<html lang="zh-cmn-Hans">
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <meta http-equiv="”Cache-Control”" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  
  <title>C++常用类库 | Skuaka</title>
  <link rel="icon" type="image/png" sizes="32x32" href>
  



<link rel="stylesheet" href="/./vendor.ec1199.css"><link rel="stylesheet" href="/./app.5ed5af.css">


</head>
  <body>
    <header class="main-header">
  <div class="container">
    <a href="/" " class="logo">
      <img src="logo.jpg" alt="Skuaka" class="logo-img">
    </a>
    <span class="nav-separator"></span>
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索文章"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
    <a href="javascript:void(0);" class="nav-icon">
      <i class="fas fa-bars"></i>
    </a>
    <nav class="main-nav">
      <ul class="nav-list">
        
          <li class="nav-link ">
            <a href="/">首页</a>
          </li>
        
          <li class="nav-link ">
            <a href="/archives/">归档</a>
          </li>
        
          <li class="nav-link ">
            <a href="/categories">分类</a>
          </li>
        
          <li class="nav-link ">
            <a href="/about.html">关于</a>
          </li>
        
      </ul>
    </nav>
  </div>
</header>
    <div class="page--article">
  
    <div class="toc-container">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#string类"><span class="toc-number">1.</span> <span class="toc-text">string类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#头文件"><span class="toc-number">1.1.</span> <span class="toc-text">头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输入方式"><span class="toc-number">1.2.</span> <span class="toc-text">输入方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用方法"><span class="toc-number">1.3.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string对象的内存"><span class="toc-number">1.4.</span> <span class="toc-text">string对象的内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串种类"><span class="toc-number">1.5.</span> <span class="toc-text">字符串种类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#智能指针模版类"><span class="toc-number">2.</span> <span class="toc-text">智能指针模版类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#赋值的三种方法"><span class="toc-number">2.1.</span> <span class="toc-text">赋值的三种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#赋值运算符"><span class="toc-number">2.1.1.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#所有权模型"><span class="toc-number">2.1.2.</span> <span class="toc-text">所有权模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引用计数模型"><span class="toc-number">2.1.3.</span> <span class="toc-text">引用计数模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特殊事项"><span class="toc-number">2.2.</span> <span class="toc-text">特殊事项</span></a></li></ol></li></ol>
      <div class="toc-tip">Table of Contents ▼</div>
    </div>
  


  <div class="container">
    <article>
      <h1>C++常用类库</h1>
      <h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>使用头文件string（注意，string.h 和 cstring 支持对C-风格字符串进行操作，但不支持string类）</p>
<h3 id="输入方式"><a href="#输入方式" class="headerlink" title="输入方式"></a>输入方式</h3><ul>
<li><p>对于C-风格字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> info[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; info;</span><br><span class="line"><span class="built_in">cin</span>.getline(info, <span class="number">100</span>);	<span class="comment">//discard '\n'</span></span><br><span class="line"><span class="built_in">cin</span>.get(info, <span class="number">100</span>);		<span class="comment">//leave '\n' in queue</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于string对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> stuff;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; stuff;</span><br><span class="line">getline(<span class="built_in">cin</span>,stuff);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>两个版本的getline都有一个可选参数，用于确定边界字符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>.getline(info, <span class="number">100</span>, <span class="string">':'</span>);	<span class="comment">//read up to ':',discard ':'</span></span><br><span class="line">getline(info, <span class="string">':'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li><p>size()和length()都返回字符串中的字符数。</p>
<p>length来自较早版本的string类，而size是为提供STL兼容性添加的。</p>
</li>
<li><p>find(). refind(). find_first_of(). find_last_of(). find_first_not_of(). find_last_not_of()</p>
</li>
<li><p>c_str()方法返回一个指向C-风格字符串的指针，这样就可以使用C-风格函数。</p>
<p>data()方法和c_str()类似，不过没有结尾的空字符。</p>
</li>
</ul>
<h3 id="string对象的内存"><a href="#string对象的内存" class="headerlink" title="string对象的内存"></a>string对象的内存</h3><p>当扩大字符串时，字符串相邻的内存块可能已经被占用了，所以程序要分配一个新的内存块，并将原来的内容复制过去。如果大量执行如此操作，效率极低。</p>
<p>很多C++实现为增加效率，会分配比实际字符串大的内存块，为字符串提供增大空间。</p>
<p>然而，如果字符串增大到超过了内存块的大小，程序将分配一个大小为元来两倍的新内存块。</p>
<h3 id="字符串种类"><a href="#字符串种类" class="headerlink" title="字符串种类"></a>字符串种类</h3><p>string类其实是一个基于模版的具体化，一共有四种具体化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="title">class</span> <span class="title">traits</span> = <span class="title">char</span> _<span class="title">traits</span>&lt;charT&gt;,</span></span><br><span class="line"><span class="class">		<span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;charT&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">basic_string</span> &#123;</span>…&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="keyword">char</span>&gt; <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="keyword">wchar_t</span>&gt; wstring;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="keyword">char16_t</span>&gt; u16string;	<span class="comment">//C++11</span></span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="keyword">char32_t</span>&gt; u32string;	<span class="comment">//C++11</span></span><br></pre></td></tr></table></figure>
<h2 id="智能指针模版类"><a href="#智能指针模版类" class="headerlink" title="智能指针模版类"></a>智能指针模版类</h2><p>auto_ptr</p>
<p>c++11 ：unique_ptr   shared_ptr</p>
<ul>
<li><p>将原程序换成智能指针的步骤</p>
<ol>
<li>包含头文件memory</li>
<li>替换指针</li>
<li>删除delete语句</li>
</ol>
</li>
</ul>
<h3 id="赋值的三种方法"><a href="#赋值的三种方法" class="headerlink" title="赋值的三种方法"></a>赋值的三种方法</h3><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>定义赋值运算符，使之进行深复制。</p>
<h4 id="所有权模型"><a href="#所有权模型" class="headerlink" title="所有权模型"></a>所有权模型</h4><p>auto_ptr和unique_ptr采用所有权模型，但是unique_ptr会在编译阶段就报错，所以已经取代了auto_ptr。</p>
<p>  具体规则是：程序试图将一个unique_ptr赋给另一个时，如果源unique_ptr是一个临时右值，编译器允许这样做；如果源unque_ptr将存在一段时间，编译器将禁止这样做。否则会造成多次使用delete。</p>
<h4 id="引用计数模型"><a href="#引用计数模型" class="headerlink" title="引用计数模型"></a>引用计数模型</h4><p>shared_ptr在赋值时，计数加一，指针过期时，计数减一；当最后一个指针过期时，才调用delete。</p>
<h3 id="特殊事项"><a href="#特殊事项" class="headerlink" title="特殊事项"></a>特殊事项</h3><ul>
<li>只有unique_ptr有使用new[ ]和delete[ ]的版本。其他两个只有new和delete。</li>
</ul>
<ul>
<li>在unique_ptr为临时右值时，可以赋给shared_ptr。模版shared_ptr包含一个显示构造函数，可以将unique_ptr转化为shared_ptr。</li>
<li>std::move( )可以将一个unique_ptr指针赋给另一个。它使用了C++11的移动构造函数和右值引用。</li>
</ul>

  </article>
    
  </div>
</div>

    <footer class="main-footer">
  <div class="container">
    © 2018 
  </div>
</footer>
    



<script src="/./runtime.32f029.js"></script><script src="/./vendor.ec1199.js"></script><script src="/./app.5ed5af.js"></script>


  </body>
</html>
