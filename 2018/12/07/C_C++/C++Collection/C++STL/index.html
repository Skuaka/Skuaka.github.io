<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="Skuaka">



<meta name="description" content="标准模板库STL 提供了一组表示容器、迭代器、函数对象、算法的模板。">
<meta name="keywords" content="C&#x2F;C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ STL">
<meta property="og:url" content="http://skuaka.cn/2018/12/07/C_C++/C++Collection/C++STL/index.html">
<meta property="og:site_name" content="Skuaka">
<meta property="og:description" content="标准模板库STL 提供了一组表示容器、迭代器、函数对象、算法的模板。">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-03-07T12:49:34.084Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ STL">
<meta name="twitter:description" content="标准模板库STL 提供了一组表示容器、迭代器、函数对象、算法的模板。">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Skuaka" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/avatar.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>C++ STL | Skuaka</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Skuaka</a></h1>
        </hgroup>

        
        <p class="header-subtitle">For you, a thousand times over.</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">Home</a></li>
                        
                            <li><a href="/archives/">Archives</a></li>
                        
                            <li><a href="/tags/">Tags</a></li>
                        
                            <li><a href="/about/">about</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C-操作系统/">-C/C++ -操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCIE/">CCIE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DDos/">DDos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS-BFS/">DFS,BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DTD/">DTD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DoNotStarve/">DoNotStarve</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dreamweaver/">Dreamweaver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kali/">Kali</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Macos/">Macos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MetaProgram/">MetaProgram</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mp3/">Mp3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenGL/">OpenGL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Perl/">Perl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL/">PostgreSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QT/">QT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Raspberrypi/">Raspberrypi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLserver/">SQLserver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Socks5/">Socks5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sorting/">Sorting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tcp-ip/">Tcp/ip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tree/">Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wifi/">Wifi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wireshark/">Wireshark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/base64/">base64</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/epoll/">epoll</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcc-gdb/">gcc,gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reactor/">reactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vultr/">vultr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a></li></ul>
                    </div>
                </section>
                
                
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Skuaka</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Skuaka</a></h1>
            </hgroup>
            
            <p class="header-subtitle">For you, a thousand times over.</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">Home</a></li>
                
                    <li><a href="/archives/">Archives</a></li>
                
                    <li><a href="/tags/">Tags</a></li>
                
                    <li><a href="/about/">about</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:skuaka@icloud.com" title="Email"></a>
                            
                                <a class="fa bilibili" target="_blank" href="https://space.bilibili.com/5006495" title="bilibili"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me">
</nav>
      <div class="body-wrap"><article id="post-C_C++/C++Collection/C++STL" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/07/C_C++/C++Collection/C++STL/" class="article-date">
      <time datetime="2018-12-07T12:51:15.000Z" itemprop="datePublished">2018-12-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++ STL
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="标准模板库"><a href="#标准模板库" class="headerlink" title="标准模板库"></a>标准模板库</h2><p>STL 提供了一组表示容器、迭代器、函数对象、算法的模板。</p>
<a id="more"></a>
<p>STL 容器是同质的，即存储的值的类型相同。</p>
<h3 id="杂项记录"><a href="#杂项记录" class="headerlink" title="杂项记录"></a>杂项记录</h3><h4 id="Allocator"><a href="#Allocator" class="headerlink" title="Allocator"></a>Allocator</h4><p>各种STL容器模板都接受一个可选的模板参数，指定使用哪个分配器来管理内存。</p>
<p>默认使用 <code>allocator&lt;T&gt;</code> 类，这个类使用 new 和 delete。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class">	<span class="title">class</span> <span class="title">vector</span> &#123;</span>...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h3><p>对于已有的通用方法，类也有可能重新定义成员方法。因为针对特殊元素的成员方法一般比通用方法效率高。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a.size();	<span class="comment">//返回元素数目</span></span><br><span class="line">a.swap(b);	<span class="comment">//交换两个容器的内容</span></span><br><span class="line"></span><br><span class="line">a.begin();	<span class="comment">//返回指向容器中第一个元素的迭代器</span></span><br><span class="line">a.end();	<span class="comment">//返回一个表示超过容器尾的迭代器</span></span><br><span class="line">a.cbegin();	<span class="comment">//c++11 const迭代器</span></span><br><span class="line">a.cend();	<span class="comment">//c++11 const迭代器</span></span><br><span class="line"></span><br><span class="line">copy(it1, it2, it3);	<span class="comment">//前两个参数表示要复制的范围(输入迭代器)，第三个参数表示复制到的位置(输出迭代器)。</span></span><br><span class="line"></span><br><span class="line">for_each(it1, it2, pfun);	<span class="comment">//替换for循环，对指定区间每个元素使用函数对象。不能修改元素值。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x: books)&#123;*pfun(x)&#125;;	<span class="comment">//基于范围的for能修改元素值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*__需要支持随机访问__*/</span></span><br><span class="line"><span class="comment">//随机排列区间中的元素</span></span><br><span class="line">random_shuffle(it1, it2);</span><br><span class="line"><span class="comment">//排列指定区间，默认按照 &lt; 运算符，或者函数对象(接收两个元素引用，返回值bool，false表示顺序不对)</span></span><br><span class="line">sort(it1, it2[, pfun] );</span><br></pre></td></tr></table></figure>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是广义指针。让 STL 能够为不同的容器类提供统一的接口。</p>
<p>每个类都定义了一个合适的迭代器，该迭代器的类型是一个名为 iterator 的 typedef，其作用域为整个类。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::iterator pd;<span class="comment">// pd an iterator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器的行为就像指针</span></span><br><span class="line"><span class="keyword">auto</span> pd = scores.begin(); <span class="comment">// c++ automatic tyoe deduction</span></span><br><span class="line">*pd = <span class="number">22.3</span>;</span><br><span class="line">++pd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(pd = scores.begin(); pd != scores.end(); ++pd)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pd &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h4 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h4><p>不同的算法对迭代器的要求也不同。STL定义了5种迭代器，并根据所需要的类型对算法进行了描述。</p>
<p>例如，find()的原型与下面类似，指出了算法需要一个输入迭代器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>);</span></span><br></pre></td></tr></table></figure>
<h5 id="输入迭代器"><a href="#输入迭代器" class="headerlink" title="输入迭代器"></a>输入迭代器</h5><ul>
<li>术语“输入”是从程序的角度说的，即来自容器的信息被视为输入。</li>
<li>不能修改元素。</li>
<li><p>必须能够访问容器中所有元素，通过支持两种形式的++运算符。</p>
</li>
<li><p>并不能保证第二次遍历容器时，顺序不变。</p>
</li>
<li>是单向迭代器，可以递增，但不能倒退。</li>
</ul>
<h5 id="输出迭代器"><a href="#输出迭代器" class="headerlink" title="输出迭代器"></a>输出迭代器</h5><ul>
<li><p>术语“输出”指用于将信息从程序传输给容器。</p>
</li>
<li><p>只能解引用修改容器值，不能读取。</p>
<p>这点可能很奇怪。其实类似的，发送到显示器上的输出就是如此，cout 可以修改发送到显示器的字符流，却不能读取屏幕上的内容。STL足够通用，其容器可以表示输出设备。</p>
</li>
<li><p>单向迭代器。</p>
</li>
</ul>
<p>简而言之：对于单通行、只读算法，可以使用输入迭代器；单通行、只写，输出迭代器。</p>
<h5 id="正向迭代器"><a href="#正向迭代器" class="headerlink" title="正向迭代器"></a>正向迭代器</h5><ul>
<li><p>只使用++运算符来遍历容器，与输入、输出迭代器不同的是，它总是按相同的顺序遍历。</p>
<p>另外，将正向迭代器递增后，仍然可以对前面的迭代器值解引用，并得到相同的值。</p>
</li>
<li><p>即可以读写，也可以只读：</p>
<p><code>int * pitrw;</code>    <code>const int * pitr;</code></p>
</li>
</ul>
<h5 id="双向迭代器"><a href="#双向迭代器" class="headerlink" title="双向迭代器"></a>双向迭代器</h5><ul>
<li>具有正向迭代器的所有特性，并支持两种递减运算符。</li>
</ul>
<p>比如 reverse() 函数，交换第一个和最后一个元素，并将指向第一个元素的指针加一、指向最后的减一，并重复这种过程。</p>
<h5 id="随机访问迭代器"><a href="#随机访问迭代器" class="headerlink" title="随机访问迭代器"></a>随机访问迭代器</h5><ul>
<li>有些算法要求能够直接跳到容器中的任何一个元素，这叫做随机访问。</li>
<li>随机访问拥有双向迭代器的所有特性，并且支持随机访问（如指针增加运算）和用于对元素进行排序的关系运算符。</li>
</ul>
<h4 id="将指针用作迭代器"><a href="#将指针用作迭代器" class="headerlink" title="将指针用作迭代器"></a>将指针用作迭代器</h4><ul>
<li>指针满足所有迭代器要求。</li>
</ul>
<h4 id="迭代器的输入输出适配器"><a href="#迭代器的输入输出适配器" class="headerlink" title="迭代器的输入输出适配器"></a>迭代器的输入输出适配器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="comment">// *** ostream_iterator ***</span></span><br><span class="line"><span class="comment">// 第一个模板参数指出了被发送给输出流的数据类型</span></span><br><span class="line"><span class="comment">// 第二个模板参数指出输出流使用的字符类型&#123;char, wchar_t&#125;</span></span><br><span class="line"><span class="comment">// 构造函数的第一个参数指出了要用的输出流，可以是文件流</span></span><br><span class="line"><span class="comment">// 构造函数的第二个参数是发送给输出流的每个项后的分隔符</span></span><br><span class="line">ostream_iterator&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; out_iter(<span class="built_in">cout</span>, <span class="string">" "</span>);</span><br><span class="line">copy(dice.begin(), dice.end(), out_iter);	<span class="comment">// copy vector to output stream</span></span><br><span class="line"><span class="comment">// 也可使用匿名迭代器</span></span><br><span class="line">copy(dice.begin(), dice.end(), ostream_iterator&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// *** istream_iterator ***</span></span><br><span class="line"><span class="comment">// 第一个模板参数指出要读取的数据类型</span></span><br><span class="line"><span class="comment">// 第二个模板参数指出输入流使用的字符类型&#123;char, wchar_t&#125;</span></span><br><span class="line"><span class="comment">// 构造函数参数标书使用的输入流，如果省略参数表示输入失败。</span></span><br><span class="line">copy(istream_iterator&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;(<span class="built_in">cin</span>), </span><br><span class="line">    istream_iterator&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;(), dice.begin());	</span><br><span class="line"><span class="comment">//从输入流读取，直到文件结尾、类型不匹配或其他输入故障</span></span><br></pre></td></tr></table></figure>
<h4 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h4><ul>
<li>对 reverse_iterator 执行<strong>递增</strong>操作将导致它被<strong>递减</strong>。</li>
</ul>
<p>vector 类有名为 rbegin() 和 rend() 的成员函数，分别返回指向超尾和第一个元素的反向迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(dice.rbegin(), dice.rend(), out_iter);	<span class="comment">// display in reverse order</span></span><br></pre></td></tr></table></figure>
<p>反向指针通过”先递减、再解引用”来访问到每一个项。</p>
<h4 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h4><p>插入将添加新的元素，而不会覆盖已有的数据，并使用自动内存分配来确保能容纳新的元素。</p>
<p><strong>三种类型</strong>：</p>
<ul>
<li>back_insert_iterator 将元素插入到容器尾部</li>
<li>front_insert_iterator 将元素插入到容器前端</li>
<li>insert_iterator 将元素插入到构造函数指定的位置的前面</li>
</ul>
<p><strong>使用</strong>：</p>
<ul>
<li><p>将容器作为模板参数，将实际的容器标识符作为构造函数参数。</p>
<p><code>back_insert_iterator&lt;vector&lt;int&gt; &gt; back_iter(dice);</code></p>
<p>back_insert_iterator 将假定传递给它的类型有一个 push_back() 方法。</p>
</li>
<li><p>对于 insert_iterator ，还需要一个指示插入位置的构造函数参数：</p>
<p><code>insert_iterator&lt;vector&lt;int&gt; &gt; back_iter(dice, dice.begin() );</code></p>
</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>back_insert_iterator 只能用于允许在尾部快速插入的容器(时间固定的算法)，vector符合</li>
<li>front_insert_iterator 只能用于允许在起始位置做时间固定插入的容器，vector不符合，但queue满足</li>
<li>insert_iterator 没有这些限制，可以用它来插入到 vector 前端，但速度慢。</li>
</ul>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul>
<li><p>STL具有容器概念和容器类型。</p>
<p><strong>容器概念</strong>是具有相同名称（如容器、序列容器、关联容器等）的通用类别；</p>
<p><strong>容器类型</strong>是可用于创建具体容器对象的模板。</p>
</li>
<li><p>容器是存储其他对象的对象。被存储的对象必须是<strong>同类型</strong>的，可以是内置类型值。</p>
</li>
<li><p>不是任何类型的对象都能存储在容器中。</p>
<p>类型必须是可复制构造的和可赋值的。</p>
<p>基本类型满足要求；只要类定义没有将复制构造函数和赋值运算符声明为私有的，也满足要求。</p>
</li>
</ul>
<p><strong>基本的容器特征</strong></p>
<ol>
<li>上文介绍的STL通用方法</li>
<li><code>X::iterator</code> 指向 T 的迭代器类型。要求：满足正向迭代器的任何迭代器。</li>
<li><code>X::value_type</code> T 的类型。</li>
</ol>
<h4 id="所有容器"><a href="#所有容器" class="headerlink" title="所有容器"></a>所有容器</h4><p><strong>11个基本容器</strong>：</p>
<p>deque、list、</p>
<p>queue、priority_queue、</p>
<p>stack、vector、</p>
<p>map、multimap、</p>
<p>set、multiset、bitset。</p>
<p><strong>5个c++11新增</strong>：</p>
<p>forward_list、</p>
<p>unordered_map、unordered_multimap、</p>
<p>unordered_set、unordered_multiset。</p>
<h4 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h4><p><strong>7种容器</strong>：</p>
<p>deque、queue、priority_queue、</p>
<p>list、forward_list (c++11)、</p>
<p>stack、vector 。</p>
<p><strong>要求</strong>：</p>
<ul>
<li><p>正向迭代器（保证了元素按特定顺序排列，不会在两次迭代之间发生变化）</p>
</li>
<li><p>线性顺序（树的分支结构就不是）</p>
</li>
</ul>
<p><strong>通用成员</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">a</span><span class="params">(n,t)</span></span>;	<span class="comment">// 声明一个名为a的由n个t值组成的序列</span></span><br><span class="line"><span class="function">X <span class="title">a</span><span class="params">(i,j)</span></span>;	<span class="comment">// 声明并初始化为区间[i,j)的内容</span></span><br><span class="line"></span><br><span class="line">a.insert(p,t);	<span class="comment">// 将t插入到p的前面。返回迭代器。</span></span><br><span class="line">a.insert(p,n,t);<span class="comment">// 将n个t插入到p的前面。返回void。</span></span><br><span class="line">a.insert(p,i,j);<span class="comment">// 将区间[i,j)中的元素插入到p的前面。返回void。</span></span><br><span class="line"></span><br><span class="line">a.erase(p);		<span class="comment">// 删除p指向的元素。返回迭代器。</span></span><br><span class="line">a.erase(p,q);	<span class="comment">// 删除区间[p,q)中的元素。返回迭代器。</span></span><br><span class="line">a.clear();		<span class="comment">// 等价于 erase(begin(), end() )</span></span><br></pre></td></tr></table></figure>
<p><strong>可选成员</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*表达式*/</span>		<span class="comment">/*返回类型*/</span>	<span class="comment">/*含义*/</span>			<span class="comment">/*容器*/</span></span><br><span class="line">a.front();		  T&amp;		*a.begin()		<span class="built_in">list</span>、<span class="built_in">deque</span>、<span class="built_in">vector</span></span><br><span class="line">a.back();		  T&amp;		*--a.end()		<span class="built_in">list</span>、<span class="built_in">deque</span>、<span class="built_in">vector</span></span><br><span class="line">a.push_front(t);  <span class="keyword">void</span>						<span class="built_in">list</span>、<span class="built_in">deque</span>、</span><br><span class="line">a.push_back(t);	  <span class="keyword">void</span>						<span class="built_in">list</span>、<span class="built_in">deque</span>、<span class="built_in">vector</span></span><br><span class="line">a.pop_front(t);   <span class="keyword">void</span>						<span class="built_in">list</span>、<span class="built_in">deque</span>、</span><br><span class="line">a.pop_back(t);    <span class="keyword">void</span>						<span class="built_in">list</span>、<span class="built_in">deque</span>、<span class="built_in">vector</span></span><br><span class="line">a[n]			  T&amp;						    、<span class="built_in">deque</span>、<span class="built_in">vector</span></span><br><span class="line">a.at(n)			  T&amp;						    、<span class="built_in">deque</span>、<span class="built_in">vector</span></span><br><span class="line"><span class="comment">//at(n)和a[n]区别在于会检查n是否合法。必要时引发out_of_range异常。</span></span><br></pre></td></tr></table></figure>
<h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><p>简单地说，vector是数组的一种类表示。</p>
<p>除序列外，vector还是<strong>可反转容器概念</strong>的模型，增加了<code>rbegin()</code>和<code>rend()</code>。</p>
<p>vector 是最简单的序列类型，除非其他类型的特殊优点能更好地满足程序的要求，否则应默认使用这种类型。</p>
<h5 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h5><p>双端列队</p>
<p>和vector差不多。</p>
<p>主要区别：从deque的开始位置插入和删除元素的时间是固定的，而不像vector是线性的。</p>
<h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p>双向链表</p>
<p>可反转容器，不支持随机访问。</p>
<p>vector 强调的是通过随机访问进行快速访问，而 list 强调的是元素的快速插入和删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将链表x与调用链表合并。</span></span><br><span class="line"><span class="comment">//1.两个链表必须已经排序。</span></span><br><span class="line"><span class="comment">//2.合并后的经过排序的链表存在调用链表中，x清空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">list</span>&lt;T,Alloc&gt;&amp; x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从链表中删除val的所有实例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span>;</span><br><span class="line"><span class="comment">// 如果谓词返回true,删除这些元素</span></span><br><span class="line">scores.remove_if(tooBig);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用&lt;运算符对链表进行排序。O(NlogN)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表x的内容插入到pos的前面，x清空</span></span><br><span class="line"><span class="comment">// 和insert()的区别在于：splice()是移动原内容，insert()是插入副本。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator pos, <span class="built_in">list</span>&lt;T,Alloc&gt; x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将连续的相同元素压缩为单个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unique</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sort()、merge()、unique() 还各自拥有接受另一个参数的版本，该参数用于指定用来比较元素的函数。</span></span><br><span class="line"><span class="comment">   remove() 也可以有另一个参数，用于确定是否删除元素的函数。</span></span><br><span class="line"><span class="comment">   这些参数都是谓词函数。 */</span></span><br></pre></td></tr></table></figure>
<p>用途举例：</p>
<p>假如有两个邮件列表要整理，可以对每个列表进行排序，合并它们，然后删除重复的元素。</p>
<h5 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h5><p>单链表</p>
<p>不可反转，只需要正向迭代器。</p>
<h5 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h5><p>队列</p>
<p>是一个适配器类，底层默认还是 deque。</p>
<p>不允许随机访问，甚至不允许遍历。</p>
<p>操作被限制在定义队列的基本操作上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span> </span>;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span><span class="keyword">const</span> </span>;</span><br><span class="line"><span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>;	<span class="comment">// 队尾插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;		<span class="comment">// 队首弹出</span></span><br></pre></td></tr></table></figure>
<h5 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h5><p>优先队列</p>
<p>是另一个适配器类，默认的底层类是 vector。</p>
<p>支持的操作和 queue 相同。</p>
<p><strong>区别</strong>：</p>
<ul>
<li><p>最大的元素被移到队首。</p>
<p>可以修改确定哪个元素放到队首的比较方式，方法是提供一个可选的构造函数参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq1;				<span class="comment">// defult version</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq2(greater&lt;<span class="keyword">int</span>&gt;);	<span class="comment">// use greater&lt;int&gt; to order</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h5><p>栈</p>
<p>也是一个适配器类，默认底层是 vector。</p>
<p>不允许随机访问，甚至不允许遍历。</p>
<p>操作被限制在定义栈的基本操作上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span> </span>;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span><span class="keyword">const</span> </span>;</span><br><span class="line"><span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>;	<span class="comment">// 栈顶插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;				<span class="comment">// 栈顶弹出</span></span><br></pre></td></tr></table></figure>
<h5 id="array"><a href="#array" class="headerlink" title="array"></a>array</h5><p>不是STL容器，因为其长度是固定的。</p>
<p>头文件：<code>&lt;array&gt;</code></p>
<p>array没有定义调整容器大小的操作，但是定义了对它来说有意义的成员函数，比如 <code>operator[]()</code> 和 <code>at()</code></p>
<p>可以将很多STL算法用于array，比如<code>copy()</code> 和 <code>for_each()</code>。</p>
<h4 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h4><p><strong>4种容器</strong>：</p>
<p>set、multiset、</p>
<p>map、multimap。</p>
<p><strong>要求</strong>：</p>
<ul>
<li><p>关联容器将值与键关联在一起，并使用键来查找值。键被看做常量。</p>
</li>
<li><p>对于容器 X，<code>X::value_type</code> 指出存储在容器中的值类型；</p>
<p>对于关联容器，<code>X::key_type</code> 指出了键的类型。</p>
</li>
<li><p>关联容器通常是用树实现的，查找速度更快。</p>
</li>
</ul>
<p><strong>4种容器都有的性质</strong>：</p>
<ul>
<li>可反转的</li>
<li>本身就是排序的</li>
</ul>
<h5 id="multi-set"><a href="#multi-set" class="headerlink" title="(multi)set"></a>(multi)set</h5><p>值与键类型相同，对于set来说，值就是键。</p>
<p>multiset 类似于 set，区别是可以有多个值的键相同。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个模板参数是可选的，用来指示对键进行排序的比较函数或对象。默认用 less&lt;T&gt;</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; A;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>, greater&lt;<span class="built_in">string</span>&gt; &gt; A;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set_union、set_intersection、set_difference</span></span><br><span class="line"><span class="comment">// 分别查找并集、交集、差集。</span></span><br><span class="line"><span class="comment">// 接口：前两个迭代器定义了第一个集合的区间，后两个定义第二个区间，最后一个是输出迭代器。</span></span><br><span class="line">set_union(A.begin(), A.end(), B.begin(), B.end(),</span><br><span class="line">         ostream_iterator&lt;<span class="built_in">string</span>, <span class="keyword">char</span>&gt; out(<span class="built_in">cout</span>, <span class="string">" "</span>) );</span><br><span class="line"><span class="comment">// 假设要将结果放到集合C，而不是显示它，则最后一个参数应是一个指向C的迭代器。</span></span><br><span class="line"><span class="comment">// 首先想到用C.begin()，但是存在问题：</span></span><br><span class="line"><span class="comment">// 	1.关联容器的键是常量，所以 C.begin()是const迭代器，不能用作输出迭代器。</span></span><br><span class="line"><span class="comment">// 	2.与 copy() 相似，set_union() 将覆盖容器中已有的数据，并要求容器有足够的空间容纳新信息。</span></span><br><span class="line"><span class="comment">// 模板 insert_iterator 可解决这两个问题，它将复制转换为插入，还模拟了输出迭代器概念。</span></span><br><span class="line">set_union(A.begin(), A.end(), B.begin(), B.end(),</span><br><span class="line">         insert_iterator&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; &gt;(C, C.begin() ) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// lower_bound()、upper_bound()</span></span><br><span class="line"><span class="comment">// 将键作为参数并返回一个迭代器，该迭代器指向集合中第一个&#123;不小于,大于&#125;键参数的成员。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// insert()</span></span><br><span class="line"><span class="comment">// 因为排序决定了插入的位置，所以不需要指定插入位置</span></span><br></pre></td></tr></table></figure>
<h5 id="multi-map"><a href="#multi-map" class="headerlink" title="(multi)map"></a>(multi)map</h5><p>值与键类型不同</p>
<p>multimap 类似于 map，区别是可以有多个值的键相同。</p>
<ul>
<li><p>STL 使用模板 <code>pair&lt;class T, class U&gt;</code> 将建类型和数据类型存储到一个对象(<strong>值</strong>)中。</p>
<p>如果 keytype 是键类型， datatype 是存储的数据类型，则<strong>值类型</strong>为<code>pair&lt;const keytype, datatype&gt;</code></p>
</li>
<li><p>对于pair对象，可以使用 first 和 second 成员来访问其两部分</p>
<p><code>cout &lt;&lt; item.first &lt;&lt; &#39; &#39; &lt;&lt; item.second &lt;&lt; endl;</code></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板参数为：键类型，值类型，可选的排序比较函数或对象</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>, less&lt;<span class="keyword">int</span>&gt; &gt; codes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个pair，然后插入</span></span><br><span class="line">pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="built_in">string</span>&gt; item(<span class="number">213</span>, <span class="string">"Los"</span>);</span><br><span class="line">codes.insert(item);</span><br><span class="line"><span class="comment">// 或者直接插入匿名pair</span></span><br><span class="line">codes.insert(pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">213</span>, <span class="string">"Los"</span>));</span><br><span class="line"><span class="comment">// 或者使用数组表示法</span></span><br><span class="line">code[<span class="number">213</span>] = <span class="string">"Los"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count()</span></span><br><span class="line"><span class="comment">// 键作为参数，返回具有该键的元素数目。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lower_bound()、upper_bound()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// equal_range()</span></span><br><span class="line"><span class="comment">// 键作为参数，返回两个迭代器，它们表示的区间与该键匹配。</span></span><br><span class="line"><span class="comment">// 为了返回两个值，该方法将它们封装在一个 pair 对象中，它的两个模板参数都是迭代器。</span></span><br></pre></td></tr></table></figure>
<h4 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h4><p><strong>4种容器</strong>：</p>
<p>unordered_set、unordered_multiset、</p>
<p>unordered_map、unordered_multimap。</p>
<p><strong>区别</strong>：</p>
<ul>
<li><p>关联容器基于树结构，而无序关联容器基于哈希表。</p>
<p>这旨在提高添加和删除元素的速度以及查找算法的效率。</p>
</li>
</ul>
<h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><ul>
<li><p>很多STL算法都使用函数对象，也叫函数符（functor）。</p>
</li>
<li><p>函数符是可以以函数方式与( )结合使用的任意对象，包括：</p>
<p>函数名、指向函数的指针、重载了( )运算符的类对象</p>
</li>
</ul>
<h4 id="函数符概念"><a href="#函数符概念" class="headerlink" title="函数符概念"></a>函数符概念</h4><ul>
<li><p><strong>生成器</strong>（generator）：不用参数就可以调用的函数符</p>
</li>
<li><p><strong>一元函数</strong>（unary function）：一个参数</p>
</li>
<li><p><strong>二元函数</strong>（binary function）：两个参数</p>
</li>
</ul>
<hr>
<ul>
<li><strong>谓词</strong>（predicate）：返回bool值的一元函数</li>
<li><strong>二元谓词</strong>（binary predicate）：返回bool值的二元函数</li>
</ul>
<p>一些 STL 函数需要谓词参数。比如 sort。</p>
<h4 id="函数适配器概念"><a href="#函数适配器概念" class="headerlink" title="函数适配器概念"></a>函数适配器概念</h4><p>类函数符可以作为函数适配器，使函数能够满足不同的接口。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有一个接收两个参数的模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">bool</span> <span class="title">tooBig</span>(<span class="title">const</span> <span class="title">T</span> &amp; <span class="title">val</span>, <span class="title">const</span> <span class="title">T</span> &amp; <span class="title">lim</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> val &gt; lim;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以将它转化为单个参数的函数对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span>&#123;</span></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">        T cutoff;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        TooBig2(<span class="keyword">const</span> T &amp; t) : cutoff(t) &#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp; v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> tooBig&lt;T&gt;(v, cutoff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 就可以这样做</span></span><br><span class="line">TooBig2&lt;<span class="keyword">int</span>&gt; tB100&#123;<span class="number">100</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span>(tB100(x))	<span class="comment">//same as if(tooBig(x,100))</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="预定义函数符"><a href="#预定义函数符" class="headerlink" title="预定义函数符"></a>预定义函数符</h4><p>STL 定义了多个基本函数符，这是为了支持将函数符作为参数的 STL 函数。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transform(gr.begin(), gr.end(), out, <span class="built_in">sqrt</span>);</span><br><span class="line">transform(gr.begin(), gr.end(), m.begin(), out, plus&lt;<span class="keyword">double</span>&gt;());</span><br><span class="line"><span class="comment">//plus&lt;double&gt;构造函数构造了一个函数符，以完成相加运算，括号表示调用默认构造函数。</span></span><br></pre></td></tr></table></figure>
<p>头文件<code>functional</code>定义了多个模板函数对象。</p>
<h5 id="运算符和相应的函数符"><a href="#运算符和相应的函数符" class="headerlink" title="运算符和相应的函数符"></a>运算符和相应的函数符</h5><table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">函数符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">plus</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">minus</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">multiples</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">divides</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">modulus</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">negate</td>
</tr>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">equal_to</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">not_equal_to</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">greater</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">less</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center">greater_equal</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center">less_equal</td>
</tr>
<tr>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">logical_and</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">\</td>
<td></td>
<td>logical_or</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">logical_not</td>
</tr>
</tbody>
</table>
<h4 id="自适应函数符"><a href="#自适应函数符" class="headerlink" title="自适应函数符"></a>自适应函数符</h4><p>上面列出的预定义函数符都是自适应的。</p>
<ul>
<li><p><strong>原因</strong>：它携带了标识参数类型和返回类型的 typedef 成员。</p>
<p>这些成员分别是：result_type、first_argument_type、second_argument_type …</p>
</li>
<li><p><strong>意义</strong>：函数适配器对象可以使用函数对象，并认为存在这些typedef对象。</p>
<p>例如，接受一个自适应函数符参数的函数可以使用result_type成员来声明一个与函数的返回类型匹配的变量。</p>
</li>
</ul>
<h5 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h5><ul>
<li><p>STL 使用<strong><em>类</em></strong>  <strong>binder1st</strong> 和 <strong>binder2st</strong> 将自适应二元函数转换为自适应一元函数。</p>
<p>假设有一个自适应二元函数对象 f2()，则可以创建一个 binder1st 对象，该对象与一个将被用作 f2() 的第一个参数的特定值（val）相关联：</p>
<p><code>binder1st(f2, val) f1;</code></p>
</li>
<li><p>STL 提供了<strong><em>函数</em></strong>  <strong>bind1st</strong> 和 <strong>bind2st</strong> 简化使用。它们返回上述类对象。</p>
<p><code>transform(gr.begin(), gr.end(), out, bind1st(multiplies&lt;double&gt;(), 2.5))</code></p>
</li>
</ul>
<h4 id="lambda表达式-C-11"><a href="#lambda表达式-C-11" class="headerlink" title="lambda表达式 C++11"></a>lambda表达式 C++11</h4><p>提供了函数指针和函数符的替代品</p>
<p>待续。。。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li><p>算法都是内联的。</p>
</li>
<li><p>对于算法函数设计，首先，它们都使用模板来提供泛型；其次，它们都使用迭代器来提供访问容器中数据的通用表示。</p>
</li>
<li><p>可以用==来比较不同类型的容器，因为容器重载的==运算符使用迭代器来比较内容，因此如果deque对象和vector对象的内容相同并且顺序相同，则它们是相等的。</p>
</li>
<li><p>STL 将算法库分成4组：</p>
<ol>
<li>非修改式序列操作</li>
<li>修改式序列操作</li>
<li>排序和相关操作</li>
<li>通用数字运算</li>
</ol>
<p>前三组在头文件 algorithm 中，第四组在 numeric 中。</p>
</li>
<li><p><code>_copy</code></p>
<p><strong>就地算法</strong>在算法完成时，结果被放到原始数据的位置上；</p>
<p><strong>复制算法</strong>将结果发送到另一个位置。</p>
<p>STL的约定是：</p>
<ol>
<li>复制版本的名称以 <code>_copy</code> 结尾。</li>
<li>复制版本将接受一个额外的输出迭代器参数。</li>
<li>复制算法返回一个迭代器，该迭代器指向复制的最后一个值后面的位置。</li>
</ol>
</li>
<li><p><code>_if</code><br>有些函数有另一个版本，即根据将函数应用于容器元素得到的结果来执行操作。它们的名字以 <code>_if</code> 结尾。</p>
<p>它们需要一个额外的谓词参数：<code>&lt;..., class Predicate, ...&gt;</code></p>
<p>同样，STL使用诸如 Generator 和 BinaryPredicate 等术语来表示需要模拟其他函数对象概念的参数。</p>
</li>
<li><p>string类</p>
<p>string类虽然不是STL的组成部分，但设计它时考虑到了STL。例如它包含：<code>begin(),end(),rbegin(),rend()</code></p>
<p>获得区间内容的排列组合：<code>next_permutation()</code> 算法将区间内容转换为下一种排列方式。对于字符串，排列按照字母递增的顺序进行。如果成功，返回true；如果区间已处于最后的序列中，则返回false。</p>
</li>
</ul>
<h2 id="其他库"><a href="#其他库" class="headerlink" title="其他库"></a>其他库</h2><p>vector、valarray、array。</p>
<p>它们是由不同的小组开发的，用于不同目的。</p>
<p>vector 模板类是一个容器类和算法系统的一部分，它支持面向容器的操作。</p>
<p>valarray 模板类是面向数值计算的，不是STL的一部分。</p>
<p>array 是为替代内置数组而设计的，她通过提供更好、更安全的接口，让数组更紧凑、效率更高。很多STL算法也能使用。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>Title:</span><a href="/2018/12/07/C_C++/C++Collection/C++STL/">C++ STL</a></p>
        <p><span>Author:</span><a href="/" title="Back to Homepage">Skuaka</a></p>
        <p><span>Created:</span>2018-12-07, 20:51:15</p>
        <p><span>Updated:</span>2019-03-07, 20:49:34</p>
        <p>
            <span>Full URL:</span><a class="post-url" href="/2018/12/07/C_C++/C++Collection/C++STL/" title="C++ STL">http://skuaka.cn/2018/12/07/C_C++/C++Collection/C++STL/</a>
            <span class="copy-path" data-clipboard-text="From http://skuaka.cn/2018/12/07/C_C++/C++Collection/C++STL/　　By Skuaka" title="Copy Article&#39;s Link &amp; Author"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>License:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target="_blank">"CC BY-NC-SA 4.0"</a> Keep Link &amp; Author if Distribute.
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2018/12/15/Unix/Programming/Makefile学习/">
                    Makefile学习
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2018/12/07/Algorithm/查找树/">
                    查找树
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#标准模板库"><span class="toc-number">1.</span> <span class="toc-text">标准模板库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#杂项记录"><span class="toc-number">1.1.</span> <span class="toc-text">杂项记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Allocator"><span class="toc-number">1.1.1.</span> <span class="toc-text">Allocator</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通用方法"><span class="toc-number">1.2.</span> <span class="toc-text">通用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器"><span class="toc-number">1.3.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代器类型"><span class="toc-number">1.3.1.</span> <span class="toc-text">迭代器类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#输入迭代器"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">输入迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#输出迭代器"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">输出迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#正向迭代器"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">正向迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#双向迭代器"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">双向迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#随机访问迭代器"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">随机访问迭代器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将指针用作迭代器"><span class="toc-number">1.3.2.</span> <span class="toc-text">将指针用作迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代器的输入输出适配器"><span class="toc-number">1.3.3.</span> <span class="toc-text">迭代器的输入输出适配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反向迭代器"><span class="toc-number">1.3.4.</span> <span class="toc-text">反向迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插入迭代器"><span class="toc-number">1.3.5.</span> <span class="toc-text">插入迭代器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器"><span class="toc-number">1.4.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#所有容器"><span class="toc-number">1.4.1.</span> <span class="toc-text">所有容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#序列容器"><span class="toc-number">1.4.2.</span> <span class="toc-text">序列容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#vector"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">vector</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#deque"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">deque</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#list"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">list</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#forward-list"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">forward_list</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#queue"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">queue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#priority-queue"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">priority_queue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stack"><span class="toc-number">1.4.2.7.</span> <span class="toc-text">stack</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#array"><span class="toc-number">1.4.2.8.</span> <span class="toc-text">array</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关联容器"><span class="toc-number">1.4.3.</span> <span class="toc-text">关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#multi-set"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">(multi)set</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#multi-map"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">(multi)map</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无序关联容器"><span class="toc-number">1.4.4.</span> <span class="toc-text">无序关联容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数对象"><span class="toc-number">1.5.</span> <span class="toc-text">函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#函数符概念"><span class="toc-number">1.5.1.</span> <span class="toc-text">函数符概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数适配器概念"><span class="toc-number">1.5.2.</span> <span class="toc-text">函数适配器概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#预定义函数符"><span class="toc-number">1.5.3.</span> <span class="toc-text">预定义函数符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#运算符和相应的函数符"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">运算符和相应的函数符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自适应函数符"><span class="toc-number">1.5.4.</span> <span class="toc-text">自适应函数符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#函数适配器"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">函数适配器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda表达式-C-11"><span class="toc-number">1.5.5.</span> <span class="toc-text">lambda表达式 C++11</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法"><span class="toc-number">1.6.</span> <span class="toc-text">算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他库"><span class="toc-number">2.</span> <span class="toc-text">其他库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结束"><span class="toc-number">3.</span> <span class="toc-text">结束</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-5 i,
        .toc-level-5 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="Hide" title="Show or Hide Table of Contents">

    <script>
        yiliaConfig.toc = ["Hide", "Show", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"C++ STL　| Skuaka　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/12/15/Unix/Programming/Makefile学习/" title="Pre: Makefile学习">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="Mini Archives"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2018/12/07/Algorithm/查找树/" title="Next: 查找树">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/10/C_C++/C++Collection/C++string/">C++ string类</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/10/C_C++/C++Collection/C++强制类型转换/">C++强制类型转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/09/Operating System/浮点数存储法/">浮点数存储法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/09/C_C++/Tips/C_C++pow函数实现/">C_C++ pow函数实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/09/C_C++/C++Collection/c++杂类/">c++杂类(持续更新</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/08/C_C++/Tips/C++运算符优先级/">C运算符优先级</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/08/C_C++/C++Collection/C++虚函数表/">C++虚函数表</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/08/C_C++/Tips/结构体offsetof宏/">结构体offsetof宏 和 bit位测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/07/Database/Concept/mysql数据库引擎/">mysql数据库引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/07/Operating System/互斥锁-自旋锁-读写锁/">互斥锁 自旋锁 读写锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/07/Operating System/虚拟内存/">虚拟内存</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/06/C_C++/C++Collection/C++智能指针/">C++智能指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/06/C_C++/Concept_gcc/C程序内存区域/">C程序内存区域</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/05/Algorithm/LIS-最长上升子序列/">LIS 最长上升子序列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/04/Algorithm/LCS-最长公共子序列/">LCS (最长公共子序列)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/04/C_C++/C++Collection/Lambda表达式/">C++ Lambda表达式用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/02/OpenGl/OpenGL编程/">OpenGL编程(待续</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/02/OpenGl/OpenGL概念/">OpenGL概念(待续</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/02/QT/QT 贪吃蛇/">QT 贪吃蛇</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/QT/PaintEvent/">QT PaintEvent</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/C_C++/Tips/C语言小Tips/">C_tips</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/28/OpenGl/窗口视口/">窗口视口</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/28/Network/Tcp/TCP半关闭,半连接,半打开/">TCP 半关闭,半连接,半打开</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/27/Network/Tcp/Tcp_ip协议栈/">Tcp_ip协议栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/05/Unix/Command/内存cpu/">Linux 内存Cpu 查看</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/Unix/Command/tar/">Tar命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/Unix/Command/ln/">ln</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/Unix/Command/screen/">使用 screen 管理远程会话</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/Game/DoNotStarve/饥荒联机控制台/">饥荒联机控制台</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/Game/DoNotStarve/饥荒Linux服务器/">饥荒Linux服务器搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/28/Unix/Command/输出重定向/">Linux 输出重定向</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/26/C_C++/模板和元编程/C++编译期备忘录/">C++ 编译期 备忘录</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/25/C_C++/模板和元编程/C++typename用法/">C++ typename 用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/25/C_C++/模板和元编程/C++模板元编程书上习题/">C++模板元编程书上习题（待续</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/22/C_C++/模板和元编程/C++模板元编程/">C++模板元编程(待续</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/20/C_C++/C++Collection/C++基础/">C++ 基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/20/C_C++/Tips/C++和Java的引用/">C++和Java的引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/18/Network/IO模型/Reactor/">高性能IO之Reactor模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/18/Database/Redis/Redis设计与实现/">Redis 设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/17/Database/Redis/Mac 下 Redis 使用/">Mac 下 Redis 使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/10/Operating System/操作系统背诵点/">操作系统期末背诵点</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/05/QT/QT入门/">QT 入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/04/QT/QString/">QString与char*的相互转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/28/Algorithm/排序算法/">排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/24/Network/Tcp/TCP网络拥塞控制/">TCP网络拥塞控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/15/Unix/Programming/Makefile学习/">Makefile学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/07/C_C++/C++Collection/C++STL/">C++ STL</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/07/Algorithm/查找树/">查找树</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/06/Database/SQLserver/远程登入sqlserver/">远程登入 SQL server</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Database/Mysql/mysql c api/">mysql c&c++ api</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Database/Mysql/mac 使用 mysql/">mac 使用 mysql</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/C_C++/Tips/C++显式实例化的用途/">C++显式实例化的用途</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/C_C++/Tips/C++ofstream输出为1的情况/">fstream输出为1的情况</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Backend/Dreamweaver服务器配置/">Dreamweaver 连接到 Linux 云服务器 php</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Macos/Mac杂项记录/">Mac杂项</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Macos/mac软件推荐/">mac软件推荐</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Raspberrypi/树莓派安装kali/">树莓派安装kali</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/30/Script Language/Perl/Perl入门/">Perl 入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/29/Unix/Command/vim备忘录/">vim备忘录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/C_C++/Concept_gcc/标准IO的三类缓冲/">标准IO的三类缓冲</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/25/C_C++/Tips/C++小Tips/">C++ Tips</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/22/Network/Wireshark/Wireshark入门/">Wireshark 入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/22/Unix/Command/Linux不常用小命令/">Linux 不常用命令(待续</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/22/C_C++/Tips/C++类与结构区别/">C++中结构体和类的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/17/Security/DDos/DDos攻击详解/">DDos 攻击详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/17/Network/Wireshark/qq好友IP定位/">qq好友IP定位</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Backend/apache删除后Nginx显示Apache界面/">apache删除后使用Nginx服务仍然显示Apache界面</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Unix/Proxy/Socks5/">Linux搭建Socks5 Proxy</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/14/Network/IO模型/epoll/">epoll</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/Unix/Command/sed/">sed 命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/12/Unix/Command/awk/">awk 命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/Unix/Command/nmap/">nmap</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/Unix/System/使用过的端口/">使用过的端口(待续</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/Macos/mac显示隐藏文件/">macos 显示隐藏文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/Mess/win逆向工程(弃)/">win逆向工程（放弃）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/01/Mess/计算机专业名词/">计算机专业名词记录(放弃更新）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/01/C_C++/Concept_gcc/不可重入函数/">不可重入函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/29/Unix/System/Linux日志文件分析/">Linux 日志文件分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/26/Unix/Programming/解释器文件/">解释器文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/26/Script Language/Python/Python杂记/">Python 杂记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/18/Database/SQLserver/mssql实验/">mssql实验(放弃更新)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/06/Database/Mysql/mysql 命令/">mysql 命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/06/Database/Mysql/mysql大小写区分/">mysql大小写区分</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/05/Unix/Programming/CMake入门/">CMake入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/04/Macos/mac平台开发工具/">我用的mac平台开发工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/02/Mess/vultr问题集/">vultr 问题集</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/02/Unix/System/Linux备忘录/">Linux备忘录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/20/Network/Unp/unp_code/">《unp》源代码问题笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/20/Database/PostgreSQL/C++ connector for PostgreSQL/">C++ connector for PostgreSQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/17/Database/PostgreSQL/PostgreSQL 命令/">PostgreSQL 命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/17/Database/PostgreSQL/Mac 下 PostgreSQL /">Mac 下 PostgreSQL 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/17/Macos/macos apache problem/">macos apache problem</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/15/Database/Mysql/mysql创建时间和更新时间/">mysql创建时间和更新时间</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/15/Database/Mysql/远程连接mysql/">远程连接mysql</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/14/Database/PostgreSQL/Linux 下 PostgreSQL/">Linux 下 PostgreSQL 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/Backend/php入门/">php入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/Frontend/DTD入门/">DTD入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/Mess/File structure/mp3文件格式/">mp3文件格式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/ipv6/">CCIE ipv6</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/bgp/">CCIE bgp</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/逻辑子接口/">CCIE 逻辑子接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/重分发 /">CCIE 重分发</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/交换机基础/">CCIE 交换机基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/防火墙/">CCIE 防火墙</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/MPLS/">CCIE MPLS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/跨域的多播/">CCIE 跨域的多播</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/IS-IS/">CCIE IS-IS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/多播/">CCIE 多播（multicast）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/IPSEC VPN/">CCIE IPSEC VPN</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/IS-IS协议/">CCIE IS-IS协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/BGP 补充知识/">CCIE BGP 补充知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/STP生成树协议/">CCIE STP生成树协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/NAT 地址转换协议/">CCIE NAT 地址转换协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/acl控制/">CCIE acl控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/MPLS VPN/">CCIE MPLS VPN</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/DM-VPN/">CCIE DM-VPN</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/网络知识总结/">CCIE 网络知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/Network/Ccie/路由协议分类/">CCIE 路由协议分类</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/13/C_C++/Concept_gcc/gcc_gdb备忘录/">gcc_gdb备忘录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/18/Frontend/Javascript入门/">Javascript 入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/12/Frontend/XML入门/">XML入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/12/Database/Mysql/mysql用户名及密码/">mysql用户名及密码</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/03/Database/Mysql/centos彻底删除mysql/">centos彻底删除mysql</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/25/Security/无线安全/Dsniff/">Dsniff</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/24/Backend/base64原理/">Base64原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/18/Security/无线安全/reaver/">reaver</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/15/Security/无线安全/wireshark fatal IO error 2/">kali vnc wireshark fatal IO error 2</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/15/Security/无线安全/Aircrack-ng/">Aircrack-ng</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/10/C_C++/C++Collection/C++11/">C++11（待续</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/03/Frontend/HTMLl5+CSS3入门/">HTML5+CSS3入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/03/Frontend/Html入门/">Html入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/03/Frontend/CSS入门/">CSS入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/25/Algorithm/DFS/">DFS BFS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/26/Script Language/Python/懒得整理的python学习笔记/">懒得整理的python学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/13/Unix/Programming/Shell入门/">shell程序设计入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/10/Mess/Markdown/">Markdown标记语言</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2019 Skuaka
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 1;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>