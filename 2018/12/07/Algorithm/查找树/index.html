<!DOCTYPE html>
<html lang="zh-cmn-Hans">
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <meta http-equiv="”Cache-Control”" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  
  <title>查找树 | Skuaka</title>
  <link rel="icon" type="image/png" sizes="32x32" href>
  



<link rel="stylesheet" href="/./vendor.ec1199.css"><link rel="stylesheet" href="/./app.5ed5af.css">


</head>
  <body>
    <header class="main-header">
  <div class="container">
    <a href="/" " class="logo">
      <img src="logo.jpg" alt="Skuaka" class="logo-img">
    </a>
    <span class="nav-separator"></span>
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索文章"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
    <a href="javascript:void(0);" class="nav-icon">
      <i class="fas fa-bars"></i>
    </a>
    <nav class="main-nav">
      <ul class="nav-list">
        
          <li class="nav-link ">
            <a href="/">首页</a>
          </li>
        
          <li class="nav-link ">
            <a href="/archives/">归档</a>
          </li>
        
          <li class="nav-link ">
            <a href="/categories">分类</a>
          </li>
        
          <li class="nav-link ">
            <a href="/about.html">关于</a>
          </li>
        
      </ul>
    </nav>
  </div>
</header>
    <div class="page--article">
  
    <div class="toc-container">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#树"><span class="toc-number">1.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#线段树"><span class="toc-number">1.1.</span> <span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#平衡查找树"><span class="toc-number">1.2.</span> <span class="toc-text">平衡查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3查找树"><span class="toc-number">1.2.1.</span> <span class="toc-text">2-3查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查找"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插入"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">插入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#向2-结点中插入"><span class="toc-number">1.2.1.3.1.</span> <span class="toc-text">向2-结点中插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#向自身为树根的3-结点中插入"><span class="toc-number">1.2.1.3.2.</span> <span class="toc-text">向自身为树根的3-结点中插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#向父结点为2-结点的3-结点中插入"><span class="toc-number">1.2.1.3.3.</span> <span class="toc-text">向父结点为2-结点的3-结点中插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#向父结点为3-结点的3-结点中插入"><span class="toc-number">1.2.1.3.4.</span> <span class="toc-text">向父结点为3-结点的3-结点中插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#插入总结"><span class="toc-number">1.2.1.3.5.</span> <span class="toc-text">插入总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优点"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#红黑二叉查找树"><span class="toc-number">1.2.2.</span> <span class="toc-text">红黑二叉查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义-1"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#用红链接替换3-结点"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">用红链接替换3-结点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优点-1"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#颜色表示"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">颜色表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插入-1"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">插入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#旋转"><span class="toc-number">1.2.2.4.1.</span> <span class="toc-text">旋转</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#向2-结点中插入-1"><span class="toc-number">1.2.2.4.2.</span> <span class="toc-text">向2-结点中插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#向一颗双键树（即一个3-结点）中插入"><span class="toc-number">1.2.2.4.3.</span> <span class="toc-text">向一颗双键树（即一个3-结点）中插入</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造-1"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">构造</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#平衡二叉树（AVL树）"><span class="toc-number">1.2.3.</span> <span class="toc-text">平衡二叉树（AVL树）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义-2"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">定义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B树和B-树"><span class="toc-number">1.3.</span> <span class="toc-text">B树和B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B树"><span class="toc-number">1.3.1.</span> <span class="toc-text">B树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-树"><span class="toc-number">1.3.2.</span> <span class="toc-text">B+树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区别"><span class="toc-number">1.3.3.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分析"><span class="toc-number">1.3.4.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-树-1"><span class="toc-number">1.3.5.</span> <span class="toc-text">B*树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结束"><span class="toc-number">2.</span> <span class="toc-text">结束</span></a></li></ol>
      <div class="toc-tip">Table of Contents ▼</div>
    </div>
  


  <div class="container">
    <article>
      <h1>查找树</h1>
      <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。</p>
<p>使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN)。而未优化的空间复杂度为2N，实际应用时一般还要开4N的数组以免越界，因此有时需要离散化让空间压缩。</p>
<p><img src="Picture/线段树00.png" alt="线段树00"></p>
<h2 id="平衡查找树"><a href="#平衡查找树" class="headerlink" title="平衡查找树"></a>平衡查找树</h2><p>在一颗含有N个结点的树中，我们希望树高为~lgN，这样我们就能保证所有查找都能在~lgN此比较内结束，就和二分查找一样。不幸的是，在动态插入中保证树的完美平衡的代价太高了。我们放松对完美平衡的要求，使符号表API中所有操作均能够在对数时间内完成。</p>
<h3 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p>为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键。</p>
<p>2-结点：含有一个键(及值)和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。</p>
<p>3-结点：含有两个键(及值)和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。</p>
<p><img src="Picture/2-3树01.jpeg" alt="2-3树"></p>
<p>一颗完美平衡的2-3查找树中的所有空链接到根结点的距离都是相同的。</p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中的任何一个相等，查找命中。否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中。</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>要在2-3树中插入一个新结点，我们可以和二叉查找树一样先进行一次未命中的查找，然后把新结点挂在树的底部。但这样的话树无法保持完美平衡性。<strong>我们使用2-3树的主要原因就在于它能够在插入之后继续保持平衡。</strong></p>
<h5 id="向2-结点中插入"><a href="#向2-结点中插入" class="headerlink" title="向2-结点中插入"></a>向2-结点中插入</h5><p>如果未命中的查找结束于一个2-结点，我们只要把这个2-结点替换为一个3-结点，将要插入的键保存在其中即可。</p>
<h5 id="向自身为树根的3-结点中插入"><a href="#向自身为树根的3-结点中插入" class="headerlink" title="向自身为树根的3-结点中插入"></a>向自身为树根的3-结点中插入</h5><p>只有一个3-结点的树，向其插入一个新键。</p>
<p>这棵树唯一的结点中已经没有可插入的空间了。我们又不能把新键插在其空结点上（破坏了完美平衡）。为了将新键插入，我们先临时将新键存入该结点中，使之成为一个4-结点。</p>
<p>创建一个4-结点很方便，因为很容易将它转换为一颗由3个2-结点组成的2-3树（如图所示），这棵树既是一颗含有3个结点的二叉查找树，同时也是一颗完美平衡的2-3树，其中所有空链接到根结点的距离都相等。</p>
<p><img src="Picture/2-3树02.jpeg" alt="2-3树02"></p>
<h5 id="向父结点为2-结点的3-结点中插入"><a href="#向父结点为2-结点的3-结点中插入" class="headerlink" title="向父结点为2-结点的3-结点中插入"></a>向父结点为2-结点的3-结点中插入</h5><p>我们先像刚才一样构造一个临时的4-结点并将其分解，但此时我们不会为中键创建一个新结点，而是将其移动至原来的父结点中。</p>
<p><img src="Picture/2-3树03.jpeg" alt="2-3树03"></p>
<h5 id="向父结点为3-结点的3-结点中插入"><a href="#向父结点为3-结点的3-结点中插入" class="headerlink" title="向父结点为3-结点的3-结点中插入"></a>向父结点为3-结点的3-结点中插入</h5><p>我们再次和刚才一样构造一个临时的4-结点并分解它，然后将它的中键插入它的父结点中。但父结点也是一个3-结点，因此我们再用这个中键构造一个新的临时4-结点，然后在这个结点上进行相同的变换，即分解这个父结点并将它的中键插入到它的父结点中去。</p>
<p>我们就这样一直向上不断分解临时的4-结点并将中键插入更高的父结点，直至遇到一个2-结点并将它替换为一个不需要继续分解的3-结点，或者是到达3-结点的根。</p>
<p><img src="Picture/2-3树04.jpeg" alt="2-3树04"></p>
<h5 id="插入总结"><a href="#插入总结" class="headerlink" title="插入总结"></a>插入总结</h5><p>先找插入结点，若结点有空(即2-结点)，则直接插入。如结点没空(即3-结点)，则插入使其临时容纳这个元素，然后分裂此结点，把中间元素移到其父结点中。对父结点亦如此处理。（中键一直往上移，直到找到空位，在此过程中没有空位就先搞个临时的，再分裂。）</p>
<p> ★2-3树插入算法的根本在于这些变换都是局部的：除了相关的结点和链接之外不必修改或者检查树的其他部分。每次变换中，变更的链接数量不会超过一个很小的常数。所有局部变换都不会影响整棵树的有序性和平衡性。</p>
<h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>和标准的二叉查找树由上向下生长不同，2-3树的生长是由下向上的。</p>
<p><img src="Picture/2-3树05.jpeg" alt="2-3树05"></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>2-3树在最坏情况下仍有较好的性能。每个操作中处理每个结点的时间都不会超过一个很小的常数，且这两个操作都只会访问一条路径上的结点，所以任何查找或者插入的成本都肯定不会超过对数级别。</p>
<p>完美平衡的2-3树要平展的多。例如，含有10亿个结点的一颗2-3树的高度仅在19到30之间。我们最多只需要访问30个结点就能在10亿个键中进行任意查找和插入操作。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>我们需要维护两种不同类型的结点，查找和插入操作的实现需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。</p>
<p>平衡一棵树的初衷是为了消除最坏情况，但我们希望这种保障所需的代码能够越少越好。</p>
<h3 id="红黑二叉查找树"><a href="#红黑二叉查找树" class="headerlink" title="红黑二叉查找树"></a>红黑二叉查找树</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>若是要在代码级理解红黑树，则势必需要记住其复杂的插入和旋转的各种情况，我认为那只有助于增加大家对红黑树的恐惧，实际面试和工作中几乎不会遇到需要自己动手实现红黑树的情况(很多语言的标准库中就有红黑树的实现)。 </p>
<p>☆理解红黑树一句话就够了：<strong>红黑树就是用红链接表示3-结点的2-3树</strong>。</p>
<p>那么红黑树的插入、构造就可转化为2-3树的问题。这样，我们就不用记那么复杂且让人头疼的红黑树插入旋转的各种情况了。只要清楚2-3树的插入方式即可。</p>
<p><strong>红黑树的本质</strong>：</p>
<p>红黑树是对2-3查找树的改进，它能用一种统一的方式完成所有变换。</p>
<h5 id="用红链接替换3-结点"><a href="#用红链接替换3-结点" class="headerlink" title="用红链接替换3-结点"></a>用红链接替换3-结点</h5><p>★红黑树背后的思想是用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。</p>
<p>我们将树中的链接分为两种类型：</p>
<p><strong>黑链接</strong>是2-3树中的普通链接。</p>
<p><strong>红链接</strong>将两个2-结点连接起来构成一个3-结点，确切地说，我们将3-结点表示为由一条<strong>左斜</strong>的红色链接相连的两个2-结点。</p>
<p>这种表示法的一个优点是，我们无需修改就可以直接使用标准二叉查找树的get()方法。对于任意的2-3树，只要对结点进行转换，我们都可以立即派生出一颗对应的二叉查找树。我们将用这种方式表示2-3树的二叉查找树称为红黑树。</p>
<p><img src="Picture/2-3树06.jpeg" alt="2-3树06"></p>
<p><strong>红黑树的另一种定义</strong>是满足下列条件的二叉查找树：</p>
<p>⑴红链接均为左链接。</p>
<p>⑵没有任何一个结点同时和两条红链接相连。</p>
<p>⑶<strong>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同</strong>。</p>
<p><strong>如果我们将一颗红黑树中的红链接画平，那么所有的空链接到根结点的距离都将是相同的</strong>。如果我们将由红链接相连的结点合并，得到的就是一颗2-3树。</p>
<p>相反，如果将一颗2-3树中的3-结点画作由红色左链接相连的两个2-结点，那么不会存在能够和两条红链接相连的结点，且树必然是完美平衡的。</p>
<p><img src="Picture/2-3树07.jpeg" alt="2-3树07"></p>
<p>无论我们用何种方式去定义它们，红黑树都既是二叉查找树，也是2-3树。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>2-3树的深度很小，平衡性好，效率高，但是其有两种不同的结点，实际代码实现比较复杂。而红黑树用红链接表示2-3树中另类的3-结点，统一了树中的结点类型，使代码实现简单化，又不破坏其高效性。</p>
<h4 id="颜色表示"><a href="#颜色表示" class="headerlink" title="颜色表示"></a>颜色表示</h4><p>因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们将链接的颜色保存在表示结点的Node数据类型的布尔变量color中（若指向它的链接是红色的，那么该变量为true，黑色则为false）。</p>
<p>当我们提到一个结点颜色时，我们指的是指向该结点的链接的颜色。</p>
<h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><h5 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h5><p>在我们实现的某些操作中可能会出现红色右链接或者两条连续的红链接，但在操作完成前这些情况都会被小心地旋转并修复。</p>
<p>（我们在这里不讨论旋转的几种情况，把红黑树看做2-3树，自然可以得到正确的旋转后结果）</p>
<p>在插入时我们可以使用旋转操作帮助我们保证2-3树和红黑树之间的一一对应关系，因为旋转操作可以保持红黑树的两个重要性质：有序性和完美平衡性。</p>
<h5 id="向2-结点中插入-1"><a href="#向2-结点中插入-1" class="headerlink" title="向2-结点中插入"></a>向2-结点中插入</h5><p>向红黑树中插入操作时，想想2-3树的插入操作。红黑树与2-3树在本质上是相同的，只是它们对3结点的表示不同。</p>
<p>向一个只含有一个2-结点的2-3树中插入新键后，2-结点变为3-结点。我们再把这个3-结点转化为红结点即可。</p>
<p><img src="Picture/2-3树08.jpeg" alt="2-3树08"></p>
<p>（这图一开始没看懂，再仔细想：2-3树如果命中结点是2-结点，则直接成为3-结点，既然是3-结点了，所以要用红链接表示）</p>
<h5 id="向一颗双键树（即一个3-结点）中插入"><a href="#向一颗双键树（即一个3-结点）中插入" class="headerlink" title="向一颗双键树（即一个3-结点）中插入"></a>向一颗双键树（即一个3-结点）中插入</h5><p>向红黑树中插入操作时，想想2-3树的插入操作。你把红黑树当做2-3树来处理插入，一切都变得简单了。</p>
<p>向2-3树中的一个3-结点插入新键，这个3结点临时成为4-结点，然后分裂成3个2结点</p>
<p><img src="Picture/2-3树09.jpeg" alt="2-3树09"></p>
<h4 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h4><p><img src="Picture/2-3树10.png" alt="2-3树10"></p>
<h3 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>平衡二叉树(Balance Binary Tree)又称AVL树。</p>
<p>它或者是一颗空树，或者是具有下列性质的二叉树：</p>
<ol>
<li>它的左子树和右子树都是平衡二叉树</li>
<li>左子树和右子树的深度之差的绝对值不超过1。</li>
</ol>
<p>其旋转操作 用2-3树的分裂来类比想象。</p>
<h2 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h2><p>B树和B-树是同一种树，只不过英语中B-tree被中国人翻译成了B-树，让人以为B树和B-树是两种树，实际上，两者就是同一种树，</p>
<p>M为设定的非叶子结点最多子树个数，N为关键字总数。</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p><strong>B 树</strong>可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。</p>
<ul>
<li>根节点至少有两个子节点</li>
<li>每个节点有M-1个key，并且以升序排列</li>
<li>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</li>
<li>其它节点至少有M/2个子节点</li>
</ul>
<p>B树的插入及平衡化操作和2-3树很相似，B-树的性能总是等价于二分查找（与M值无关）。</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p><strong>B+</strong>树是对B树的一种变形树，它与B树的差异在于：</p>
<ul>
<li>有k个子结点的结点必然有k个关键码；</li>
<li>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。</li>
<li>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。</p>
<p>B+ 树的优点在于：</p>
<ul>
<li>由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。</li>
<li>B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</li>
</ul>
<p>但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。下面是B 树和B+树的区别图：</p>
<p><img src="Picture/B树01.png" alt="B树01"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对B树和B+树的分析和对前面讲解的2-3树的分析类似，</p>
<p>对于一颗节点为N度为M的子树，查找和插入需要logM-1N ~ logM/2N次比较。这个很好证明，对于度为M的B树，每一个节点的子节点个数为M/2 到 M-1之间，所以树的高度在logM-1N至logM/2N之间。</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h3><p>在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1>
  </article>
    
  </div>
</div>

    <footer class="main-footer">
  <div class="container">
    © 2018 
  </div>
</footer>
    



<script src="/./runtime.32f029.js"></script><script src="/./vendor.ec1199.js"></script><script src="/./app.5ed5af.js"></script>


  </body>
</html>
